<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Active Time, Size, Acceptance Tests, and Performance</title>
</head>

<body>

<p>Background</p>
<p>Based on our work with Hackystat outside of HPC, and Mike Paulding's HPC-specific
work on the Truss PBB, we have been focusing our attention on the following
measurements:</p>
<p><b>Active Time.</b>&nbsp; This is a measure of the time spent by developers
editing source code (or other files) related to the system.&nbsp; Active Time
can be collected automatically through the use of sensors attached to the editor
used by developers.&nbsp; Active Time does not reflect effort spent by
developers on the project that occurs outside of editing, such as time spent in
meetings, time spent in reviews, time spent on the telephone, time spent in the
shower, and so forth.&nbsp; Active Time is useful in the HPC context as a proxy
for overall effort. </p>
<p><b>Most Active File.</b>&nbsp; A measure related to Active Time is the
&quot;Most Active File&quot;.&nbsp; One way to abstract the raw event stream
sent from an editor-based Hackystat server is to divide the day up into 288 five
minute intervals, and if the developer was actively editing files within a five
minute period, to determine which file was edited most during that five minutes,
and assign the &quot;credit&quot; for that five minutes to that file and that
file alone. (We performed a calibration study which found this to be a
reasonable abstraction.)&nbsp;&nbsp; The Most Active File abstraction is useful
in the HPC context as a way of determining what specific files were the focus of
developer attention, and how that focus of attention changed over the course of
development.</p>
<p><b>Command Line Invocations. </b>In addition to time spent editing files in
an editor, HPC development frequently involves extensive use of program
invocation in a shell process, such as make, gcc, etc.&nbsp; We have implemented
a sensor for the Unix command shell (based upon the 'history' shell mechanism)
to record command line invocations. Command Line Invocation data is useful in
the HPC context as a way of providing further insight into the types of
activities performed by developers during the development of the HPC
code.&nbsp;&nbsp; For example, if the HPC developer spends significant time
working at the command line without concurrent editing of code, then it might be
useful to develop an enhanced representation of Active Time that accounts for
this type of effort as well. While the current sensor only captures command
invocations and not their results, it would be useful to extend the sensor to
capture results in certain circumstances. For example, recording whether or not
a compilation succeeded or failed as well as what types of run-time errors occur
could help identify potential productivity bottlenecks.</p>
<p><b>Parallel and Serial Lines of Code.</b> We have enhanced our size
measurement tool, LOCC, with a token-based counter for C++ that allows us to
count non-comment source lines of code, and determine for each line of code
whether or not an MPI directive occurs on it.&nbsp; Thus, for HPC programs built
using C++ and MPI, we can determine (a) the total number of files in the system,
(b) the total non-commented size of each file in the system; (c) whether or not
a file consists purely of serial (non-MPI) code or not; (d) for files containing
MPI directives, the frequency of occurrence of each MPI directive; and (e) for
files containing MPI code, what percentage of the non-comment source lines of
code contained an MPI directive.&nbsp; We hope it will be straightforward to
extend this approach to support other languages (such as Fortran) and other HPC
packages (such as OpenMP).&nbsp; Parallel and Serial LOC measurement is useful
in the HPC context by providing insight into how the code evolves during the
course of development, both with respect to its overall size, as well as with
respect to the kinds of parallel constructs that occur in it and their
evolution. </p>
<p>While these four measures appear to interesting and worth the effort required
for their collection and analysis, I have been troubled</p>

</body>

</html>
