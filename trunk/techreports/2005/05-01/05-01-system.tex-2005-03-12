%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Latex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 05-01-system.tex -- Thesis Proposal - PRI
%% Author          : Aaron A. Kagawa
%% Created On      : Mon Sep 23 11:52:28 2004
%% Last Modified By: Aaron Kagawa
%% Last Modified On: Mon Mar  7 12:45:58 2005
%% RCS: $Id$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Copyright (C) 2004 Aaron A. Kagawa
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Hackystat Priority Ranked Inspection Extension}
\label{chapter:system}
To successfully use Priority Ranked Inspection, the determination of MINI
and LINI must be obtainable for a very low cost. In other words, if the
ranking function takes three months to generate, a software project will
have long past the need for those specific recommendations. Therefore, this
determination must be obtained in real-time.

One way of obtaining ranking function values in real-time is through the
use of the Hackystat system. Hackystat is a framework for collecting and
analyzing software product and development process metrics in real-time.
For more information about the Hackystat system see Chapter
\ref{chapter:hackystat}.  For this proposed research, I have created an
extension to Hackystat called the Hackystat Priority Ranked Inspection
Extension (hackyPRI for short). This extension provides a real-time PRI
ranking. Figure \ref{fig:WorkspaceQualityAnalysis} demonstrates the use
of the PRI ranking function by ranking a software project's workspaces.

This chapter provides a detailed description of the Hackystat PRI
(hackyPRI) extension. First, I will provide a detailed description of PRI
measures. Second, I will provide a detailed explanation of the design and
implementation of the system. Third, I will discuss how hackyPRI supports
the four steps of the Priority Ranked Inspection process. Last, I will
discuss the hackyPRI user interface. 

\section{PRI Measures}
PRI measures are the most important and most complicated component of
hackyPRI. There are three fundamental aspects that must be understood. They
are the collection of PRI measures, the different types of PRI measures,
and the ranking of the PRI measures. The following sections introduces
these concepts. 

\subsection{Collection of PRI Measures}
PRI measures represent software product and development process measures
that aid the determination of MINI and LINI documents. In the general
Priority Ranked Process, PRI measures can be collected by any means. In
hackyPRI, the Hackystat system is used to automate the collection of the
PRI measures. In Hackystat, a product and process measure is implemented
with three components. They are the Sensor Data Type, Sensor, and
DailyProjectData representation. A Sensor Data Type defines the attributes
associated with a measure. A Sensor is used to collect the measures in the
software product or development process and send that information to a
Hackystat server. The DailyProjectData representation provides a
project-level representation of the low-level data that was collected by
the Sensors. hackyPRI requires the use of these three components, therefore
to successfully implement a PRI measure one must have the necessary
Hackystat knowledge. In addition to the three Hackystat components;
hackyPRI implements another component that represents a PRI
measure. Section \ref{section:designAndImplementation} explains the
implementation of PRI measures in detail.

\subsection{Aggregate and Snapshot Measures}
There are two different types of PRI measures. They are Aggregate and
Snapshot measures. An Aggregate PRI measure is the result of the summation
of calculated values obtained from processing more than day of Hackystat
Sensor Data. For example, the Active Time PRI measure is an Aggregate
measure because it adds the values of active time over a specified time
period. Snapshot measures are not aggregated. Instead, it represents a
single value from a single day of Hackystat data. For example, the LOC
(lines of code) measure does not make sense as an Aggregate measure.
Therefore, LOC is a Snapshot PRI measure. In hackyPRI, Aggregate and
Snapshot measures must be implemented differently. Therefore, the decision 
of the type of PRI measure (either Aggregate or Snapshot) must be made
carefully. 

\subsection{PRI Measure Ranking Function and Threshold}
hackyPRI calculates a set of PRI measures for a single workspaces. To
better illustrate this, see Figure \ref{fig:WorkspaceQualityAnalysis}. In
this figure, one workspace has values gathered from many different PRI
measures. Each individual PRI measure can and should be calibrated
differently to rank its calculated values to best represent a MINI and LINI 
determination. The calibration of a PRI measure includes three
parts. First, each PRI measure defines certain numerical thresholds that
represent good, normal and bad calculated values. Second, these thresholds
define the PRI rank of each PRI measure. Third, all PRI rankings are
aggregated to provide an overall Workspace Ranking. 

For example, if the coverage of a package is below 80 percent threshold,
the PRI Coverage measure returns a ``bad'' ranking. If the coverage of a
package is 100 percent, then the PRI Coverage measure returns a ``good''
ranking. If the coverage of a package is between the 80 and 100 percent
thresholds, then the PRI Coverage measure returns a ``normal'' ranking.


\section{Design and Implementation}
\label{section:designAndImplementation}
This section describes the design and implementation of the Hackystat PRI
Extension. This extension was implemented in two evolutions; version 1.0
and version 2.0. In the following sections, I will describe both versions.
Version 2.0 is the current version and therefore learning about the design
and implementation impracticable. However, I present the design and
implementation of version 1.0 to provide a historical account of the
choices that were made in the system's initial design.


\subsection{hackyPRI version 1.0}
I began the implementation of the first version of hackyPRI in September
2004. In this section, I will describe the design of version 1.0.  I will
also identify some of the problems associated with its design that has
forced a complete redesign of the system in hackyPRI version 2.0. 

%%This initial version, required approximately 10.7 hours of Hackystat
%%active time. 

\subsubsection{Design and Implementation}
Version 1.0 was created with a very simple design and consists of two main
classes; WorkspacePri and ProjectWorkspacePri. The WorkspacePri class was
designed to represent a single workspace and its associated PRI measures.
The ProjectWorkspacePri class was designed to access Hackystat's product
and process measures, extract the measures' values, and create WorkspacePri
objects.

The WorkspacePri class stores the values of the PRI measures and when
requested provides the PRI ranking based on its calibration. Table
\ref{table:hackyPriv1-WorkspacePri} is a portion of the WorkspacePri code
that handles the Commit Measure. In addition to the Commit measure, the
WorkspacePri class provides methods, similar to the methods presented in
Table \ref{table:hackyPriv1-WorkspacePri}, for 8 other PRI measures.
Furthermore, this single class mixes Aggregate and Snapshot PRI measures
into one single Java class.

The ProjectWorkspacePri class is the workhorse of the system. Its job is to
access and gather Hackystat's product and process measures to create
WorkspacePri objects. Table
\ref{table:hackyPriv1-ProjectWorkspacePri-algorithm} presents the basic
algorithm used in the ProjectWorkspacePri class in pseudo-code form. Table
\ref{table:hackyPriv1-ProjectWorkspacePri} is a portion of the
ProjectWorkspacePri code that creates and populates the WorkspacePri Commit
measure. The ProjectWorkspacePri code utilizes Hackystat to gather the
Commit information for a specified project. In addition to the Commit
measure, the ProjectWorkspacePri class accesses Hackystat to retrieve
information for 8 other product and process measures.

\begin{table}[htbp]
  \begin{center}
    \caption{WorkspacePri code that handles the Commit measure and its calibration}
    \label{table:hackyPriv1-WorkspacePri}
    \begin{tabular}{|p{14.0cm}|} \hline

\begin{alltt}{\scriptsize{}
 /**
  * Adds the number of commits.
  * @param commit The number of commits to add.
  * @param day The day of the commit.
  */
 public void addCommit(double commit, Day day) \{
   if (commit > 0) this.lastCommitDay = day;
   this.commit += commit;
 \}

 /**
  * Returns the number of commits.
  * @return The number of commits.
  */
 public int getCommit() \{
   return this.commit;
 \}

 /**
  * Returns the day of the last commit.
  * @return The day of the last commit.
  */
 public Day getLastCommitDay() \{
   return this.lastCommitDay;
 \}

 /**
  * Adds the user to the member commit map.
  * @param member The member to add to the commit map.
  * @param memberCommit The number of commits associated with 
  *   the specified member.
  */
 public void addMemberCommit(User member, int memberCommit) \{
   int temp = 0;
   if (this.memberCommitMap.containsKey(member.getUserEmail())) \{
     temp = ((Integer)this.memberCommitMap.get(member.getUserEmail())).intValue();
   \}
   this.memberCommitMap.put(member.getUserEmail(), 
     new Integer(temp + memberCommit));
 \}

 /**
  * Returns the number of members who committed to the workspace.
  * @return The number of members who committed to the workspace.
  */
 public int getMemberCommitSize() \{
   return this.memberCommitMap.size();
 \} 

 /**
  * Returns the pri ranking of the member commit map.
  * @return The pri ranking level.
  */
 public int getMemberCommitPriRank() \{
   if (this.memberCommitMap.size() >= 3) this.memberCommitPriRank = 2;
   else if (this.memberCommitMap.size() == 2) this.memberCommitPriRank = 1;
   return this.memberCommitPriRank;
 \} 
}\end{alltt} \\ \hline

    \end{tabular}
  \end{center}
\end{table}


\begin{table}[htbp]
  \begin{center}
    \caption{ProjectWorkspacePri algorithm}
    \label{table:hackyPriv1-ProjectWorkspacePri-algorithm}
    \begin{tabular}{|p{14.0cm}|} \hline


\begin{alltt}{\scriptsize{}
FOR each day starting from the project's end day to the project's start day
  IF the daily build is buildSuccessful
    successfulBuildDay = currentDay
  END IF
END FOR

FOR each day starting from the project's start day to the project's end day
  create new WorkspacePri object or retrieve from cache
  IF day is equal to successFulBuildDay
    process snapshot product and process measures and add value
      to WorkspacePri object
  END IF
  process aggregate product and process measures and add value
    to WorkspacePri object
END FOR 

Rank according to PRI ranking determined by the WorkspacePri calibration
}\end{alltt}
\\ \hline
    \end{tabular}
  \end{center}
\end{table}


\begin{table}[htbp]
  \begin{center}
    \caption{ProjectWorkspacePri code that creates the WorkspacePri Commit measure}
    \label{table:hackyPriv1-ProjectWorkspacePri}
    \begin{tabular}{|p{14.0cm}|} \hline

\begin{alltt}{\scriptsize{}
 for (Iterator j = this.project.getMembers().iterator(); j.hasNext(); ) \{
   User member = (User) j.next();
   int memberCommit = DailyProjectCommit.getInstance(this.project, 
     day).getNumOfCommits(member, filePattern);
   if (memberCommit > 0) \{
     workspacePri.addMemberCommit(member, memberCommit);
   \}
 \}
 workspacePri.addCommit(
   DailyProjectCommit.getInstance(this.project, 
   day).getCodeChurnInfo(filePattern).getNumOfCommits(), day);
}\end{alltt} \\ \hline

    \end{tabular}
  \end{center}
\end{table}




\subsubsection{Design and Implementation Problems}
There are two major problems with the design and implementation of hackyPRI
version 1.0. The two major problems are poor runtime performance and an
unconfigurable framework.

First, as a result of poor design, the system's execution time is
unacceptable. Version 1.0 requires 60 minutes to execute a complete PRI
ranking for the hacky2004-all Hackystat project, which contains 2 years of
Sensor Data gathered from 9 different Hackystat users (approximately 14
thousand Hackystat XML sensor data files, roughly equal to 956 Megabytes of
data). This result was collected on a computer with a 3.4 GHz Pentium 4
processor with Hyperthreading and 1.00 GB of RAM. Furthermore, the system
will need 60 minutes to process the same project's data for each and every
execution. In my opinion, this execution time violates the intended design
of ``real-time'' PRI rankings. This slow execution time hampers the ability
to properly calibrate the PRI measures.

Second, also due to poor design, the system is quite hard to extend and
configure for other software projects. For example, adding new product and
process measures and their calibration requires the maintenance two large
classes. When PRI measures are added or removed from the system, a
developer must edit a significant portion of the two classes. This problem
is a direct result of the simplicity of the design.  Step 1 of the Priority
Ranked Inspection process states that various product and process measures
must be selected and calibrated to best distinguish MINI documents from
LINI documents. This selection process will not be the same for all
software projects. Therefore, it is quite obvious that a properly designed
system will allow the configuration of different product and process
measures without having to completely redesign the system. For hackyPRI to
be successful different software projects should be able to easily extend
the current set of PRI measures and in version 1.0 this is not possible.




\subsection{hackyPRI version 2.0}
Due to various problems that I've discovered in hackyPRI version 1.0, I
decided to completely redesign the system's architecture. Unlike version
1.0, hackyPRI version 2.0 was implemented with processing time,
extendibility, and configurability in mind. However, I believe that the
implementation of version 1.0 was very important. Version 1.0 proved that
this sort of Hackystat extension is possible. Therefore, version 1.0
provided me with a baseline implementation to improve. 

%%This redesign was accomplished in approximately 18.8 hours of active time.



\subsubsection{Design and Implementation}
hackyPRI version 2.0 has a fairly complicated design. It consists of
numerous classes within two main packages; the
\emph{org.hackystat.app.pri.model.workspace} package and
the \newline \emph{org.hackystat.app.pri.model.workspace.measures}
package. In this section I will describe how both packages work.


\paragraph{Package org.hackystat.app.pri.model.workspace.measure}
\label{paragraph:measurepackage}
This package provides classes that represent the PRI measures. Each measure
implements the WorkspacePriMeasure interface, shown in its entirety in
Table \ref{table:hackyPriv2-WorkspacePriMeasure}. The purpose of this
interface is to standardize the functionality of each and every measure.
For example, each measure must be able to calculate its value, return the
calculated value in a readable form, and determine the PRI ranking based on
the calculated value. The standardization of the functionality of PRI
measures greatly improved the configurability of the system. In addition,
the interface defines four methods: isAggregateMeasure, isCacheEnabled,
writeCache, and readCache, which provide the ability to persistently save
the results of a measure for future use. Once the measure is calculated it
should not need to be re-calculated. The persistent cache greatly lowered
the required execution time for version 2.0.

A specific example of one of the PRI measures is the
Commit Contribution measure. Like all PRI measures within hackyPRI, the
Commit Contribution measure implements the WorkspacePriMeasure Interface
and therefore provides a standard set of functionality. Table
\ref{table:hackyPriv2-WorkspacePriCommitContribution} provides its
calculate method. The Commit Contribution PRI measure is an example of
Aggregate PRI measure. Therefore, its isAggregateMeasure and isCacheEnabled
measure both return the boolean true.

Table \ref{table:hackyPriv2-measurepackage} presents a summary listing of
all the classes in this package. 

\begin{table}[htbp]
  \begin{center}
    \caption{The WorkspacePriMeasure interface that defines the
      functionality of all PRI measures.}
    \label{table:hackyPriv2-WorkspacePriMeasure}
    \begin{tabular}{|p{14.0cm}|} \hline

\begin{alltt}{\tiny{}
  /**
   * Returns the label of this measure.
   * @return The label of this measure.
   */
  public String getLabel();
  
  /**
   * Determines if the measure is an aggregation of past data. If this method returns true,
   *   then this indicates that each day since the start day of the project is used to calculate
   *   the measure's value. If this method returns false, then the measure is calculated from 
   *   the last build day.
   * @return True if the measure is an aggregate calculation, false otherwise.
   */
  public boolean isAggregateMeasure();
  
  /**
   * Determines if the cache is enabled. Generally, measures that are calculated in an aggregation
   *   of past data is cached. 
   * @return True if the cache is enabled, false otherwise.
   */
  public boolean isCacheEnabled();
  
  /**
   * Calculates and returns the value of the PRI measure for the specified workspace and day.
   * @param workspace Specifies the workspace to calculate the measure for.
   * @param day Specifies the day to calculate the measure for. 
   * @throws Exception If a problem occurs.
   */
  public void calculate(String workspace, Day day) throws Exception;
  
  /**
   * Returns the formatted String of the calculated value.
   * @param workspace The workspace to get the calculated value.
   * @return The formatted value.
   */
  public String formatCalculatedValue(String workspace);
  
  /**
   * Returns the PRI ranking for the value associated with the workspace.
   * @param workspace Specifies what workspace to get the PRI ranking for.
   * @return The PRI ranking for the value associated with the workspace.
   */
  public int getPriRank(String workspace);
  
  /**
   * Writes out the cache objects associated with this instance of the measure
   *   object. The collection of caches are stored in the Project owner's partitions.
   * @throws Exception If a problem occurs.
   */
  public void writeCache() throws Exception;
  
  /**
   * Reads in the cache objects associated with this instance of the measure
   *   object and creates an internal representation of the cache. The collection of caches 
   *   are stored in the Project owner's partitions.
   * @throws Exception If a problem occurs.
   */
  public void readCache() throws Exception;
}\end{alltt} \\ \hline

    \end{tabular}
  \end{center}
\end{table}


\begin{table}[htbp]
  \begin{center}
    \caption{WorkspacePriCommitContribution code that calculates the Commit 
      Contribution measure}
    \label{table:hackyPriv2-WorkspacePriCommitContribution}
    \begin{tabular}{|p{14.0cm}|} \hline

\begin{alltt}{\scriptsize{}
 /**
  * Calculates and returns the Commit Contribution PRI measures for the 
  *   specified workspace and day.
  * @param workspace Specifies the workspace to calculate the commit 
  *    contribution measure for.
  * @param day Specifies the day to calculate the commit 
  *     contribution measure for. 
  * @throws Exception If a problem occurs.
  */
 public void calculate(String workspace, Day day) throws Exception \{
   FilePattern filePattern = new FilePattern(workspace + "*.java");
   WorkspacePriCache cache = (WorkspacePriCache) 
     this.workspacePriCacheMap.get(workspace);
   if (cache == null) \{
     Data data = new Data();
     for (Iterator i = this.project.getMembers().iterator(); i.hasNext(); ) \{
       User member = (User) i.next();
       int commits = DailyProjectCommit.getInstance(this.project, 
           day).getNumOfCommits(member, filePattern);
       if (commits > 0) \{
         data.addContribution(member.getUserEmail(), commits);
       \}
     \}
     this.workspacePriCacheMap.put(workspace, 
       new WorkspacePriCache(workspace, day, data));
   \}
   // if last day is before the day then we need to update the value
   else if (cache.getLastDay().compareTo(day) < 1) \{
     Data data = (Data) cache.getValue();
     for (Iterator i = this.project.getMembers().iterator(); i.hasNext(); ) \{
       User member = (User) i.next();
       int commits = DailyProjectCommit.getInstance(this.project, 
           day).getNumOfCommits(member, filePattern);
       if (commits > 0) \{
         data.addContribution(member.getUserEmail(), commits);
       \}
     \}
     cache.replace(day);
   \}
 \}
}\end{alltt} \\ \hline

    \end{tabular}
  \end{center}
\end{table}

\begin{table}[htbp]
  \begin{center}
    \caption{WorkspacePriCommitContribution code that returns 
       the PRI ranking of the measure}
    \label{table:hackyPriv2-WorkspacePriCommitContribution-getPriRank}
    \begin{tabular}{|p{14.0cm}|} \hline
\begin{alltt}{\scriptsize{}
 /**
  * Returns the PRI ranking for the Commit Contribution value.
  * @param workspace Specifies what workspace to get the PRI ranking for.
  * @return The PRI ranking for the Commit Contribution value.
  */
 public int getPriRank(String workspace) \{
   Data commitContribution = this.getData(workspace);
   if (commitContribution.size() > 1) return 1;
   return 0;
 \}
}\end{alltt} \\ \hline
    \end{tabular}
  \end{center}
\end{table}


\begin{table}[htbp]
  \begin{center}
    \caption{WorkspacePriCommitContribution code that writes the measure to a persistent cache}
    \label{table:hackyPriv2-WorkspacePriCommitContribution-writeCache}
    \begin{tabular}{|p{14.0cm}|} \hline
\begin{alltt}{\scriptsize{}
 /**
  * Writes out the cache objects associated with this instance of the 
  *   WorkspacePriCommitContribution object. The collection 
  *   of caches are stored in the Project owner's partitions.
  * @throws Exception If a problem occurs.
  */
 public void writeCache() throws Exception \{
   Element cacheRoot = new Element("WorkspacePriCache");
   Document cacheDocument = new Document(cacheRoot);
   for (Iterator i = this.workspacePriCacheMap.values().iterator(); i.hasNext(); ) \{
     WorkspacePriCache cache = (WorkspacePriCache) i.next();
     String workspace = cache.getWorkspace();
     Day lastDay = cache.getLastDay();
     Object value = cache.getValue();
     Element entryElement = new Element("entry");
     entryElement.setAttribute("workspace", workspace);
     entryElement.setAttribute("lastDay", lastDay.toString());
     Element valuesElement = new Element("values");
     Set entrySet = ((Data) value).getEntrySet();
     for (Iterator j = entrySet.iterator(); j.hasNext();) \{
       Map.Entry entry = (Map.Entry) j.next();
       Element valueElement = new Element("value");
       valueElement.setAttribute("memberEmail", String.valueOf(entry.getKey()));
       valueElement.setAttribute("commit", String.valueOf(entry.getValue()));
       valuesElement.addContent(valueElement);
     \}
     entryElement.addContent(valuesElement);
     cacheRoot.addContent(entryElement);
   \}
   String partitionName = "PRI-" + this.project.getName()  
     + "-" + this.getLabel().replaceAll(" ", "");
   this.project.getOwner().putJDomDocument(cacheDocument, partitionName);
 \}
}\end{alltt} \\ \hline
    \end{tabular}
  \end{center}
\end{table}
  



\begin{table}[htbp]
  \begin{center}
    \caption{Summary description of all classes in the 
      org.hackystat.app.pri.model.workspace.measure package}
    \label{table:hackyPriv2-measurepackage}
    \begin{tabular}{|p{6.0cm}|p{9.0cm}|} \hline
      {\bf Class Name} & {\bf Description} \\ \hline

\small{}WorkspacePriMeasure & \small{}Provides an Interface of all PRI
measures. \\ \hline 

\small{}WorkspacePriCache & \small{}Provides an internal cache of the
calculated values of the PRI measures \\ \hline

\small{}WorkspacePriActiveTime & \small{}Provides the PRI active time
measure, which represents the total aggregate active time for each
workspace in a project.\\ \hline 

\small{}WorkspacePriActiveTimeContribution & \small{}Provides the PRI
active time contribution measure, which represents the total aggregate
number of active time member contributions for each workspace in a
project. \\ \hline  

\small{}WorkspacePriActiveTimeLast & \small{}Provides the PRI last active
time day measure, which represents the last day active time was recorded
for each workspace in a project.\\ \hline

\small{}WorkspacePriCommit & \small{}Provides the PRI commit measure, which
represents the total aggregate number of commits for each workspace in a
project. \\ \hline 

\small{}WorkspacePriCommitContribution & \small{}Provides the PRI commit
contribution measure, which represents the total aggregate number of commit
member contributions for each workspace in a project. \\ \hline

\small{}WorkspacePriCommitLast & \small{}Provides the PRI last commit day
measure, which represents the last day commit information was recorded for
each workspace in a project. \\ \hline

\small{}WorkspacePriCoverage & \small{}Provides the PRI coverage measure,
which represents the latest snapshot of the method level coverage
percentage for each workspace in a project.  \\ \hline

\small{}WorkspacePriDependency & \small{}Provides the PRI dependency
measure, which represents the latest snapshot of the number of inbound and
outbound dependency references for each workspace in a project. \\ \hline

\small{}WorkspacePriExpert & \small{}Provides the PRI expert measure, which
represents the project member who has the most active time and commits for
a each workspace in a project. \\ \hline

\small{}WorkspacePriFileMetric & \small{}Provides the PRI file metric
measure, which represents the latest snapshot of the number of lines of
code, number of methods, number of classes for each workspace in a
project.\\ \hline 

\small{}WorkspacePriIssue & \small{}Provides the PRI issue measure, which
represents the latest snapshot of the total number of relevant issues
(open, major, bug) for each workspace in a project. \\ \hline

\small{}WorkspacePriReview & \small{}Provides the PRI review measure, which
represents the total aggregate number of review issues for each workspace
in a project.  \\ \hline 

\small{}WorkspacePriReviewLast & \small{}Provides the PRI last review day
measure, which represents the last day review issues was recorded for each
workspace in a project.  \\ \hline

\small{}WorkspacePriTestFileMetric & \small{}Provides the PRI file metric
measure, which represents the latest snapshot of the number of lines of
test code,  number of test methods, number of test classes for each
workspace in a project.\\ \hline 

\small{}WorkspacePriUnitTest & \small{}Provides the PRI unit test measure,
which represents the latest snapshot of the number of executed unit tests
for each workspace in a project. \\ \hline

    \end{tabular}
  \end{center}
\end{table}


\paragraph{Package org.hackystat.app.pri.model.workspace} This package
provides classes that manage the PRI measures in the
\emph{org.hackystat.app.pri.model.workspace.measure} package. Unlike
version 1.0 where a single class was the workhorse of the system, version
2.0 evenly distributes the work among this package and the \emph{measure}
package. The \emph{workspace} package is responsible for implementing an
algorithm that delegates the responsibility of calculation to the PRI
measures.

The main class of interest in the workspace package is the
ProjectWorkspaceRanking class. Surprisingly, this class has the same
general algorithm explained in Table
\ref{table:hackyPriv1-ProjectWorkspacePri-algorithm}. However, several
implementation-level enhancements were introduced. The first major
enhancement was the elimination of lines of code similar to Table
\ref{table:hackyPriv1-ProjectWorkspacePri}. Instead, the
ProjectWorkspaceRanking class uses two pieces of code to delegate the
calculation to the PRI measures. Table
\ref{table:hackyPriv2-ProjectWorkspaceRanking} and Table
\ref{table:hackyPriv2-ProjectWorkspaceRanking-calculateMeasure} illustrate
how this class off-loads the calculation work to the PRI measures in the
\emph{measure} package. As I previously explained, each PRI measure
implements the WorkspacePriMeasure Interface and this minor implementation
design makes this delegation possible.

Table \ref{table:hackyPriv2-workspacepackage} provides a summary
description of all classes in this package. 

\begin{table}[htbp]
  \begin{center}
    \caption{Summary description of all classes in the 
      org.hackystat.app.pri.model.workspace package}
    \label{table:hackyPriv2-workspacepackage}
    \begin{tabular}{|p{6.0cm}|p{8.0cm}|} \hline
      {\bf Class Name} & {\bf Description} \\ \hline

ProjectWorkspaceRankingManager & Provides the management of a collection of 
ProjectWorkspaceRanking objects. \\ \hline

ProjectWorkspaceRanking & Provides the facilities to calculate PRI measures 
and create a ranking based on the calculated results.\\ \hline

WorkspacePriValues & Provides a collection of measure values for a
specified workspace. Used primarily for presentation purposes. \\ \hline

PriRankComparator & Provides a comparator that compares the PRI ranking
value from two WorkspacePriValues objects. \\ \hline

    \end{tabular}
  \end{center}
\end{table}


\begin{table}[htbp]
  \begin{center}
    \caption{ProjectWorkspaceRanking code that loads all PRI measures used
      in this ranking}
    \label{table:hackyPriv2-ProjectWorkspaceRanking}
    \begin{tabular}{|p{14.5cm}|} \hline

\begin{alltt}{\scriptsize{}
 /** 
  * Constructs a project workspace ranking object. And loads all PRI measures
  *   that will be used in the ranking.
  * @param project The project to process.
  */
 ProjectWorkspaceRanking(Project project) \{
   this.project = project;
   this.measureList.add(WorkspacePriActiveTime.getInstance(this.project));
   this.measureList.add(WorkspacePriActiveTimeLast.getInstance(this.project));
   this.measureList.add(WorkspacePriActiveTimeContribution.getInstance(this.project));
   this.measureList.add(WorkspacePriCommit.getInstance(this.project));
   this.measureList.add(WorkspacePriCommitLast.getInstance(this.project));
   this.measureList.add(WorkspacePriCommitContribution.getInstance(this.project));
   this.measureList.add(WorkspacePriExpert.getInstance(this.project));
   this.measureList.add(WorkspacePriReview.getInstance(this.project));
   this.measureList.add(WorkspacePriReviewLast.getInstance(this.project));
   this.measureList.add(WorkspacePriIssue.getInstance(this.project));
   this.measureList.add(WorkspacePriFileMetric.getInstance(this.project));
   this.measureList.add(WorkspacePriTestFileMetric.getInstance(this.project));
   this.measureList.add(WorkspacePriDependency.getInstance(this.project));
   this.measureList.add(WorkspacePriUnitTest.getInstance(this.project));
   this.measureList.add(WorkspacePriCoverage.getInstance(this.project));
   this.buildWorkspacePriValuesMap();
 \}
}\end{alltt} \\ \hline

    \end{tabular}
  \end{center}
\end{table}


\begin{table}[htbp]
  \begin{center}
    \caption{ProjectWorkspaceRanking code that delegates the calculation of 
      the measures to the WorkspacePriMeasure classes}
    \label{table:hackyPriv2-ProjectWorkspaceRanking-calculateMeasure}
    \begin{tabular}{|p{14.0cm}|} \hline

\begin{alltt}{\scriptsize{}
 /**
  * Calculates the measure for the specified workspace and day.
  * @param isAggregateMeasure Determines if the measure to be calculated is 
  *   an aggregate measure or not.
  * @param workspace The workspace to calculate the measure for.
  * @param day The day to calculate the measure for.
  */
 private void calculateMeasure(boolean isAggregateMeasure, 
     String workspace, Day day) \{
   for (Iterator i = this.measureList.iterator(); i.hasNext();) \{
     WorkspacePriMeasure measure = (WorkspacePriMeasure) i.next();
     if (measure.isAggregateMeasure() == isAggregateMeasure) \{
       try \{
         measure.calculate(workspace, day);
       \}
       catch (Exception e) \{
         // if exception ignore it and continue processing
         e.printStackTrace();
       \}
     \}
   \}
 \}
}\end{alltt} \\ \hline

    \end{tabular}
  \end{center}
\end{table}



\subsubsection{Design and Implementation Improvements}
As I previously stated, hackyPRI version 2.0 is designed to solve the
problems associated with version 1.0. The two problems that were solved are
execution time and the configurability for other software projects.

The execution time of hackyPRI version 2.0 has been greatly improved. Under
normal situations the execution time has been reduced from 60 minutes to 5
minutes for the same Hackystat project and on the same 3.4 GHz computer.
This is a 92 percent decrease in processing time. In my opinion, version
2.0 is now a ``real-time'' PRI ranking. A simple persistent caching of the
calculated values accounted for the dramatic decrease in execution time.
However, there are two situations where the execution time will become
quite lengthy. First, when the persistent caches are non-existent. Second,
when the persistent caches are deleted. In these two cases, the system must
calculate and persistently store the caches. This action requires 47
minutes. However, once this action is executed, the system should not
require it. Therefore, under normal situations the execution time is 5
minutes. Of course, execution times will vary depending on the Hackystat
server's speed, memory, and on the amount of project data. 

The configurability of hackyPRI version 2.0 has been greatly improved. In
version 1.0, the system gathered and bunched up the management and
calculation of the PRI measures into two Java classes. I changed that
design in version 2.0 and separated the different PRI measures into
smaller, easier to manage pieces. Under this new design, when a new PRI
measure is added to the system only a few lines of code must change. In
addition, swapping different PRI measures in and out of the ranking is now
very simple. See sections \ref{subsubsection:addPriMeasure}, and
\ref{subsubsection:calibratePriMeasure} for a detailed description of the
steps required to add, remove, and calibrate a PRI measure.




\section{The Four Steps of the Priority Ranked Inspection Process}
Hackystat PRI Extension supports the four steps of the Priority Ranked
Inspection process. The following list is the four steps of the PRI
process.

\begin{enumerate}
\item The creation of the PRI ranking function, which distinguishes MINI
  documents from LINI documents. The ranking function design includes two
  steps:
\begin{enumerate}
\item Selection of product and process measures to use in the PRI
  ranking function.
\item The calibration of the PRI measures, which includes determining
  thresholds that provide the ranking of each measure. 
\end{enumerate}
\item The selection of a document for inspection based on the PRI
  ranking function.
\item The actual inspection of the selected document.
\item Adjustment of product and process measure selection and
  calibration based on the results of the inspection.
\end{enumerate}

The following subsections detail how hackyPRI supports the steps.

\subsection{Step 1a: Selection of Product and Process Measures}
Step 1 of the Priority Ranked Inspection process states that various
product and process measures must be selected and calibrated to best
distinguish MINI documents from LINI documents. Step 1a concentrates on the
selection of the PRI measures and this selection process will not be the
same for all software projects. Therefore, different software groups must
be able to add new product and process measures to their own Hackystat PRI
installation.

A PRI measure is implemented with a WorkspacePriMeasure, explained in
Section \ref{paragraph:measurepackage}, and the following Hackystat-related
components; a Sensor Data Type, a Sensor, and a DailyProjectData
representation. The Hackystat system provides a set of various product and
process measures and I will utilize a subset of the available measures to
create the PRI measures. Table \ref{table:hackyPriv2-measurepackage}
contains a description of the PRI measures that are implemented in
hackyPRI. Each measure is collected for each package within a specified
project. Figure \ref{fig:WorkspaceQualityAnalysis} shows several example
LINI packages.

The next two sections provide a detailed illustration of how to add and
remove PRI measures to and from the system.

%Table \ref{table:measures-hackyPRI} contains a description of the
%measures that will be used in the hackyPRI extension.

\begin{figure*}[ht]
  \centering
  \includegraphics[width=1.00\textwidth]{figs/2004-12-01-all_Page_01.eps}
  \caption{The Workspace PRI analysis. Workspaces are listed with its
  respective PRI ranking and the measures.
}
  \label{fig:WorkspaceQualityAnalysis}
\end{figure*}


\subsubsection{Adding a new PRI measure to the system}
\label{subsubsection:addPriMeasure}
This section provides a detailed description of the steps that are required
to add the Runtime Execution PRI measure to the system. This measure
represents the total number of runtime executions for a specific piece of
code during the span of 24 hours.  Although this measure is currently not
obtainable in set of Hackystat measures, it has many practical
applications. For example, a Hackystat analysis can map out the areas of a
project that are executed the most during normal usage. This would be a
great measure to incorporate into PRI, because one would assume that if
package foo is executed ten times more often than package bar, ceteris
paribus, then package foo could have a higher MINI ranking than package
bar.

\paragraph{Step 1 - Create a Runtime Execution Sensor Data Type} All
Hackystat measures are concretely defined in a Sensor Data Type. This
representation, specifies the exact information that is required to allow
useful, interesting, and correct interpretations of the data. Essentially,
it is the schema that defines the data. Therefore, the first step is to
define the attributes of a Runtime Execution Sensor Data Type.

\paragraph{Step 2 - Create a Hackystat Runtime Execution Sensor} Like all
Hackystat measures, there must be some way of ``sensing'' the Runtime
Execution measure. Utilizing the Java Management Extension (JMX) is one of
the many possibilities for creating a Runtime Execution sensor. In any case,
imagine such a software tool exist, such that a Hackystat sensor can
extract the necessary information required by the Runtime Execution Sensor
Data Type.  Once the sensor and Sensor Data Type have been implemented,
Runtime Execution data can be sent to a Hackystat server.

\paragraph{Step 3 - Create a DailyProjectRuntimeExecution representation}
After the completion of steps 1 and 2, we should have Runtime Execution
Sensor Data stored in Hackystat. This fine-grained data is meaningless if
we are unable to associate the data to a specific Hackystat project. At
this point, the creation of the DailyProjectRuntimeExecution representation
is needed. The purpose of this representation is to provide coarse-grained
information about Runtime Execution data at the project level. For example,
the number of executions during June 14, 2005 for the package foo in
project Bar.

\paragraph{Step 4 - Create a WorkspacePriRuntimeExecution class}
Up until this point we have not implemented a PRI measure. Instead, we have
been implementing various Hackystat-related components that the PRI measure
requires. Now we are ready to create the WorkspacePriRuntimeExecution
class. As I previously mentioned each PRI measure must implement the
WorkspacePriMeasure Interface (see Table
\ref{table:hackyPriv2-WorkspacePriMeasure}). This creates a standard set of
functions that all PRI measures must have. During the implementation of
this class, a critical decision must be made; whether this measure is an
Aggregate or Snapshot measure.  Should the executions be aggregated over
time or should the number of executions be obtained from the last set of
data sent by the Runtime Execution sensor?  That decision is debatable,
therefore I would suggest designing all PRI measures as Aggregate measures.
This will give you the ability to toggle the isAggregateMeasure between
true and false (Aggregate and Snapshot) to determine which type works
best.

\paragraph{Step 5 - Add the WorkspacePriRuntimeExecution class to the
  ProjectWorkspaceRanking constructor}
This step requires one line of code. Simply add a instance of the
WorkspacePriRuntimeExecution to the measureList in the
ProjectWorkspaceRanking constructor. Table
\ref{table:hackyPriv2-ProjectWorkspaceRanking} shows the constructor in its 
entirety.

\paragraph{Step 6 - Add the label of the measure to the WorkspacePriValues
  getLabelIterator}
Step 5 only ensured that the Runtime Execution PRI measure would be
calculated properly. To display the calculated values correctly, we must
add some code to the WorkspacePriValues class, which handles the
presentation of the PRI ranking. Once again, this is a one-line edit.

\paragraph{We are done!} 
After finishing these six steps you have successfully added a new product
measure to the PRI determination of MINI and LINI. You should now move on
to Step 1b to improve the calibration of this measure.


\subsubsection{Removing a PRI measure from the system}
\label{subsubsection:removePriMeasure}
This section provides a detailed description of the steps that are required
to remove PRI measure from the system. 

\paragraph{Step 1 - Remove the WorkspacePriRuntimeExecution class to the
  ProjectWorkspaceRanking constructor} This step requires the deletion of
one line of code. Simply remove the instance of the
WorkspacePriRuntimeExecution from the measureList in the
ProjectWorkspaceRanking constructor. Table
\ref{table:hackyPriv2-ProjectWorkspaceRanking} shows the constructor in its
entirety.

\paragraph{Step 2 - Remove the label of the measure to the WorkspacePriValues
  getLabelIterator}
Step 1 only ensured that the Runtime Execution PRI measure would not be
calculated. To ensure that we do not display the measure's values, we must
remove some code from the WorkspacePriValues class, which handles the
presentation of the PRI ranking. Once again, this is a one-line edit.

\paragraph{We are done!} 
After finishing these two steps you have successfully removed a PRI measure
from the PRI determination of MINI and LINI.



\subsection{Step 1b: Calibration of Product and Process Measures}
Each measure and its ranking function is implemented in the hackyPRI
extension. The process of determining the rankings are not shown in Figure
\ref{fig:WorkspaceQualityAnalysis}, however the calibration and ranking
function works behind the scenes.

To make the important distinction of MINI and LINI, I assign certain
numerical thresholds to the measures to determine the PRI ranking. For
example, if the coverage of a package is below 80 percent threshold, the
system returns a ``low'' ranking for that measure. If the coverage of a
package is 100 percent, then the system returns a ``high'' ranking.
``Low'' is usually operationalized by a 1, ``high'' is operationalized by a
3, and ``middle ground'' is operationalized by a 2. The system determines
the ranking for each measure after analyzing its value. Table
\ref{table:calibration-hackyPRI} contains a description of the thresholds and
ranking function used in the hackyPRI extension.

After all PRI measures generate an individual ranking, the rankings are
aggregated to combine an overall ranking for a specific workspace. The
workspaces are then ranked by the aggregate ranking, sorting the MINI
packages to the bottom and LINI packages to the top.

\begin{table}[htbp]
  \begin{center}
    \caption{The Calibration used in hackyPRI}
    \label{table:calibration-hackyPRI}
    \begin{tabular}{|p{2.5cm}|p{3.0cm}|p{8.0cm}|} \hline
      {\bf Measure} & {\bf Calibration} & {\bf Discussion} \\ \hline
\small{}Expert & \small{}johnson=3 \newline anyone else=1 &
\small{}Dr. Johnson is an active Hackystat developer. He is the most
experienced programmer in CSDL. In addition, a lot of his development are
technical over passes of the code to ensure that the code is of high
quality. Therefore, code that he develops is weighted higher than
others. \\ \hline

\small{}Active Time & \small{}Not Weighted  &  \\ \hline
\small{}Last Active Time & \small{}Not Weighted & \\ \hline
\small{}\# of Developer \newline Active Time \newline Contributions & 
\small{}3+ developers=2 \newline 2 developers=1 \newline 1 developer=0
\newline none=0 & \small{}If code has been developed solely by one
person, the code is more likely to contain defects. As more developers work 
on the code, the less likely defects will occur. \\ \hline

\small{}Commits & \small{}Not Weighted & \\ \hline
\small{}Last Commit & \small{}Not Weighted & \\ \hline
\small{}\# of Developer \newline Commit \newline Contributions & \small{} 
\small{}3+ developers=2 \newline 2 developers=1 \newline 1 developer=0 &
\small{}Commit data is another way to determine if developers are working
on a particular piece of code. If code has been developed solely by one
person, the code is more likely to contain defects. As more developers work
on the code, the less likely defects will occur. \\ \hline

\small{}Review & \small{}2+ reviews=2 \newline 1 review=1 \newline none=0 & 
More reviews (inspections) that are conducted equals higher quality code. \\ \hline
\small{}Last Review & \small{}today-last$>$30=2 \newline today-last$<$31=1
\newline none=0 & \small{}Code that has been reviewed recently tends to be
higher quality code. \\ \hline 

\small{}Defects & \small{}>0=1 & \small{}Open defects represent a problem
in the system. If there one or more then this will impact the quality of
the code. \\ \hline
%%\small{}Last Defect & \small{}Not Weighted & \small{}In development \\ \hline

\small{}File Metrics & \small{}Not Weighted & \small{} \\ \hline
\small{}Test File Metrics & \small{}Not Weighted  & \small{} \\ \hline

\small{}Dependency & \small{}1=inbound$>$outbound & \small{}Inbound
references represents the number of references that use a specific
class. Outbound represents the number of references that the class
uses. The more inbound references the more likely changes in a class will
impact other classes.\\ \hline

\small{}Unit Test & \small{}$>$0=1 & \small{}Each day a set of unit tests
are executed against the system. If there is at least one or more
executions then we can be fairly certain that some portion of the system
was tested. However, this does not represent the effectiveness and
thoroughness of the tests. Effectiveness and thoroughness can be measured
with a combination of Test Failure, Coverage, and Defects.\\ \hline

\small{}Test Failures & \small{} & \small{} \\ \hline

\small{}Coverage & \small{}100\%=2 \newline 99-90+\%=1 \newline 89-0=\%=0 &
\small{}Higher coverage percentage, every thing else being equal,
translates to higher quality code. \\ \hline

    \end{tabular}
  \end{center}
\end{table}


There are several issues with the ranking and numerical thresholds that I
still need to address. For example, I explicitly determine thresholds using
my own subjective opinion of what is low versus high quality.  I will need
to explore if my subjective opinion is sufficient. For example, if some
measures should be ranked with more weight than others, or if any other
entirely different ranking methods provide more accurate results.

\subsubsection{Calibrating a PRI measure}
\label{subsubsection:calibratePriMeasure}
This section provides a detailed description of the steps that are required
to calibrate the Runtime Execution PRI measure. This measure represents the
total number of runtime executions for a specific piece of code during the
span of 24 hours. This would be a great measure to incorporate into PRI,
because one would assume that if package foo is executed ten times more
often than package bar, ceteris paribus, then package foo could have a
higher MINI ranking than package bar.

\paragraph{Step 1 - Take an initial guess}
In the previous paragraph, I hinted at an initial guess of one possible
calibration of the Runtime Execution PRI measure. Step 1 requires that the
developer of hackyPRI create a calibration based on either an initial guess
or even hard evidence. The calibration of the Runtime Execution PRI measure
requires the definition of certain thresholds. For example, 50 executions
could represent the threshold for a high ranking and 10 executions could
represent the threshold for a low ranking. This calibration is implemented
in code similar to Table
\ref{table:hackyPriv2-WorkspacePriCommitContribution-getPriRank}.

\paragraph{Step 2 - Run the PRI analysis and analyze the results}
Do not spend a great deal of time contemplating defining the thresholds in
Step 1, because a calibration is useless unless you have concrete data.
Therefore, Step 2 requires that you run the PRI ranking on a real software
project to analyze the results of your initial calibration. If the results
are not satisfactory, then repeat steps 1 and 2. 

\paragraph{Step 3 - Monitor inspection results over time}
Software products and development process evolve over time; therefore the
calibration of the PRI measures that represent them must evolve as well.
Monitoring the inspection results and comparing them to the calibration of
PRI measures is a continuous requirement. For example, if you find that
Runtime Execution information does not have as much as a affect that was
once determined, then the calibration must be adjusted.

\paragraph{We are done!} 
After finishing these three steps you have successfully calibrated a PRI measure.




\subsection{Step 2: Selecting a Document for Inspection Based on the PRI
  Ranking} Using the PRI Hackystat analysis, an organization should
select a document at the bottom of the PRI ranking table for inspection.
The higher the document is in the table, the less it is in need of
inspection. 

In my initial studies, I have found that simply picking the highest
priority document, or the document that is at the very bottom of the chart,
will probably not be the ``best'' document to inspect. In most cases, I
have found that the PRI ranking aids the selection of a document, but it
does not select the document automatically. In other words, it is more
useful to consider a few documents from the bottom portion of the ranking
and take an educated guess as to which document needs inspection more.

\subsection{Step 3: Conducting an Inspection of the Selected Document}
Once a document is selected it can be inspected. One interesting side
effect of the PRI ranking is that specific statistics and measures can be
presented during the inspection process. For example, if a document is
selected because it has low coverage, then the inspection can focus on why
the coverage is low. However, in my evaluation of PRI, I will keep all PRI
information a secret. 

Of course, the Hackystat PRI Extension or the PRI process does not support
the actual inspection of the document. An organization should consult
traditional inspection processes (i.e., Software Inspection, Fagan
Inspection, In-Process Inspection, etc). In other words, the PRI process is
an outer layer that wraps around an already established inspection process.

\subsection{Step 4: Adjustment of the Measure Selection and Calibration}
If a document is shown to be incorrectly ranked, then an adjustment of the
PRI weighting function is necessary. In hackyPRI, this can be accomplished
by adding more PRI measures (Step 1a) or recalibrating the numerical
thresholds associated with the measures (Step 1b). More specifically, a
recalibration includes editing the Java source code in the hackyPRI system.
Conceptually, recalibration would be as easy as editing the information
presented in Table \ref{table:calibration-hackyPRI}.



\section{User Interface}
This section contains a description of the user interface of hackyPRI. [TOO 
BE FINISHED SOON].

\subsection{List Workspace Analysis}

%%\subsubsection{Execution}

%%\subsubsection{Result}


\subsection{Project Workspace Ranking Analysis}

%%\subsubsection{Execution}

%%\subsubsection{Result}
















