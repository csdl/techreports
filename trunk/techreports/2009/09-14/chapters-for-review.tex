\documentclass[12pt,oneside]{report}

\usepackage[utf8]{inputenc}
%%% Load some useful packages:
%% "New" LaTeX2e graphics support.
\usepackage{graphicx}
%%	using final option to force graphics to be included even in draft mode
%\usepackage[final]{graphicx}
%% Tell graphicx the default directory for all figures
\graphicspath{{figures/}}

% Enable subfigure support
\usepackage{subfigure}

%% Make subsubsections numbered and included in ToC
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{2}

%% Package to linebreak URLs in a sane manner.
\usepackage{url}

%% Define a new 'smallurl' style for the package that will use a smaller font.
\makeatletter
\def\url@smallurlstyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
%% Now actually use the newly defined style.
\urlstyle{smallurl}

%% Define 'tinyurl' style for even smaller URLs (such as in tables)
\makeatletter
\def\url@tinyurlstyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\scriptsize\ttfamily}}}
\makeatother

%% Provides additional functionality for tabular environments
\usepackage{array}

%% Puts space after macros, unless followed by punctuation
\usepackage{xspace}

%% Make margins less ridiculous
\usepackage{fullpage}

%% Allows insertion of fixme notes for future work
\usepackage[footnote, nomargin]{fixme}

%%%% Turned off for tech report, should be turned on for research portfolio
%% Turn on double spacing
\usepackage{setspace}
\usepackage{mdwlist}
\doublespacing

%% Make URLs clickable
%\usepackage[colorlinks, bookmarks=false]{hyperref}
\usepackage[colorlinks, bookmarks=true]{hyperref}

%% Since I'm using the LaTeX Makefile that uses dvips, I need this
%% package to make URLs break nicely
\usepackage{breakurl}

\usepackage{todonotes}
\usepackage{amsmath,amsfonts}
\numberwithin{equation}{subsection}
%%\usepackage{nonfloat}
\usepackage{bbm}
\usepackage{setspace}
\onehalfspacing
\usepackage{tabularx}

\newenvironment{myindentpar}[1]%
 {\begin{list}{}%
         {\setlength{\leftmargin}{#1}}%
         \item[]%
 }
 {\end{list}}

%opening
\title{}
\author{Pavel Senin}

%%% End of preamble
\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\chapter{Experimental design}
Given multiple streams of software process artifacts, how to find recurrent behaviors? In this chapter, 
I will describe Software Trajectory Analysis, which summarizes, compresses, and indexes artifact trails 
allowing discovery of recurrent behaviors. The idea behind this approach is to employ a computational 
algorithm that focus on the differences in the streams produced by studied entities.

\section{Introduction}
Software artifacts are abundant and carry a vast amount of information about performed process. 
The vast majority of artifacts are concerned about the software itself and largely associated with 
specific development methodology. Examples of such artifacts are design documents, use cases, class 
diagrams and requirements, user manuals, etc. The payload of this artifacts aids in understanding of 
a function, architecture, and the design of software, while carrying a very little information about the 
recurrent behaviors and underlying software processes itself. Due to this fact, such artifacts are off 
my attention.

What is studied in this thesis - is the informational content of software development process byproducts 
which include: source code changes, bug reports, and developers discussions. These artifacts act as primary 
evidence of recurrent behaviors. Note, however, that developers do not intentionally create these 
artifacts to enable research, or to keep things in order - mainly, these artifacts are the pure byproduct
helping to the development of a software project. Thus, we must assume, that these data is inconsistent, 
that any kind of annotations used by developers might be erroneous, and the amount of disclosed information 
could simply be not enough to determine the actual generative behavior - which ultimately leads to 
uncertainty.

Nevertheless 

The focus of my work is to handle the discovery of recurrent behaviors automatically. So far, straightforward 
methods like ... give poor results. Ideally one would like a method with the following properties:
\begin{itemize}
 \item Effective: the reported findings, with respect to behaviors reconstruction, must agree with human intuition.
 \item Scalable: currently software process artifact trails for a single project could easily grow beyond dozens of
       gigabytes, thus, the computation technique should ideally be able to utilize parallelization and pre-computing
       of intermediate results which alleviate the overall space-time complexity.
 \item Efficient: the set of reported findings should not exceed a certain threshold becoming overwhelming stream 
       of spurious facts.
\end{itemize}



\end{document}
