\documentclass[12pt,oneside]{article}
%\usepackage{fullpage}

%%% Load some useful packages:
\usepackage{graphicx}
\graphicspath{{figures/}}
\usepackage{subfigure}
\usepackage{bbm}
\usepackage{tabularx}
\usepackage{setspace}
\onehalfspacing
%% Package to linebreak URLs in a sane manner.
\usepackage{url}

\usepackage{todonotes}
\usepackage{amsmath,amsfonts}
\numberwithin{equation}{subsection}
%% Define a new 'smallurl' style for the package that will use a smaller font.
\makeatletter
\def\url@smallurlstyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
%% Now actually use the newly defined style.
\urlstyle{smallurl}

%% Define 'tinyurl' style for even smaller URLs (such as in tables)
\makeatletter
\def\url@tinyurlstyle{%
  \@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\scriptsize\ttfamily}}}
\makeatother

%% Provides additional functionality for tabular environments
\usepackage{array}

%% Puts space after macros, unless followed by punctuation
\usepackage{xspace}

%% Make margins less ridiculous
\usepackage{fullpage}

%% Allows insertion of fixme notes for future work
\usepackage[footnote, nomargin]{fixme}

%% Make URLs clickable
\usepackage[colorlinks, bookmarks=true]{hyperref}

\begin{document}
\title{Abstract for Ph.D. dissertation: \\
       \textsc{Software Trajectory Analysis:} \\
       \textsc{An empirically based method for automated software process discovery} \\
       \author{Pavel Senin \\
               Collaborative Software Development Laboratory \\
               Department of Information and Computer Sciences \\
               University of Hawaii \\[0.3cm]
               \texttt{senin@hawaii.edu} \\[0.3cm]
               CSDL Technical Report 09-13 \\
               \url{http://csdl.ics.hawaii.edu/techreports/09-13/09-13.pdf}
       }
       \date{May 2013}
}
\maketitle

\clearpage


\section{Introduction}
Software engineering is a unique area of engineering field having almost no cost associated with
materials and fabrication which dominate cost in all other engineering disciplines. 
However, ironically, software engineering is suffering from the costs and challenges
associated with continuous re-design of the product design (\textit{software development}) 
processes - the issue which is rarely seen at all in any of other engineering areas. 

In order to efficiently deal with this issue, many universal design processes - known as 
software development methodologies - were proposed up to date. 
Nevertheless, these methodologies known to fail in delivering of the software. 
One of the reasons for these failures is the overall immaturity of these models, which
traditionally designed through a top-down approach, where at the first place, someone has to
``invent'' the process. As was shown, the software development methodology invention is a difficult
and error-prone process, which may take decades for validation and tend to produce ``paper lions'' -
process models which are disconnected from reality, disruptive, and simply unacceptable by the end
users.

The alternative, bottom-up approach of inferring process models through observation and
study of already established processes is also not new and was around for decades. 
Unfortunately, this technique is also facing a number of issues which are dominated by privacy
concerns, high cost of observations, and limited generalization of results.

Potentially, the outlined above issues can be addressed by an \textit{automated system} which is
capable of process discovery from offline collections of common process artifacts, such as change
records, bug/issue reports, and other entities created merely for supporting of software development
activities rather than collected for the process discovery. However, the ability of such system to
infer software processes is questionable.

In the thesis, I am addressing the question of the possibility of such an automated system
construction and its performance. As a result, I show the implementation of an
automated software artifacts mining system based on the novel knowledge discovery algorithm,
and investigate its performance in discovery of software process primitives - the recurrent
behaviors.
\clearpage
 
\section{Methodology}
Traditionally, offline process mining techniques rely on the extraction of event sequences from
collected in a controlled environment logs. However, as indicated by previous research,
these techniques usually fail when applied to publicly available process artifacts, which are
information-poor integrals of many, potentially self-canceling, concurrent events. 

In these context, I chose to work at somewhat higher, more general level of process
abstractions - at the level of behaviors. Examples of such behaviors include unusually large churns
or decreasing frequency of branch merges. Thus, effectively, I am re-framing the approach to the
research problem - instead of mining for atomic events in order to reconstruct sequences of actions,
I am mining for different kind of primitives - recurrent features in the trajectories of
measured values, in a hope, that their analysis will shed a light on higher processes.

This problem of knowledge discovery from trajectories is not new and there are plenty of
algorithms, which rely on the use of a number of primitives such as periods, bursts,
motifs, discords, and shapelets as building blocks. These methods can be classified into two
categories - techniques based on the exact or on the approximate search. Through the
experimentation, I found that only approximate techniques are capable of producing results with
adequate support. However, the traditional frequency- or distance-based primitives discovered 
by this techniques are far from optimal. This poor performance can be attributed to the
high noise of and frequent ``chimeric'' features in software process artifact trails.

In order to advance in this direction, I designed a novel \textit{characteristic primitives
discovery and ranking algorithm} presented in the thesis and called SAX-VSM. 
These primitives were described recently in the literature and called \textit{shapelets}. They
are subsequences which characterize a time series class differentiation and can be used for
classification and the knowledge discovery. As I show through the experimental evaluation and
case-studies, ranked shapelets discovered with SAX-VSM 
allow not only to build well-performing classifiers, but offer excellent interpretability of complex
concepts.

The use of this novel technique enabled a discovery of characteristic behaviors in a case studies
which I conducted in order to address the research hypothesis. Two of these case studies are
concerned with discovery of known behaviors - the software release pattern and the software
maintenance pattern, while the third case study is concerned with discovery of recurrent
behaviors from logs of Q\&A sites.

\clearpage
\section{Contribution}
The contribution of my thesis can be summarized as follows:

\begin{itemize}

\item 
I show an efficient, generic algorithm for interpretable time series data mining (classification,
and exploration). The algorithm outputs optimal\footnote{"optimal" statement is not proven
mathematically, but is expected by design - I understand that this can be regarded as a weak
statement - but then, in order to prove the optimality by myself, I need to resort into building a
construct upon Shannon's information theory, Zipf's law, terms arrival event space (Poisson models),
and hit the problem of overall relevance of weights - all these, in turn, could stall my research
and ultimately result in yet another study on tf*idf heuristics. Instead, in this statement, I am
relying on previous studies on time series distribution and on the previous research on TF*IDF.}
class characteristic patterns, and demonstrates classification performance superior to, or comparable
with the current state of the art. It is based on the adjustable aggregation and
approximation properties of SAX and on metric properties of Vector Space model - in other words it
is not exact and naturally generalizes class characteristic patterns (outputs less patterns with
higher support). 

Overall, I expect this algorithm to play an important role in future because of the growing ubiquity
of time series and growing interest in behaviors.

\item 
I show, that the application of the algorithm to software process artifacts yields patterns
(features) corresponding to recurrent behaviors, thus positively confirming the research
hypothesis. Further, I show applications of the algorithm as a knowledge discovery tool to software
process artifacts through case studies based on comparative analyses. In particular, I show, that
the temporal primitives discovered by the algorithm provide not only quantitative evidence for
processes interpretation, but can\footnote{ I use word "can" here because of the baselines - these
are basically not established - it is hard to tell what are the "normal" behaviors for a project.} 
be used for a qualitative assessment of discovered recurrent behaviors.

\item 
Finally, I provide an implementation of SAX-VSM time series classification algorithm and STA
analysis framework to the community. This algorithm implementation uses several computational
tricks to optimize, reduce, and reuse computation. 
\end{itemize}

Within last years, the SAX-VSM implementation was downloaded numerous times, as well as codebase
was extended by a number of contributors from academia and industry. Current codebase has grown
beyond the scope of the reference implementation and become a part of a scientific and two
industrial research projects in which I participate - these concerned with temporal motif discovery
through grammatical inference with Sequitur, behaviors prediction using n-Gram language models, and
multivariate time series classification.

\section{Results}
Close examination of SAX-VSM performance, case studies of its application to software process
artifacts, and analysis of the discovered behaviors constitute the Results section of my thesis.

\subsection{SAX-VSM}
SAX-VSM was evaluated on 31 benchmark datasets known in the field of time series classification.
Overall, the algorithm demonstrated a superior classification performance. Further, its ability to
discover characteristic to class shapelets, was proven through the close examination of discovered
and ranked features in a number of synthetic and real datasets.

\subsection{PostgreSQL change records archive analysis}
PostgreSQL development team maintains a clean and streamlined source code repository with very few branches.
In addition, there is a limited set of authorized committers and a clear process for aquiring third-party contributions 
called CommitFest which is run regularly. The size of PostgreSQL dataset and the clarity of processes allowed 
an investigation of STA performance in a number of experiments. 

In experiment aimed to discover individual behaviors associated with CommitFest STA failed to recognize 
any of them. As always, we learn more from failures than from success - this failure outlines STA applicability
threshold to sparse datasets. Nevertheless, STA succeded to capture characteristic recurrent behaviors behind 
CommitFest when applied to the whole team's  trajectories which are integrals of individual ones. This results 
supports the research hypothesis as well as provides some insights into CommitFest team's recurrent behaviors.

In experiment concerned with release behaviors discovery STA succeded 




%%% Input file for bibliography
\bibliography{seninp}
%% Use this for an alphabetically organized bibliography
\bibliographystyle{plain}
%% Use this for a reference order organized bibliography
%\bibliographystyle{unsrt}
%% Try using this BibTeX style that hopefully will print annotations in
%% the bibliography. This will allow me to make notes on papers in the
%% BibTeX file and have them readable in the references section until
%% I turn them into a conceptual literature review 
%\bibliographystyle{annotation}

\end{document}
