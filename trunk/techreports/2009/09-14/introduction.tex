\chapter{Introduction}
Contemporary software projects typically have a considerably long life-cycle - well over decade.
Their development and maintenance usually carried out by geographically distributed teams 
and individuals. The development pace, the experience, and the structure of these development 
teams continuously change as developers are joining and leaving. When combined with
schedule and requirements changes, all these create numerous difficulties for stakeholders,
project managers, and developers, ultimately affecting the project success. 

This software development complexity phenomena was identified in 1968 as ``Software crisis'' \cite{crisis}, 
and was addressed by bringing the research and the practice of software development 
(or as it was called ``programming'') under the umbrella of Engineering  - in an effort to provide a 
control over the process of software development. 
Following the engineering paradigm, numerous \textit{models} of software processes 
and software development \textit{methodologies} were proposed \cite{citeulike:10002165}.
%For example, the Waterfall Model proposes a sequential pattern in which developers first create a 
%Requirements document, then create a Design, then create an Implementation, and finally develop Tests; 
%the Test Driven Development methodology proposes an iterative pattern in which the developer must first 
%write a test case, then write the code to implement that test case, then refactor the system for maximum clarity 
%and minimal code duplication. 
Many of these models were adopted by practitioners while most efficient were accepted as industrial 
standards - CMMI, ISO, SPICE, PSP, and alike. 
Today, these standards, guidelines, and recommendations ought to 
provide managers, teams, and individual developers with the ability to control their software processes.

Nevertheless, despite to success of formalized approaches to manufacturing processes in other 
engineering fields, current state-of-the-art models of software processes perform somewhat poorly 
and do not deliver consistently. 
For example, the recent study by Standish Group (Rubinstein, ``Chaos Reports'', 2006) indicates,
that while `\textit{`Software development shops are doing a better job creating software than they were 
12 years ago}'', still, only ``\textit{35\% of software projects in 2006 can be categorized 
as successful meaning they were completed on time, on budget and met user requirements}â€.
Another, widely acknowledged problem with existing models is their rigidity - usually 
once a project executed, the cost of incorporating a change in the process or a product 
not only becomes significant, but also grows proportionally to the project execution time.

Along with industrial, engineering-like process models, a number of software processes 
emerged from hobbyists and were successfully adopted by practitioners, seeking for alternative solutions.
Some of these, not only address aforementioned limitations, but proven to be applicable for large scale 
industrial projects (Android OS: LoC$>$15M, $\sim$2K contributors). 
Among others, the Free/Libre/Open-Source Software model (FLOSS) and the software craftmanship 
approaches gained a significant credibility among practitioners.
While the former \textit{holistic} software process paradigm emphasizes extensive collaboration, 
frequent releases and removes the boundary between developers and customers, the latter is focusing 
on the roles of highly motivated, creative and skilled individuals in a process of software creation. 

The existence of these distinct by nature approaches, their uneven and often unpredictable performance, 
and vast amount of their application experiences ranging from success stories to complete failures clearly 
indicates, that our understanding of underlying ``software process mechanics'' is incomplete. This
fact continues to fuel further research in software processes.

Not surprisingly, most of the research in the field is focused on engineering-like software processes following business 
interests and leveraging the ability to perform experimentation in a controlled environment - where it is possible to 
evaluate a proposed by solution to (often \textit{cherry-picked}) research problems. 
One problem with this approach to process development is that it requires the process analyst to invent, or to notice 
a recurrent pattern of behavior, addressing the problem in the first place \cite{citeulike:5043104}. 
In addition to difficulties with ``invention'' itself, another issue pinpointed by van der Alast in \cite{citeulike:9758924}, 
is that the process inventors are often limited in their scope and tend to assume an idealized versions of real processes, 
thus, often producing ``paper lions'' - process models which are likely to be disruptive and unacceptable for end users, 
at least in their proposed form. Finally, the full evaluation cycle of proposed solutions is considerably long and expensive.
%Research in this area is usually
% based on the hard data - such as source code analysis and defect identification, static and dynamic testing, 
%formal verifications, etc.

The alternative, people-oriented approach pioneered by Weinberg in 1971 \cite{citeulike:262020}, recently been revived. 
It shifts focus from technical aspects towards understanding and improving how software processes are shaped by 
humans and social behaviors. 
Current research is driven by increase in public data made available by the proliferation 
of open source communities. Currently available and abundant software artifacts (source code, defect records, 
mailing list communications, etc.) removed the high cost barrier that previously made large-scale analysis of software 
projects unfeasible for most researchers. Since 2004, the International Conference on Software Engineering (ICSE) has 
held a Working Conference on Mining Software Repositories (MSR). 
Its original call for papers stated MSR's purpose as \textit{``to use data stored in software
repositories to further understanding of software development practices ... [and enable
repositories to be] used by researchers to gain empirically based understanding of software
development, and by software practitioners to predict and plan various aspects of their
project''} \cite{citeulike:7853299}. 
Several other venues, 
International Conference on Predictive Models in Software Engineering , 
International Conference on Open Source Systems (OSS, since 2005), 
the Workshop on Public Data about Software Development (WoPDaSD, 2006{2010, subsequently subsumed by OSS), 
and the International Workshop on Emerging Trends in FLOSS Research (FLOSS, 2007 and 2010) have also played
an important role in shaping and advancing this research domain.

In my work, I am following the non-intrusive, approach for the software process analysis focusing on the discovery 
of recurrent behaviors from software process artifacts. I believe, that if there exists a mechanism which facilitates 
the discovery of recurrent behaviors, it might be possible to associate these with building blocks of larger processes. 
In turn, this empirical knowledge would help to refine our understanding of existing process models and to improve 
a process of a design of novel software development methodologies.

The work in this thesis addresses a fundamental aspects in discovery of recurrent behaviors - their significance assessment.
At first, I will show a generic time-series classification algorithm which facilitates discovery of class-characteristic features.
Then, through the exploratory case studies I will evaluate its applicability to publicly available software process artifacts.

\section{Research questions, hypothesis, and a scope of the dissertation}
Software is coded by humans. Whether in team or individually, we perform a number of daily activities - 
commuting to an office, answering emails, attending meetings, writing a code, and many others. 
The ordering of these activities and their durations are driven and constrained by internal and external factors, 
such as a role,motivation, working schedule, project phase, physical location of the office, etc. 
When summarized together, the range of these activities and the mannerisms form our behavioral portraits.

A subset of these activities can be attributed as relevant to the project goal - delivering a software. 
Thus, one of the research questions addressed in my work is the \textit{partitioning of the activities}. 

By limiting the scope of my research to a discovery of recurrent behaviors only from software process 
artifacts, I address the above question at large (but not in full) by simply considering only related to software 
process entities.
This, however, leads to other research questions: 
\textit{is it possible to discover recurrent behaviors from a very limited set of software process by-products?} 
and, if it is possible, 
\textit{will the discovered behaviors be meaningful, i.e. interpretable?}

Some of the previous research, especially in MSR field  \cite{citeulike:9114115, citeulike:7853299}, 
indicates, that by application of a variety of a techniques it is not only possible to discover evidence of 
software process \cite{citeulike:9007622}, but, at least partially, to infer the process as a whole \cite{citeulike:5128808}. 
In these works, it was shown, that many of techniques can be applied to software process artifacts, 

These combine into the research hypothesis - \textit{it is possible to discover recurrent behaviors 
from software process artifacts by application of appropriate data-mining techniques} - 
which I investigate in this dissertation. 

In order to approach this hypothesis questions, I choose to reduce the problem of mining of software artifacts to a narrower,
but more generic software treat software artifacts as time-series and design an interpretable time 
series classification technique, which, 
as I will show, temporal 


Exactly as it sounds, my research is interdisciplinary - it combines together knowledge discovery and software process 
analysis, focusing on a very narrow subject - exploring approaches for recurrent behaviors or ``programming habits'' 
discovery from software process artifacts.
While I will show, that recurrent and significant software-development behaviors can be discovered,
their precise categorization, effect, and performance are beyond the scope of this thesis.

\section{Contributions}
I show a novel, generic algorithm for interpretable time series classification: SAX-VSM. 
While the performance of this algorithm is at the level of current state of the art, it offers an outstanding feature -
discovery, generalization and ranking of class-characteristic structural features. This feature, in turn, enables
knowledge discovery by offering much clearer insight into data specificity than any other competing technique.
In addition, SAX-VSM uses only N weight vectors for classification of unlabeled data by computing N cosines, where N is
a number of classes, - therefore it is very fast and has a very small memory footprint.
Overall, I expect this algorithm to play an important role in future because of the growing ubiquity of time series and
growing interest in behaviors.

I provide SAX-VSM implementation to the community. This implementation uses several computational tricks to optimize,
reduce, and reuse computation. Within last years, this implementation was regularly downloaded and used in academia and
industry. 

Powered by SAX-VSM, through the application of Software Trajectory Analysis (STA) to software process artifacts, I show
through the case studies: that it is possible to discover known recurrent behaviors, thus positively confirming the
research hypothesis. In the PostgreSQL study I was able to discover characteristic recurrent behaviors in source code
editing churns corresponding
to Software release and to the Commit Fest processes.
that STA and SAX-VSM can be used as a knowledge discovery tool in the StackOverflow case study. In particular, I show,
that the temporal primitives discovered by the algorithm provide not only quantitative evidence for processes
interpretation, but can be used for a qualitative assessment of discovered recurrent behaviors.
In Android case study...

Finally, I provide an implementation of STA analysis framework to the community. 

\section{Organization of the dissertation}