\chapter{Introduction}
Contemporary software projects typically have a considerably long life-cycle - well over decade.
Their development and maintenance usually carried out by geographically distributed teams 
and individuals. The development pace, the experience, and the structure of these development 
teams continuously change as developers are joining and leaving. When combined with
schedule and requirements changes, all these create numerous difficulties for stakeholders,
project managers, and developers, ultimately affecting the project success. 

This software development complexity phenomena was identified in 1968 as ``Software crisis'' 
and was addressed by bringing the research and the practice of software development 
(or as it was called ``programming'') under the umbrella of Engineering - in an effort to provide a 
control over the process of software development. 
Following the engineering paradigm, numerous \textit{models} of software processes were proposed.
Many of these models were extensively studied by researchers and adopted by practitioners, 
while the most efficient were accepted as industrial standards - CMMI, ISO, SPICE, and alike.
Today, these standards, guidelines, and recommendations ought to provide managers, teams, 
and individual developers with an ability to control their software processes.

Nevertheless, despite to success of formalized approaches to manufacturing processes in other 
engineering fields, current state-of-the-art engineering-like models of software processes perform 
somewhat poorly and do not deliver consistently. 
For example, the recent study by Standish Group (Rubinstein, ``Chaos Reports'', 2006) indicates,
that while `\textit{`Software development shops are doing a better job creating software than they were 
12 years ago}'', still, only ``\textit{35\% of software projects in 2006 can be categorized 
as successful meaning they were completed on time, on budget and met user requirements}‚Äù.
Another, widely acknowledged problem with large models is their rigidity - usually once a project executed, 
the cost of incorporating a change not only becomes significant, but also grows proportionally to 
the project execution time.

Along with engineering-based process models, there is a number of alternative software processes,
which proven to be mature enough for application in a large scale projects and address aforementioned 
limitations. Most of these emerged from hobbyists and were successfully adopted by practitioners.
Among others, the open-source software model (OSS) and the software craftmanship approaches gained a 
significant credibility among practitioners.
While the former \textit{holistic} software process paradigm emphasizes extensive collaboration, frequent releases 
and removes the boundary between developers and customers, the latter is focusing on the roles 
of highly motivated, creative and skilled individuals in a process of software creation. 

The existence of these distinct by nature approaches, and the vast amount of their application experiences -
ranging from success stories to complete failures - continue to fuel the research community's interest. 

Not surprisingly, most of the research in the field is focused on formal software processes following business 
interests and enjoying observability and leveraging an ability to perform experimentation in a controlled environment -
where it is possible to evaluate a proposed by a researcher or a practitioners solution to 
(often \textit{cherry-picked}) research problems. 
But, as pinpointed by van der Alast in \cite{citeulike:9758924}, the process inventors are often limited in their
scope and tend to assume an idealized versions of real processes, thus, often producing ``paper lions'' - 
process models which are likely to be disruptive and unacceptable for end users, at least in their proposed form.

In my work, I attempt to explore an opposite, ``down-top'', non-intrusive, approach for the software 
process analysis based on the discovery of recurrent behaviors from software process artifacts trails. 
Potentially, if there exists a mechanism which facilitates the discovery of recurrent behaviors, 
it might be possible to associate these with building blocks of larger processes. In turn, this empirically-based 
knowledge would help to refine our understanding of existing process models and to improve a process of 
design of novel software development methodologies.

\section{Research questions, hypothesis, and a scope of the dissertation}
Software is coded by humans. Whether in team or individually, we perform a number of daily activities - 
commuting to an office, answering emails, attending meetings, writing a code, and many others. 
The ordering of these activities and their durations are driven and constrained by internal and external factors, 
such as a role,motivation, working schedule, project phase, physical location of the office, etc. 
When summarized together, the range of these activities and the mannerisms form our behavioral portraits.
Only a subset of these activities can be attributed as relevant to the project goal - delivering a software. 
Thus, one of the research questions addressed in my work is the \textit{partitioning of the activities}. 

By limiting the scope of my research to a discovery of recurrent behaviors only from software process 
artifacts, I address the above question at large (but not in full) by simply considering only related to software 
process entities.
This, however, leads to other research questions: 
\textit{is it possible to discover recurrent behaviors from a very limited set of software process by-products?} 
and, if it is possible, 
\textit{will the discovered behaviors be meaningful, i.e. interpretable?}

Some of the previous research, especially in MSR field  \cite{citeulike:9114115, citeulike:7853299, citeulike:9007622}, 
indicates, that it is not only possible to discover evidence of software process, but, at least partially, 
to infer the process as a whole \cite{citeulike:5128808}. In these works, it was shown, that a variety of techniques 
can A variety of techniques 

These combine into the research hypothesis - \textit{it is possible to discover recurrent behaviors 
from software process artifacts by application of appropriate data-mining techniques} - 
which I investigate in this dissertation. 

In order to approach this hypothesis questions, I choose to reduce the problem of mining of software artifacts to a narrower,
but more generic software treat software artifacts as time-series and design an interpretable time 
series classification technique, which, 
as I will show, temporal 


Exactly as it sounds, my research is interdisciplinary - it combines together knowledge discovery and software process 
analysis, focusing on a very narrow subject - exploring approaches for recurrent behaviors or ``programming habits'' 
discovery from software process artifacts.
While I will show, that recurrent and significant software-development behaviors can be discovered,
their precise categorization, effect, and performance are beyond the scope of this thesis.

\section{Contributions}
I show a novel, generic algorithm for interpretable time series classification: SAX-VSM. 
While the performance of this algorithm is at the level of current state of the art, it offers an outstanding feature -
discovery, generalization and ranking of class-characteristic structural features. This feature, in turn, enables
knowledge discovery by offering much clearer insight into data specificity than any other competing technique.
In addition, SAX-VSM uses only N weight vectors for classification of unlabeled data by computing N cosines, where N is
a number of classes, - therefore it is very fast and has a very small memory footprint.
Overall, I expect this algorithm to play an important role in future because of the growing ubiquity of time series and
growing interest in behaviors.

I provide SAX-VSM implementation to the community. This implementation uses several computational tricks to optimize,
reduce, and reuse computation. Within last years, this implementation was regularly downloaded and used in academia and
industry. 

Powered by SAX-VSM, through the application of Software Trajectory Analysis (STA) to software process artifacts, I show
through the case studies: that it is possible to discover known recurrent behaviors, thus positively confirming the
research hypothesis. In the PostgreSQL study I was able to discover characteristic recurrent behaviors in source code
editing churns corresponding
to Software release and to the Commit Fest processes.
that STA and SAX-VSM can be used as a knowledge discovery tool in the StackOverflow case study. In particular, I show,
that the temporal primitives discovered by the algorithm provide not only quantitative evidence for processes
interpretation, but can be used for a qualitative assessment of discovered recurrent behaviors.
In Android case study...

Finally, I provide an implementation of STA analysis framework to the community. 

\section{Organization of the dissertation}