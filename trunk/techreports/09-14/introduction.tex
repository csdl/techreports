\chapter{Introduction}
Engineers build things and make them work by applying known theories, methods, 
and tools, appropriately and selectively, in systematic fashion, to reach the goal. 
It is also widely recognized, that in this process of engineering, they operate 
in restricted environment complying with organizational rules, financial restrictions, 
and schedule. Altogether these methods and principles control the process of engineering 
assuring it safety for life and property and making its result predictable.

The relatively new engineering discipline - the Software Engineering (SE) was born in 1968, 
when the first NATO Software Engineering Conference was held. It is thought, that the reason
to define Software Engineering as an engineering discipline versus Software Programming or any other 
term was an attempt to bring a somewhat unpredictable and unordered art of computer programming 
into streamlined and controlled environment.
And at that time, it was thought, that Software Engineering is not different 
from any other engineering fields. And just like any others disciplines of engineering, 
Software Engineering was defined as the application of a systematic, disciplined, quantifiable 
approach to the design, development, operation, and maintenance of the final product - the software.
Delivering high quality software products within the budget and in time was set as the main goal 
and the most challenging task of Software Engineering.

In following decades, scientific research in Software Engineering resulted in a number of software 
processes providing detailed guidelines on how to reach the goal efficiently and in time. 
These processes manifested themselves as the means for improvements in terms of quality, 
speed, and execution cost over existing practices. Many processes were tested within academic 
settings and adopted by industry proving their superiority, some of this processes were 
further standardized, shaping the best practices of contemporary software development \cite{citeulike:9962021}. 

The processes, that I am addressing here, found in numerous studies and described at length in 
academic and industrial literature. Too numerous to name, they can be categorized by the level 
of their application:
\begin{itemize}
 \item global organizational standards, like CMMI, ISO 9000, and SPICE. 
 \item large industrial software models, such as Waterfall, Spiral, Cleanroom, etc.
 \item smaller scale, flexible methodologies and agile approaches: XP, SCRUM, FDD, 
TDD, Pair Programming, etc.
 \item general guidelines and principles aiming to improve the software process flow, 
such as ``build before commit'' and others.
 \item and finally, there are processes for improving existing processes of software development 
on the organizational, team, and personal levels: TSP, PSP, Six Sigma, etc.
\end{itemize}
While some of these are product of a ``technology transfer'' - that is by direct copying or by an 
application of existing engineering principles to software development process (like Waterfall model), 
some, and in particular agile methods, considered to be a software-engineering only processes. 

\section{Motivation}
As shown before, there exist numerous software process, models, methodologies, 
and coding conventions for virtually any scale of the project or a team size; and these are
applicable at any level and at any stage of the software development process. This amount of 
well-grounded and documented knowledge creates an impression that the area of software development 
process is thoroughly explored, and that there exists a deterministic choice for a model and a 
processes for any software project. However, it is far from being true - software projects still fail 
at the considerable high rate and there are many challenges exist when developing a software product.

This phenomena, also known as a ``software crisis'', was first recognized by Randell et al. in 1976 
\cite{naur1976software}. The attention was caught by the fact that many software projects ran 
over budget and schedule, some caused property damage \cite{citeulike:11044022}, and a few projects caused 
loss of life \cite{citeulike:712058}. Decades later, the ``Chaos Report'' from the Standish 
Group \cite{SDTimes} state, that only ``35\% of software projects in 2006 can 
be categorized as successful - meaning they were completed on time, on budget and met 
user requirements''. These thirty five percent of success clearly manifest that it is somewhat 
illusory statement that we are capable to understand and to control software processes.

This rather poor performance of the mainstream software engineering processes 
ignited a new wave of research in the field in recent decades. Gradually, researchers and 
practitioners alike recognized, that a direct application of classical engineering and a 
straightforward ``up-down'' software process governing might be somewhat erroneous. 
Also, it was recognized that over many years, continuous formalization of the field and 
excessive attention to software process metrics may malformed not only the software development 
practices landscape, but education and a professional code of conduct. 
This recognition forced some of the professional associations 
to review their licensing policies \cite{citeulike:11045517} and some educators to change their 
opinions \cite{citeulike:5203446}. 

In parallel with this search for industrial ``software crisis'' solution, another phenomena, 
the Open Source Software (OSS) 
development - an alternative software process arose and has proven its ability to deliver 
large, high quality software products. The OSS process is largely differ from typical SE process
on many levels - first of all it is carried out by a highly distributed community of people,
which significantly contradicts to developers collocation assumed by the most of the SE processes.
Secondly - OSS delivers a software free of charge and promotes its reuse, modification, and 
redistribution by anyone, moreover the OSS software is largely developed for a fraction of cost
of similar commercial projects. And finally, the OSS projects rarely governed by or can provide
any sort of documented software process. Yet, many OSS projects delivered large-scale, widely
adopted software systems fully comparable or superior to industrial projects.

Lately, third approach to software development emerged - software craftsmanship emerged 
\cite{citeulike:11058561}, \cite{citeulike:11058554}. The followers of this methodology 
are not only focused on the delivering ``well crafted'' software and continuously adding value,
but on the apprenticeship - on forming communities and engaging more people in software development.
While recommendation exists \cite{citeulike:11058784}, little known about the research 
in software craftsmanship and apprenticeship processes.

All this continues to engage thoughts and fuels the search not just for the exact definition 
of software development, but deep, fundamental for efficient processes resolving. 
Is software development an engineering discipline? Is it a craft \cite{citeulike:5203446}? 
Or is it an art \cite{citeulike:11045694}?

Answers to these questions would require extensive interdisciplinary studies to be made, what is 
obviously clear, that software development is a creative, human activity. Whether software is coded 
by team where its members have a variety of skills and experience, or by a single individual,
they all driven by their believes and motivations. While usually developers agree on the use of 
particular technologies, development tools, and a development process with imposed timeline and 
a budget, the software process is - as many other human activities - highly creative and mostly 
non-recurring. Thus, the choice of methodology, technology, or tools provides only a marginal 
effect on this human-based and human-driven process. While this effect can be measured through 
the common approach by using a control environment factoring out human component, the most of 
the difference, which lies in human creativity, motivation and productivity is unknown and yet, 
mostly unmeasurable.

\section{Research area overview}
\todo[inline]{here, describe in short the current state of the art and notable efforts which
shed light on the research area and identify a precise place where I am going.}
Here, lies a great room for the research and for improvement of our understanding of software 
processes. And my thesis is yet another attempt at the understanding of the role human activities 
in the software process. Before going further, I would like to emphasize, that in this work I will not 
address the need and means of the process synthesis, process quality assessment, productiveness
or any topics related to the software product itself; I would rather focus on the specific issue - 
on uncovering an existence and on studying the programming habits. 

