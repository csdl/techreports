\chapter{Introduction}
Engineers build things and make them work. Engineers apply known theories, methods, 
and tools appropriately and selectively to reach the goal. If an unforeseen problem occurs, 
engineers discovering solution while pursuing their goal. It is also widely recognized, 
that in the process of engineering, engineers operate in restricted environment - they 
must comply with organizational rules, financial restrictions, and also, they must 
reach the goal in time. 

The relatively new engineering discipline - the Software Engineering was born in 1968, 
when the first NATO Software Engineering Conference was held. It is thought, that the reason
to define Software Engineering as a discipline versus Programming was an attempt to bring 
a somewhat unpredictable and unoredred art of Programming into streamlined and controlled 
environment. And at that time, it was thought, that Software Engineering is not different 
from any other engineering fields. And just like any others disciplines of engineering, 
Software Engineering was defined as the application of a systematic, disciplined, quantifiable 
approach to the design, development, operation, and maintenance of the final product - the software.
Thus, delivering high quality software products within the budget and in time is the main goal 
and the most challenging task of Software Engineering.

In following years, scientific research in Software Engineering resulted in a number of software 
processes providing detailed guidelines on how to reach the goal efficiently and in time. 
These processes manifested themselfs as the means for improvements in terms of quality, 
speed, and execution cost over existing practices. Many processes were tested within academic 
settings and adopted by industry proving their superiority, some of this processes were 
further standardized, shaping the best practices of contemporary software development \cite{citeulike:9962021}. 

The processes, that I am adderssing here found in numerous studies and described at length in 
academic and industrial literature. Too numerous to name, they can be categorized by the level 
of their application:
\begin{itemize}
 \item global organizational standards, like CMMI, ISO 9000, and SPICE. 
 \item large industrial software models, such as Waterfall, Spiral, Cleanroom, etc.
 \item smaller scale, flexible methodologies and agile approaches: XP, SCRUM, FDD, 
TDD, Pair Programming, etc.
 \item general guidelines and principles aiming to improve the software process flow, 
such as ``build before commit'' and others.
 \item the processes for improving existing processes of software development 
on the organizationl, team, and personal levels: TSP, PSP, Six Sigma, etc.
\end{itemize}
While some of these resulted by a ``technology transfer'' - that is by an application of existing 
engineering principles to software development process (like Waterfall model), some, in prticular 
the agile methods, considered to be a software-engineering only processes. 

\section{Motivation}
As shown before, there exist numerious software process standards, models, methodologies, 
and coding conventions for virtually any scale of the project or a team size; and these are
applicable at any level and at any stage of the software development process. This amount of 
well-grounded and documented knowledge creates an impression that the area of software development 
process is thoroughly explored, and that there exists a deterministic choice for a model and a 
processes for any software project. However, it is far from being true - software projects still fail 
at the considerable high rate and there are many challenges exist when developing a software product.

This phenomena, also known as a ``software crisis'', was first recognized by Randell et al. in 1976 
\cite{naur1976software}. The attention was caught by the fact that many software projects ran 
over budget and schedule, some caused property damage \cite{citeulike:11044022}, and a few projects caused 
loss of life \cite{citeulike:712058}. Decades later, the ``Chaos Report'' from the Standish 
Group (Rubinstein) \cite{SDTimes} stating, that only ``35\% of software projects in 2006 can 
be categorized as successful - meaning they were completed on time, on budget and met 
user requirements''. These thirty five percent of success clearly manifest that it is somewhat 
illusory statement that we are capable to understand and to control software processes.

In recent decades, this poor performance of the mainstream software engineering processes 
ignited a new wave of research in the field. Gradually, researchers and practionioners alike 
recognized, that a direct application of classical engineering and a straightforward ``up-down'' 
software process governing might be somewhat errorneous. Also, it was recognized that over 
many years, continous formalization of the field and excessive attention to software process 
metrics shaped not only the software development practices landscape, but education and a 
professional code of conduct. This recognition forced some of the professional assosiations 
to review their licencing policies \cite{citeulike:11045517} and some educators to change their 
opinions \cite{citeulike:5203446}. 

All this continues to engage thoughts and fuels the search for an exact definition of software 
development. Is software development an engineering discipline? Is it a craft \cite{citeulike:5203446}? 
Or is it an art \cite{citeulike:11045694}?

What is obviously clear, is that there is a great room for research and improvement of our 
understanding of software processes. And my thesis is yet another attempt at the understanding. 
In my research work I am 
exploring techniques aiming the understanding of small processes which are 
rather the reflection of personal behaviors or habits of software development rather than a 
formalized constructs. Also, I would like to emphasize, that in this work I will not 
address the need and means of the process synthesis, its quality assessment, productiveness
or any topics related to the software product itself; I would rather focus on the specific issue - 
uncovering an existence and studying the programming habits. 

This thesis presents a methodology for finding recurrent behaviors through the 
analysis of the variety of software process artifacts left after performing a 
software process. I have called this methodology ``Software Trajectory'' and it consists 
of four distinct steps. Each of these steps has a specific goal and compromising variety of 
means to reach it. 
At first software process artifacts are identified and collected. 
At second, they are cleaned, organized and classified. 
On the third step particular research questions are formulated and data are organized and indexed. 
And finally, a set of KDD techniques is applied in order to undercover recurrent behaviors which 
could potentially shed a light on the performed process details. 

My personal motivation for performing this work is coming from the recognition of the 
importance of the software in our lives and the severity of issues with its development. 
Through my everyday experiences with software development and use I have stumble upon 
a number of issues which made me realize that mentioned ``software crisis'' phenomena is very real.
As a user in industrial and academic settings I often find myself facing software failures 
which create numerous difficulties for reaching production or research goals. As a developer, 
in an attempt to be productive and in order to deliver a better software I have studied and 
explored a number of formal processes, however, sometime I found myself seeing a very little of 
rationale behind their application, and moreover, in this exploration, when facing the process
application failing to help I was unable to comprehend what exactly went wrong and what need 
to be changed. All of these experiences made me studying software process research and exploring
novel approaches to software process recovery on my own in order to understand software process better.

\section{Research area overview}
Usually, software is coded by teams. Members of these teams have a variety of skills and experience, and
driven by their believes and motivations. While they usually agree on the use of particular technologies, 
development tools, and a development process with imposed timeline and a budget, the software development
activity is - as many other human activities - highly creative and mostly non-recurring. 
Thus, the choice of technology and tools provides only a marginal effect on this human-based and 
human-driven process. The common approach for studying this effect is to use the control environment 
for experiment and factor out human component and 

These are large scale industrial model such as Waterfall and Spiral, along with 
smaller and flexible agile approaches like XP, SCRUM or FDD. These also include sets of 
rules and recommendations which can be applied to certain stages of the software processes 
such as Test Driven Development or Pair Programming; general guidelines, helping 
to improve the process flow; standards and reccomendations, like CMMI, ISO 9000, and SPICE; 
guidlines for testing and measurements, code syntax rules and formatting styles, code comments 
recomendations \cite{citeulike:900855} etc. Finally, these include processes for 
improving existing processes of software development on the team \cite{citeulike:9962027} 
and personal levels \cite{citeulike:9962022}.

The plethora of these instructions, applicable for any software project at any level, creates 
an impression that the research area of software process is thoroughly explored and there 
is a deterministic choice for a model and processes for any software project, however,
it is very far from being true - software projects still fail and there are many challenges exist 
when developing a software product.
This phenomena also known as a ``software crisis'' was first recognized by Randell et al. in 1976 
\cite{naur1976software}. Thirty years later, the ``Chaos Report'' from the Standish 
Group (Rubinstein) \cite{SDTimes} stating, that only ``35\% of software projects in 2006 can 
be categorized as successful - meaning they were completed on time, on budget and met 
user requirements''. These thirty five percent of success clearly manifest that it is somewhat 
early to make a statement that we are fully understand and able to control software processes.
Moreover, it makes questionable the main direction of software process research.

Moreover, over years, while this idea of a software process formalizations shaped the 
programming practices, which once thought to be a creative human activity accessible by amateurs 
and hobbyists \cite{citeulike:9958822} into a serious engineering discipline, bounded 
by requirements for education, standardized processes, rules, certifications, and strict 
financial requirements from stakeholders the opposite idea was born - the idea of 
software development as a craft. Interesting that such a duality of views can be found 
in the work of a single person \cite{citeulike:5203446}.


, the effect which can be found by factoring out human component. \todo{here must add stuff}
While the particular are of ``software process'' effect is well studied by using controlled environment 
and conducting a series of studies. We must admit, however, that this approach provides a very poor metric - 
the ``local efficiency'' which refers to the efficiency and effectiveness of the tool or technique when it 
is applied in isolation from larger application context. 
For example, the typical efficiency study is limited to a specific type of development 
artifact, by a typical class of developers (with homogenous training and experience levels) 
regardless of the other techniques and entities involved in a real life development process. 
As a contrary  - the ``global efficiency'' of a tool or technique, relates to its role and 
impact on the whole project performance while considering all other tools and techniques 
involved in the entire development process and their interactions. Typically, global efficiency 
and effectiveness is very difficult to evaluate due to the cost of the study and its complexity.


As mentioned above, in this thesis I am focusing on a very narrow subject - exploring approaches
for uncovering of recurrent behaviors or ``programming habits'' out of software process artifacts.








