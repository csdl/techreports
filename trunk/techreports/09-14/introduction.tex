\chapter{Introduction}
Delivering high quality software products within the budget and in time is the main goal and the most 
challenging task of Software Engineering. Years of scientific research in this area resulted in a 
number of software processes providing detailed guidelines on how to reach 
the goal efficiently. These processes manifested themselfs as the means for improvements in terms 
of quality, speed and cost over existing practices. Many were implemented and tested within academic 
settings proving proposed superiority. Some of them were successfully adopted and standardized 
in industry, shaping the best practices of contemporary software development \cite{citeulike:9962021}. 

The processes I am mentioning here are the well-known large formal models such as Waterfall and Spiral, 
as well as more flexible iterative agile approaches like XP, SCRUM or FDD. These are also sets of 
rules and recommendations which can be applied to certain stages of the software processes 
such as Test Driven Development or Pair Programming; as well as general guidelines helping 
to improve the correctness of a product and standards, like CMMI or ISO 9000; guidlines for testing 
and measurements, code syntax rules and formatting styles, code comments 
recomendations \cite{citeulike:900855}. Moreover, there are plethora of processes for 
improving existing processes of software development on the team \cite{citeulike:9962027} 
and personal levels \cite{citeulike:9962022}.

From the first sight, by taking all this in account, one would guess that the area of software 
processes is thoroughly explored and there are clear choices of processes and models,  
however it is very far from being true. Despite the existence of a number of software models,
research and industrial use stories and vast documentation, software projects still fail. 
This phenomena also known as a ``software crisis'' was first mentioned by Randell et al. in 1976 
\cite{naur1976software}. This also is supported by the ``Chaos Report'' from the Standish 
Group (Rubinstein) \cite{SDTimes} stating that only ``35\% of software projects in 2006 can 
be categorized as successful - meaning they were completed on time, on budget and met 
user requirements''. These thirty five percent of success clearly saying that it is somewhat 
difficult to make a statement that we are fully understand and able to control software processes. 

Moreover, over years, while this idea of a software process formalizations shaped the 
programming practices, which once thought to be a creative human activity accessible by amateurs 
and hobbyists \cite{citeulike:9958822} into a serious engineering discipline, bounded 
by requirements for education, standardized processes, rules, certifications, and strict 
financial requirements from stakeholders the opposite idea was born - the idea of 
software development as a craft. Interesting that such a duality of views can be found 
in the work of a single person \cite{citeulike:5203446}.

 documentation many 
use stories and studies all the known facts and application of logical 
reasoning, it is extremely diffcult to foretell what is the ``best'' process to choose for a 
certain software project. This uncertainty only increases with the growth of the project complexity.
What managers are left with, are the equally succesfull alternatives with vague promises. 

Clearly, there is a great room for research and improvement of our understanding of software processes.
This exploratory study is yet another attempt at the understanding. In my research work I am 
exploring techniques aiming the understanding of small processes which are 
rather the reflection of personal behaviors or habits of software development rather than a 
formalized constructs. Also, I would like to emphasize, that in this work I will not 
address the need and means of the process synthesis, its quality assessment, productiveness
or any topics related to the software product itself; I would rather focus on the specific issue - 
uncovering an existence and studying the programming habits. 

This thesis presents a methodology for finding recurrent behaviors through the 
analysis of the variety of software process artifacts left after performing a 
software process. I have called this methodology ``Software Trajectory'' and it consists 
of four distinct steps. Each of these steps has a specific goal and compromising variety of 
means to reach it. 
At first software process artifacts are identified and collected. 
At second, they are cleaned, organized and classified. 
On the third step particular research questions are formulated and data are organized and indexed. 
And finally, a set of KDD techniques is applied in order to undercover recurrent behaviors which 
could potentially shed a light on the performed process details. 

My personal motivation for performing this work is coming from the recognition of the 
importance of the software in our lives and the severity of issues with its development. 
Through my everyday experiences with software development and use I have stumble upon 
a number of issues which made me realize that mentioned ``software crisis'' phenomena is very real.
As a user in industrial and academic settings I often find myself facing software failures 
which create numerous difficulties for reaching production or research goals. As a developer, 
in an attempt to be productive and in order to deliver a better software I have studied and 
explored a number of formal processes, however, sometime I found myself seeing a very little of 
rationale behind their application, and moreover, in this exploration, when facing the process
application failing to help I was unable to comprehend what exactly went wrong and what need 
to be changed. All of these experiences made me studying software process research and exploring
novel approaches to software process recovery on my own in order to understand software process better.

\section{Research area overview}
Most of the activities in software development are human-based and human-driven. Thus, the choice 
of technology and tools provides only the marginal effect - the effect which can be found by 
factoring out human component. The only known approach of finding the technology effect and 
its effectiveness is by using controlled environment study and conducting a series of studies. 
This approach, however, provides a very poor metric - the ``local efficiency'' which refers to 
the efficiency and effectiveness of the tool or technique when it is applied in isolation 
from larger application context. 
For example, the typical efficiency study is limited to a specific type of development 
artifact, by a typical class of developers (with homogenous training and experience levels) 
regardless of the other techniques and entities involved in a real life development process. 
As a contrary  - the ``global efficiency'' of a tool or technique, relates to its role and 
impact on the whole project performance while considering all other tools and techniques 
involved in the entire development process and their interactions. Typically, global efficiency 
and effectiveness is very difficult to evaluate due to the cost of the study and its complexity.

===

Software is usually coded by teams. Members of these teams have a variety of skills, experiences, 
believes and motivations. While they agree on use of particular technologies, development tools, 
and a development process which also imposes a timeline and a budget, the software development
activity is highly creative and non-recurring. 

. These are necessary constraints placed in order to to keep work organized, 
however there is a great freedom in what they actually do in every single moment of time in 
order to progress towards lines of code which eventually will result in software. 

There are "pathological" software/business processes that are resistant to systematic (re)engineering, and thus should be avoided.

    * These processes are characterized by:
          o lack of frequent enactment repetition
          o ad-hoc process structure or flow
          o highly creative, non-recurring activities
          o long-duration process enactment cycle times
          o processes whose modeling or formalization overwhelms their simplicity.

For example one developer may follow test first process while
another writes tests at last.  This freedom of choice in ordering of development activities 
while being much appreciated by talented and creative individuals creates an impression 
of chaotic and unordered activities for random observers, newbies and people in 
charge - so there we have all the attempts of imposing an order 
(or control) on all of the development activities. Metrics and models of processes


As mentioned above, in this thesis I am focusing on a very narrow subject - exploring approaches
for uncovering of recurrent behaviors or ``programming habits'' out of software process artifacts.








