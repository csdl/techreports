\chapter{Introduction}
Delivering high quality software products within the budget and in time is the main goal and the most 
challenging task of Software Engineering. Years of the scientific research in
this area resulted in a number of software processes providing detailed guidelines on how to reach 
the goal efficiently. Many of these processes were successfully standardized and adopted 
in industry shaping the best practices of contemporary software development. 
\todo[inline]{need to say about the age (time span) of programming as a discipline}
Interesting that all these formalization of the process lead to some sort of paradox in which 
once programming as creative human activity accessible by amateurs become bounded by requirements 
for education, rules, standards, certifications and strict requirements for the processes 
from stakeholders. 

Volumes of research literature propose various processes manifest them as the 
means for improvements of a software development process in terms of quality, speed and cost. 
Many of these processes were not only proposed but implemented and tried within academic 
and industrial settings proving certain characteristics. We know large formal processes: 
Waterfall and Spiral, we know small and strict guidelines for Agile and SCRUM. 
There are also sets of rules and recommendations which can be applied to certain stages of these 
software process such as Test Driven Development and Pair Programming; and finally there are general 
guidelines helping to improve the correctness of a product - rules for naming variables, 
formatting code blocks and commenting code. 


However only ``35\% of software projects in 2006 can be categorized as successful - meaning 
they were completed on time, on budget and met user requirements'' according to Chaos Report
from the Standish Group (Rubinstein) \cite{SDTimes}. Taking all of this into account it is somewhat difficult 
to make a statement that we understand and able to control software processes...

Yet, this research is another attempt at understanding of the software development process. 
Before all I would like to emphasize that in this dissertation I will not address the need and means 
of the process synthesis, its quality assessment, or any topics related to the
software itself. I would rather focus on the specific issue - uncovering an existence 
and studying of roles of recurrent behaviors - the programming habits. 

My personal greatest motivation for performing this work is coming from the recognition of the 
software crisis phenomena through my everyday experiences with software development and usage. 
As a user, in industrial and academical settings I often find myself facing software failures 
which create numerous difficulties for reaching production or research goals. As a developer, 
I have explored a number of formal processes and sometime found myself seeing a very little of 
rationale value behind application of these processes; moreover, in this exploration I have 
faced situations when process fails and need to be changed but I was unable to comprehend 
what exactly must be changed. 

In this work I will present a methodology for finding recurrent behaviors through the 
analysis of the software process artifacts trails left in various places after performing a 
software process. I have called this methodology ``Software Trajectory'' and it consists 
of four steps. Each of these steps has a specific goal and compromising variety of means to
reach it. At first software process artifacts are identified and collected. At second, 
they are organized and classified. At third, particular research questions are formulated and
data are organized and indexed. Finally, a set of KDD techniques is applied in order to 
undercover recurrent behaviors which could potentially shed a light on the performed process
details. 

\section{Research area overview}
Software is usually coded by teams. Members of these teams are agreed and bound to use 
a particular technologies and development tools, they also agree on following well defined 
development process which is constrained by a timeline and budget. These are necessery 
constraints to keep work organized, however there is a great freedom in what they actually 
do in every single moment of time in order to progress towards lines of code which eventually 
will result in software. For example one developer may follow test first process while
another writes tests at last.  This freedom of choice in ordering of development activities 
while being much appreciated by talanted and creative individuals creates an impression 
of chaotic and unordered activities for random observers, newbies and people in 
charge - so there we have all the attempts of imposing an order 
(or control) on all of the development activities. Metrics and models of processes




