\chapter{Introduction}
Delivering high quality software products within the budget and time is the main goal and the most challenging task of Software Engineering. Years of the scientific research in this area resulted in a number of software processes providing detailed guidelines on how to reach the goal efficiently. Many of these processes were successfully adopted in industry and shaped best practices of contemporary software development. There are rules, standards, and industrial certifications for developers as well as strict requirements for the processes from stakeholders... 

There are strict models of the whole lifecycle of software development such as Waterfall or Spiral; there are sets of rules applied to certain stages of software process such as Test Driven Development and Pair Programming; and there are general guidlines helping to improve the correctness of a product.

Volumes of formal years various approaches and means were proposed and tried within academic and industrial settings in attempts to improve reach the goal. This experience resulted in the formal software engineering processes - sets of rules and guidelines. Examples of such formal processes are  Waterfall, Scrum, Test Driven Development and others. All these formal processes manifest themselfs as the means for improvements of a software development process. 

However only ``35\% of software projects in 2006 can be categorized as successful meaning they were completed on time, on budget and met user requirements'' according Reports from the Standish Group (Rubinstein). Taking all of this into account it is very hard to say that we understand and able to control software processes.

This research is yet another attempt at understanding of the software building (creation) process. Before all I would like to emphasize that in this dissertation I will not address the need and means of the process synthesis, its quality assessment, or any topics related to the software itself. I would rather focus on the specific issue - uncovering an existence and studying of roles of recurrent behaviors - the programming habits. 

My personal greatest motivation for performing this work is coming from the recognition of the software crisis phenomena through my everyday experiences with software development and usage. As a user, in industrial and academical settings I often find myself facing software failures which create numerous difficulties for reaching production or research goals. As a developer and a team lead, I have explored various formal processes and sometime found myself seeing a very little of rationale value behind application of these processes; moreover, in this exploration I have faced situations when process fails and need to be changed but I was unable to comprehend where and what must be changed. 

In this work I will present a methodology for finding recurrent behaviors through the analysis of the software process artifacts trails left in various places after performing a software process. I have called this methodology ``Software Trajectory'' and it consists of four steps. Each of these steps has a specific goal and compromising variety of means to reach it. At first software process artifacts are adentified and collected. At second, they are organized and classified. At third, particular research questions are formulated and data are organized and indexed. Finally, a set of KDD techniques is applied in undercover recurrent behaviors which could potentially shed a light on the performed process details. 

\section{Research area overview}
Delivering high quality software products within the budget and time is a 



and techniques for the process high-level as well as everyday debvelopment of the software while software comprehension of the Software is usually coded by teams. Members of these teams agreed and bound to use a particular technologies and development tools and follow somewhat defined process and timeline, however there is a great freedom in what they actually do in every single moment of time in order to progress towards lines of code which eventually will result in software. For example one developer follows test first process while another writes test last. This freedom of choice in ordering of development activities while being much appreciated by talanted and creative individuals creates an impression of chaotic and unordered activities for random observers, newbies and people in charge - so there we have all the attempts of imposing an order (or control) on all of the development activities. Metrics and models of processes 

 creates chaos in the an im, prticular activity in particular time ies is thought to be 


 rules in their everyday development activity, however  and peopleThe enactment of a software process leaves a set of various artifacts such as formal design documents or test specifications, mailing list messages, bug reports and version control archives. Some of these will support subsequent development and maintenance, some will be left behind, but this artifacts trails serve as a rich source of information for software process researchers. 
