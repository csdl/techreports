\section{Apriori algorithm}

Family of seminal Apriori algorithms was proposed in 1994 by Agrawal \& Srikant \cite{citeulike:775528}. These algorithms are based on the naive \textit{apriori association rule} stating that \textit{any sub-pattern of a frequent pattern must be frequent}. The name ``apriori'' is based on the fact of using of a prior knowledge by the algorithm: the $k$-th itemsets are used to generate $(k+1)$ itemsets.

Algorithm starts by scanning a database and finding all possible $1$-itemsets counting their support and keeping only those which satisfy to the minimal support value. This itemsets result in the set $L_{1}$. This set, in turn, is used to construct $L_{2}$ set which is a combination of all possible itemsets from $L_{1}$, once construction of $L_{2}$ complete one full scan of the database required to compute the support of each of the itemsets. For finding the $L_{3}$ and so on the Apriori property is used, which reduces the search space while generating candidates. Apriori property is that \textit{all non-empty subsets of the frequent itemset must be also frequent}.

The apriori property is used in the candidate itemset generation step in the next fashion: if itemset $I$ does not satisfies to minimal support value, i.e. $Support(I) \; \leq \; min\_support$, the itemset $I'$ resulting from adding item $i$ into the $I$ ($I' = I \cup i$) cannot occur mor efrequently than $I$, i.e. $Support(I') \; \leq \; min\_support$. In some literature this property called \textit{antimonotone} property as an opposite to monotone one.

The generation of itemsets $L_{k}$ for $k > 2$ consists of two steps: join and prune.

\textbf{The Join step.}

To find itemset $L_{k}$ based on $L_{k-1}$ we first generate the set $C_{k}$ - the set of all candidate patterns based on the join of $L_{k-1}$ with itself: $L_{k-1} \times L_{k-1}$. We will introduce a notation $l_{i,j}$ for $j$th item of the itemset $i$, also we must note, that by convention, Apriori assumes that all items within an itemset $l_{i}$ are sorted alphabetically, i.e. that $l_{i,j} < l_{i,j+1}$. Taking all above in the account, the join of $L_{k-1} \times L_{k-1}$ is performed only on itemsets $l_{i}$ and $l_{j}$ if their first $k-2$ items are the same, i.e. $l_{i,m} = l_{j,m}, \; \forall m \in [0,k-2]$, this generates next candidate itemsets: ${l_{i,1},l_{i,2},l_{i,3},...,l_{i,k-1},l_{j,k-1}}$. Here we are also making sure that $l_{i,k-1} < l_{j,k-1}$ to avoid duplicates within $C_{k}$.

\textbf{The Prune step.}

The set $C_{k}$ generated during the join step is a superset of $L_{k}$ and it's members may not be frequent enough to satisfy a minimal support value.
