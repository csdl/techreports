\chapter{Software Process}
There are different approaches for software development which were designed in order to 
support the creation of software systems. The common part of these approaches is the use 
of a software process model. This model provides developers with guidance about their tasks 
and the activities that should be undertaken during development. It is advocated that the 
use of established and well structured model is crucial for the complex projects in order 
to orchestrate collaborative effort of multiple teams. 

These models (also called methodologies of software development) can be characterized 
by the series of distinct phases. 
Each of these phases is executed with a particular goal: some will provide a part of the 
software system, other will deliver engineering documentation or a user manual, or 
validate an existing code. Examples of such phases are the requirements collection, 
user manual writing or the coding of a functional module of the software system. 
While the methodology prescribes an ordering of carried activities, it also facilitates
a framework for estimation of needed resources, defines major milestones, and provides 
means for time and effort monitoring and management. 

In this chapter I will review major of exising software process models providing additional 
information about their derivatives and discussing their strengths and weaknesses.
The purpose of this narrowing is to present the current state of the art in software 
processes.

\section{Waterfall model}
The Waterfall model is probably the oldest of existing software process models and it is 
very popular in the domain of development of large and complex software systems. 
This model is a refinement of a stagewise model developed in 50th and its 
original version is credited to Royce (1970) \cite{citeulike:9982731}. There were two 
changes from the predecessor - first was a recognition of the feedback loops between 
stages and its limitation to successive stages only - in order to exclude expensive
cross-stage rework, while the second change was the inclusion of a prototyping stage
\cite{Boehm95anchoringthe}.

Waterfall model is an example of a plan-driven process - one must plan and schedule all 
of the activities before their execution. Model has many variations and the approach 
articulated by the model forms the basis of many standards in the software industry.

There is successive and distinct progression of stages in waterfall model; each state 
is well defined and forms the basis for the successive one. In addition to specific 
deliverable, each state producing a document which describes what exactly occurred 
during the stage, providing certain visibility to the processes, and facilitating 
audit. Each state has milestones and deliverables explicitly defined.

Five stages of waterfall model reflect the fundamental development activities:
\begin{enumerate}
 \item \textit{Requirements analysis and definition.} The feasibility study 
is conducted 
and the requirements collected. The system functionality clarified and
documented in details - the requirements specification document - delivered  
and will serve as the system specification. It is assumed that customer's 
expectations are articulated and will not change much throughout the development 
process.
 \item \textit{The system design.} Within this phase requirements for hardware and 
software components defined by the establishing an overall system architecture.
All system modules and their interactions are designed in accordance with 
collected requirements.
 \item \textit{Implementation and unit testing.} The actual code produced, individual 
modules are tested individually. This phase embeds all quality control checks.
 \item \textit{Integration and system testing.} System assembled and once complete, it
is tested and evaluated in actual conditions (alpha tested).
 \item \textit{Delivery and Maintenance.} System is tested by actual customer(s) 
(beta testing). Identified errors are corrected and if found satisfiable, 
software system is installed and put into use. Maintenance involves error correction, 
improvements of system units and enhancements of services if desired.
\end{enumerate}

During transition from stage to stage within the waterfall model, previous state 
should be signed-off - approved to be in finished state. In other 
word, states should not overlap, however in the real life problems often discovered
later on - for example it is often happens that problems with design 
discovered only after implementation is started and so on. In such situation
process returns to the problematic phase and changes are made and reflected in 
the documentation. These iterations are very costly in time and effort and 
usually after a certain number of iterations problematic stages considered 
``frozen'' and development continues. Identified and not resolved issues persist
through the further work and if possible - covered by workarounds, if not - 
they just ignored and system may not perform correctly or lack some functionality 
afterwards.

The big advantage of waterfall model of software development process is that 
it is consistent with other engineering models in terms of general approach, 
its flow and produced documentation. It seems to be manager-friendly too since
it is easy to track the progress against the development plan. The major 
problem with this model is
that within such a specification-based approach stakeholders finding it 
extremely difficult to articulate their requirements in advance and 
that requirements changes are very hard to incorporate after first stages are passed.

In 1988 Boehm revisits waterfall model and after re-stating its fundamental problems 
offers three classes of improved software process models - evolutionary development 
model, the transform model and the spiral model \cite{citeulike:10002126}.

\subsection{Evolutionary development}
Evolutionary development proposed by McCracken\&Jackson in 1982 \cite{citeulike:3996892}
was among the first reactions to the waterfall model's problems. Instead of moving 
through well-defined stages and producing number of documents, it claims the only
stage - release of extended system capability which is a response to the user 
requirements and is based on the operational experience. Evolutionary paradighm 
is built around early release of operational product (prototype) wnd its gradual 
enhancement. This approach provided stakeholders with something real - the functional 
model from very early stages and with some basis to build estimations through 
determined sequence of needed improvements.

However, while being very contrast to waterfall - this new model was found stigmated 
with weaknesses of the old code-and-fix approach - spaghetti code and the lack of 
formal planning - the exact reasons waterfall model was invented... Also, 
evolutionary development does not provide any means for identifying fixing early 
errorneous design decision - working around fundamental software issues led to 
evolution of the large expensive to maintain codebase instead of re-considering 
early decisions.


\subsection{Spiral model}
The spiral model reflects the concept in which each of development cycles involves a 
progression adressing the same sequence of steps as in previous level.


\subsection{Cleanroom software engineering}
Another of waterfall model derivatives is a Cleanroom development methodology, which is
a fusion of waterfall model with formal methods approach. 
Following the formal methodology, stages of waterfall model reshaped into 
\begin{enumerate}
 \item \textit{Formal specification} phase, where the software system is presented as 
a state-transition model with input and output. The states of the system and
its transitions (reactions on input) reflect specification and requirements.
 \item \textit{Structured, incremental development} phase. By application of the 
cleanroom methodology the software is partitioned into increments using the 
specification and the development process Within cleanroom
development process only a limited amount of programming constructs allowed,
and the development process is an iterative refinement of specification
\end{enumerate}

1) formal specification phase; 2) incremental, formal development and verification 
, formal methods are a particular kind of mathematically-based techniques for
the specification, development and verification of software and hardware systems

\section{}

The Institute of Electrical and Electronics Engineers defines software engineering as 
“the application of a systematic, disciplined, quantifiable approach to development, 
operation, and maintenance of software; that is, the application of engineering software”
