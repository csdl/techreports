\chapter{Software artifacts}
Software development activity leaves many artifacts. The variety depends on the complexity of the project 
as well as on the software process model followed by developers. Typical formal artifacts include the 
following: 
\begin{itemize}
 \item Sytem specification documents
 \item Software project plan
 \item Software requirements specification
 \item Software design specification
  \begin{itemize}
   \item Data flow design specification
   \item Interface design specification
   \item System architechture specification
  \end{itemize}
 \item Source code
 \item Code review reports
 \item Software test specification
  \begin{itemize}
   \item Test plan
   \item Test cases and test data
   \item Test reports
  \end{itemize}
 \item Installation manual (administration manual)
 \item User manual
 \item Maintenance documents
  \begin{itemize}
   \item Bug reports, feature requests
   \item Change reports
  \end{itemize}
\end{itemize}
Along with formal set of artifacts, there is a variety of informal artifacts. These include SCM system logs
developers mailing list archives, exchange not designed 
and produced to be formally or automatically analyzed

\section{Software configuration management}
Software evolve. The software evolution happens under the pressure from stakeholders, end users and due to the infomation technology evolution. It is practically inevitable.
\todo[size=\tiny]{Here I need to narrow the need of SCM and the evolution of software}
``Software configuration management'' or SCM (also known as ``software change and configuration management'') is a term used to descibe means of software evolution control by
software developers. These include but no limited to standards, approaches, techniques and tools for initiating, evaluating, and controlling change of software product before,
during and after the development process. Configuration management is an integral part of the software process spanning across all its phases and providing stucture and control
imposed on the software change, thus enabling it to be performed in a way which is reproducible and does not destroy the integrity of software.

Recalling the discussion of Goals of SCM will clearly paint a picture of what basic features an ideal SCM Tool should have in it.
•       First and most basic functionality a Software Configuration Management tool should provide is support for a central file repository. All other functionalities are around
managing and tracking of these repository items.
•       Secondly it is important that the SCM tool provides the capabilities of the distributed team to work together from a central repository. Features like file locking
mechanism, file comparison and atomic commits are to name a few.
•       The SCM tool should also provide a simple mechanism for creating and maintaining private branches and for merging changes from the main code line to the private branch, and
vice versa.
•       The SCM tool should provide visibility into changes made for each task and support the ability to work by task instead of by individual file, to merge changes from one
configuration to another, and to revert changes for a task if needed.
•       The SCM tool should also provide an easy mechanism for rolling back to the last good integration version.
•       The SCM tool supports simple creation of a hierarchy, give visibility into the changes at each stage, and enable straightforward merging between stages.
•       Tagging is another feature very common and useful which involves giving meaningful names to specific revisions. These names are generally called Tags or Labels.
•       The SCM tool should support re-targeting features without the need to write and maintain scripts to perform the operations.
•       In order to re-factor code and still be able to trace through the history of changes, an SCM tool must support file and directory rename and move operations and track the
operations as part of the element’s history.
•       The SCM tool should easily integrate with the continuous integration server so that latest code from the SCM repository can be extracted and compiled continuously and whole
process can be automated.

