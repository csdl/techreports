\documentclass[11pt,oneside]{article}
\usepackage{fullpage}
\begin{document}
\title{Dissertation proposal abstract}
\author{Pavel Senin \\
 \texttt{senin@hawaii.edu}
}
\date{July 2009}
\maketitle

\section{Motivation}
Since the first computers were build and first programs written many research was done on understanding of both: \textit{programming} and \textit{programs}. In contemporary understanding the human activity called ``\textit{programming}'' consists of many iterative phases and interleaving activities such as planning, writing code, testing, debugging, and maintaining the source code of computer programs. All these high-level phases are also aggregating many of low-level processes and episodes. In addition to that, the social interactions among developers and between developers and users are adding even more complexity into each phase of the programming. The computer program (\textit{system}, or \textit{software}) itself, from other hands, has it's own lifecycle which obviously directed by the programming effort but also, and in many cases, program, especially large software systems, can be found ``orchestrating'' needed programming activities and social interactions. All of this creates great process complexity and spurious connections between different activities making understanding of software development process and software evolution difficult.

As any systematic study, the process of ``understanding'' involves measurements, comparisons and various experiments. Over the years many work has been done in order to discover and standardize metrics for programming activity and for the computer systems. Currently we have many software utilities aiding the collection and analysis of software metrics. All of these tools and ongoing research created a rich background for an investigation of the software processes and many successfull work has been done in discovering of various specific patterns and metrics charachterizing process and software features. Some of the results of this effort are such mature process models as CMM, ISO, PSP etc. which were recognized as industry standards.

Nevertheless, software development process stays error-prone and many, more than a half, of all software development projects ending up failing for many reasons. Some of them getting abandoned runing out of budget, some delivered with so low quality or so late that they become useless and some, when delivered, never get used by prospective users because they do not fullfill original requirements. The cost of this lost effort is enormous and it clearly reveals our incomplete knowledge of the software process fueling ongoing research. 

\section{Contribution and impact}
Here, at the ICS Department of the University of Hawaii we are developing an advance in-process software engineering measurement and analysis system called Hackystat aiding our own research in the field of software process. Personally having three years of experience with Hackystat as a user and participating in the design and development of the version 8 for more than two years, I see the Hackystat as an ``one-stop shopping place'' for metrics collection utilities, storage database, analysis engine and visualization modules. The latest Hackystat implementation is a sophisticated distributed, service-oriented system which provides users not only with visualization of all metrics and their derivatives, but aids the understanding of metrics trend dynamics through the system of rules and alarm indicators. What the system is lacking in my opinion is it's own intelligence, ability to discover novel rules and patterns in the process connecting them with some known process phenomena. 

In other words, most of the in-process and post-process analysis is done completely manually and requires advance understanding of both metrics and the generative process. work this work was done empirically - first phenomena was observed and metrics and events were discovered. lately rules whether the  discovery of certain featured process and later investigation of it through the metricative effort.


\section{Methods}

\end{document}
