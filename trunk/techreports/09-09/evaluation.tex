\chapter{Experimental evaluation} \label{experiments}
Three case studies: a pilot study, a classroom case study, and a public data case study will be conducted in order to empirically evaluate capabilities and performance of the Hackystat Trajectory framework. A pilot study is ongoing along with development of the framework and some of the results discussed in this chapter.

The primary goal of these studies is to assess the ability of the framework to reproduce well known recurrent behavioral patterns (for example TDD), as well as the ability to discover novel ones. As the secondary goal I see the classification and extension of the current Hackystat sensors family in order to improve the system performance. It is quite possible that some of the currently collected sensor data will be excluded from the Trajectory Analysis datasets, while some new ones will be designed and developed in order to capture important features from software process. 

\section{Pilot study}\label{pilot.evaluation}
In order to demonstrate the ability of the current framework implementation to perform telemetry indexing and temporal recurrent patterns extraction I have conducted two pilot experiments discussed further. 

\subsection{Clustering of the Hackystat Telemetry streams}
The main purpose of the first experiment was the evaluation of PAA and SAX approximations ability to capture recurrent temporal patterns within the set of telemetry streams. Knowing about usually misleading results of time-series clustering \cite{citeulike:227029} I did not expect to capture much interesting facts, nevertheless the results look somewhat interesting.

For this experiment I was using a real data collected during the Spring'09 software engineering class. This dataset represents Hackystat metrics collected during sixty days of the classroom project development conducted by eight students. Following clustering experiments were conducted by using distance between vectors of motif frequencies:
\begin{itemize}
	\item Clustering of a software process related telemetry streams collected from individual developers. I was able to group developers with the similar behavioral patterns within clusters, which indicates the correctness of the classification approach.
	\item Clustering of software product-related telemetry streams by using shared motif frequencies. As results of this experiment I was able to group telemetry streams, but while stream groups look intuitively meaningful, close examination of the streams indicates that this grouping happened just because of the method applied. This results clearly pointing that instead of the motifs frequencies, some temporal ordering should be taking in account.
\end{itemize}

\begin{figure}[tbp]
   \centering
   \includegraphics[height=80mm]{sequential_growth.eps}
   \caption{The illustration of finding of sequential $growth \; pattern$ in two DevTime telemetry streams. Panel $a$: The Hackystat ProjectBrowser showing telemetry streams. Panel $b$: the TrajectoryBrowser showing same telemetry streams along with identified pattern. Panel $c$: the symbolic representation of streams with highlighted pattern.}
   \label{fig:sequential_growth}
\end{figure}

\subsection{Sequential patterns search}
The second experiment, aiming a discovery of sequential patterns was also conducted by using a real data from my own concurrent development of two software projects. While working on the Hackystat Trajectory framework I made a decision to split code into two parts: the algorithms implementations library JMotif, and user-interface part, TrajectoryBrowser. While this decision ease the development process, it introduced heavy dependency of UI part on the JMotif API, which provides variations of DTW, PAA and SAX algorithms along with defining data structures for indexing and clustering. Following iterative and incremental pattern in my development, I was changing JMotif public API three times, which consequently involved extensive refactoring in the ProjectBrowser code. This dependency can be clearly deducted from observing DevTime streams at Figure \ref{fig:sequential_growth} panel $a$. 

In order to capture this dependency pattern in two Telemetry streams, representing daily amount of development time spent on the TrajectoryBrowser and JMotif projects, I have defined a synthetic \textit{growth pattern} as the large positive delta value between previous and current day effort. By transforming Telemetry streams with this simple rule in the symbolic form I have obtained a two dimensional symbolic time series, where letter $G$ represents a growth pattern, see Figure \ref{fig:sequential_growth} panel $c$. I have defined a formal rule for \textit{sequential growth} pattern as the pattern like $G_{JMotif}\; \rightarrow \; G_{TrajectoryBrowser}$ where distance between these $G$s is less than three days. By application of this rule I have identified a pattern which exactly corresponds to my experience.
