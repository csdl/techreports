%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Latex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% future.tex -- 
%% Author          : Joe Dane
%% Created On      : Tue Oct  5 16:18:38 1999
%% Last Modified By: Joe Dane
%% Last Modified On: Mon Nov  8 14:45:45 1999
%% RCS: $Id$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Copyright (C) 1999 Joe Dane
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 

\chapter{Future Directions}
\label{chap:future}

There are a number of paths which could be followed to improve LOCC.  The
most obvious expansion path is the addition of new language support.  We
have seen how the inclusion of a parser in a size metric can lead to useful 
information.  However, building a parser for a complex language is not a
trivial task.  Parser generators such as JavaCC go a long
ways toward making the job easier, but there is still a non-trivial amount
of work left to the implementor.

Once a parser has been constructed for a language, it is a simple matter to 
construct size metrics for the language.  The effort spent on the parser
can be leveraged to provide any number of size metrics, each expressing a
different view of the ``size'' of the code.  Experimentation may lead to
the identification of one of these metrics as being superior to the
others.  Alternatively, multiple metric could continue to be used to give a 
fuller description of program size than could be obtained with a single
metric.

One particular application of a parser could be the definition of a
function point mapping for the language.  For example, in the Java
programming language we may decide that {\tt TextField\/}s correspond to
Albrecht's concept of a user input, and we could use the parser to
determine the number of {\tt TextField\/}s denoted in the source.  The
parser would have available the inheritance hierarchy, so that subclasses
would also be counted correctly.

More research is needed to imbue the statement and expression based metrics 
in LOCC with more intelligence.  These metrics perform perfectly when
applied to the total size of a Java source file, but make rather simple
decisions when it comes to size difference measuring.  The current solution 
is to take the difference in total size between two program units as the
size difference.  While this is a reasonable first approximation, it seems
that a more precise way of expressing the magnitude of the difference
between two parse trees is needed.

Another possible extension to LOCC would be the ability to have a central
repository of size metrics which can be accessed over a network.  LOCC's
dynamic code loading is currently restricted to loading code located on
local disk resources.  Extending LOCC to load from a network stream or URL
would be straightforward.
