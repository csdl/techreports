%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Latex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% old-intro.tex -- 
%% Author          : Joe Dane
%% Created On      : Tue Sep  7 13:29:10 1999
%% Last Modified By: Joe Dane
%% Last Modified On: Tue Oct  5 15:32:38 1999
%% RCS: $Id: introduction.tex,v 1.1 1999/09/07 23:31:50 jdane Exp jdane $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Copyright (C) 1999 Joe Dane
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 

\begin{introduction}
When asked "How large is ths program?", the typical programmer has an array
of answers, or methods which lead to answers, with which to respond.  Some
of these methods are to

* pick a standard means of counting size and apply it to the program.  

* use a method expresssly developed for the program, for the problem which the
  program was designed to solve, or for the language in which the program
  was implemented.

* lie.

The final method might seem a bit shocking, but we will get around to
explaining it shortly.

The programmer's decision as to which method to use is probably influenced
by a number of factors.  These might include

* Institutional guidlines.  Perhaps the programmer works within an
  organization which prescribes a certain method of counting program size.

* Convenience.  In general, the programmer will choose the method which
  allows the simplest path to an answer, all other things being equal.

* Fear.  The programmer might feel that his performance will be evaluated
  on the basis of his answer to our hypothetical question.

The last point above is clearly related to the last point above that [ugh,
FIX].  Program size measurement continues to be neglected [change] in large
part because it is so easy for a measure to be inaccurate.  In fact, it is
easy for the very act (or the threat of the act, at least) of measurement
to change the thing being measured.  In this case, the putative threat that
the programmer feels (because he needs to meet a quota or some productivity
goals) can cause him to artificially inflate the measure of program size.

There have been size measurement methods which attempt to take this
"measurement dysfunction" into account.  Function points, for example, move
the counting from the syntactic domain to the semantic.  Instead of
counting, e.g., source lines of code, one counts the number of "input
fields", and other semantic objects.  Function point counting has been used
successfully, and clearly has a place.  However, it also has weaknesses,
including the fact that the count units must be redefined for each type of
program.

Another way of avoiding measurement dysfunction is to keep data collected
during the software development process private.  ...

Say something about how, no matter what size counting method is used, if
it's not convenient and mostly automatic, it will be misused.

Syntax sensitive counting.
Instead of just total lines of code (or number
of function points) in a file/project, one would lke to know something
about the number of lines per class, method, function, module, etc..
Whatever syntactic units the source language allows, the programmer

This inplies that the size counting system must know "something" aobut the
source language being counted.  "Something", in that the system need only
recognize as much syntactic detail as the programmer is interested in
knowing about.  For instance. a Java size counting method only interested
in class level counts would have to know what a Java class looks like, but
would need know nothing about the syntax of methods, memebers, and the
other syntactic miscellany in the Java language.

Of course, often we are able to find grammars for the syntax of the entire
language, and developers of size counting modules can use whatever level of
detai they like, and simply ignore the rest.

Introduce the diff problem.  
Another complaint against traditional size
counting methods is that they fail to adequetly reflect the software
creation process.  In particular, methods which count a program simply as a
monolithic thing existing at a particluar time ignore the fact that
software development is usually a process of adapting and refining existing
code.  A project may require the maintainance of a project, with changes
limited to bug fixing, or the extension of a current version of a system to
incorporate additinonal features, or the use of a previously developed
library of code.

In some of these cases the added code can be entirely separated from the
existing code, say, by keeping the new code in separate source files.  In
some cases, however, this is not possible, and the new and old code becomes
entwinned within source files.  Counting which considers only total size,
whether that size be expressed as lines or function points, clearly will
not be sufficient.  More accurately, we could say that the total size of
the program is not reflective of the effort required to produce (that
version) of the program.

What is needed is a tool reminiscent of the UNIX "diff" program.  In fact,
diff itself may be enough, given that the difference counting implemented
by diff is compatible with the size measure the programmer is generating.
Other solutions may be more appropriate in other circumstnaces.  For
example, a diff which was sensitive to language specific issues, such as
those discussed above, may give the programmer more interesting
information.  In any case, it should be clear that any size counting regime
must deal with the issue of code evolution.

Reasons for counting in a personal process.  
Once we have limited the flow
of process data, can we still justify the time spect counting size at all?
What should motivate programmers to care at all about program size?  The
most important reason to care about size is that, in general, the size of a
program is correlated with the amount of effort expended to produde it.  In
particular, big programs take linger to write than small ones.  Given a
body of historical data on program size and the time spent working on those
programs, a programmer can determine his personal profile: how long should
to take me to produce a program of a certain size, and how confident can I
be of this estimate.  The programmer can use hos personal data to
extrapolate furture performance, and can thereby improve his estimates of
how long a given task will take.  It is important to realize how important
this is.  Underestimation of the time and resources required is one of the
most prominent complaints ... [justify this?]

Estimation techniques may be asisted by the addition of syntax senstive
counting to a size counting regime.  When analyzing a new problem, a
programmer can begin by breaking the problem into subunits.  The estimation
of these smaller units may be more accurate than estimation based on an
enitre project.  If the programmer has historical data on size for these
subunits, which presumably will correspond to syntactic units such as
classes and methods, then ...


Introduce LOCC LOCC is a size counting framework.  It does not attempt to
take a stand on the issue of personal vs.  organizational processes, nor
does it enforce a particular size counting paradigm.  Instead, LOCC
provides a framework for developing size counting modules which can be used
to automate size counting in any context.  LOCC also provides
implementations for size counting modules for counting code written in Java
and C++.

    \end{introduction}
 

