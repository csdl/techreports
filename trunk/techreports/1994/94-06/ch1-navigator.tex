%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Latex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ch1-navigator.tex -- 
%% Author          : Robert Brewer
%% Created On      : Thu Feb  3 10:16:21 1994
%% Last Modified By: Philip Johnson
%% Last Modified On: Sat Jun 25 08:47:11 1994
%% RCS: $Id: jmis.tex,v 1.5 94/02/18 11:13:31 johnson Exp $
%% Status          : Unknown
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Copyright (C) 1994 University of Hawaii
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%  

\chapter{The Egret Navigator}

\section{Overview}

The document is the research definition for a project to explore the
requirements, design, and evaluation of a 
collaborative, instrumented, hypertext system to support a group of
students in learning how to design and construct collaborative systems
using Egret.  This system is called the Annotated Egret Navigator, or AEN.
Since AEN will be constructed using Egret, the system itself should
illustrate to students why collaborative systems are useful, what their
capabilities are, and how to build one using Egret.

AEN is intended to serve as the primary knowledge resource for the
class as well as the primary mode of communication among the
participants.  To provide a sense for the scope of the course, an
outline of the AEN ``document'' nodes, which is also a syllabus for
the course, appears in Section \ref{sec:outline}.  The class will meet
both on-line and off-line for discussions about issues.  Most of the
interaction in the class is intended to occur through annotation of
the lecture material with new hypertext links to questions, comments,
and insights. Actual classroom meetings are intended to be a
supplementary forum to discuss things learned or questionned through
on-line activities.  Each student is expected (alone or in a group) to
design and implement a new collaborative system using Egret by the end
of the semester.

A primary motivation for the use of AEN is that it has the potential
to provide a superior educational experience for the students. The
next section discusses the capabilities enabled by the design of AEN:

\begin{itemize}
\item {\em Hypertext.} The use of a hypertext system for delivering
  instructional material on the design and implementation of collaborative
  systems has several advantages.  
  
  First, it facilitates incremental delivery of integrated
  materials.  Since this class has never been given before, many of
  the knowledge resources required for this class have not yet been
  fully identified.  It will be possible to create supplemental
  material in response to student needs during the semester, and
  forward/back link it to relevent sections of the document.
  
  Second, hypertext facilitates incremental revision of selected
  materials, with mechanisms to point students back to those parts
  of the document where changes have taken place.  This capability
  is enormously important, since the instructional materials will
  likely undergo substantial evolution over the course of the
  semester.
  
  Third, hypertext facilitates student feedback on the document,
  allowing them to raise questions or comments at those places in
  the text where the issue occurs.  Answers or further discussion on
  these comments are provided through further links, creating
  context-specific conversational threads.  Such information can be
  ultimately used to revise and improve the quality of the original
  material.
  
\item {\em Collaboration.} Learning enough about a complex new
  development framework to allow the creation of a new application
  is a significant problem.  This problem can be simplified by
  increasing the channels for interaction among the learners.
  
  AEN provides new channels for communication through a
  base document of reference materials that students can use as a
  springboard for questions and comments. Thus, the document
  forms a novel substrate for communication.  Its on-line nature means
  that communication can occur outside of normal classroom channels, and
  is not limited to same-place same-time styles of collaboration.  This
  kind of collaboration also means that the document itself can be
  improved quickly in response to issues raised by the students.
  
  Another new channel for collaboration will be provided by letting
  students browse (and perhaps ``grade'') each other's answers to quicky
  quiz questions.  
  
\item {\em Educatioanl Process and Data Modelling.} A substantial
  issue in this domain is that there is no clear understanding of the
  best order in which to deliver the instructional material.  It is
  also unclear as to the most appropriate way to structure this
  material and inter-relate it.  The AEN provides a means to explore
  both the process model and the data model required for this type of learning.
  
\item {\em Instrumentation.} Through instrumentating the use of the system,
  useful data can be captured to improve the group process and the overall
  quality of the document.  Some interesting basic measures are: whether or
  not a node has been read by a user; what order nodes are traversed in; how
  many times a node has been read by a user; how many questions are raised
  about a node, and how much time has been spent on a node. Though
  aggregation and combination of these measures, one can gain insight into
  the quality of organization of the document, the areas of the document that
  are of most use, and the areas of the document that require
  improvement.  Finally, instrumentation will provide empirical data
  of use in answering the research questions discussed below. 
  
  Instrumentation may also increase motivation: students know that
  their use of the system is being monitored and this might motivate
  them to devote more effort to it.
  
\item {\em Implementation.} As noted above, an important requirement for this
  system is that it serves as a model to the students for the power and
  potential of collaborative systems in general and those based upon Egret
  in particular.   

%% also note that agent-based or other computation over the hypertext
%% network  is an
%% important ingrediant for Egret-preferred applications.

\end{itemize}

There are several additional benefits to this system that are not of direct
benefit to the students. First, it provides an opportunity to exercise the
current implementation of Egret.  This system will be used by a dozen
students almost daily and will lead to the creation of thousands of nodes
and links.  It will be useful to see how well Egret fares under this kind
of usage. Second, it will result in an ``exportable'' version of Egret,
which will facilitate its (and CSRS's) dissemination and visibility.
Finally, it will produce data suitable for a nice journal article on
collaborative learning.

The next section provides an overview of the proposed contents of {\em The 
Annotated Egret}, which further clarifies the scope of this course and
thus the requirements for this system.

\section{Outline of the Annotated Egret}
\label{sec:outline}

One goal of this hypertext document is to introduce all of the
information necessary to constructing a collaborative system in Egret.
To fulfill this goal, the document must go beyond a simple description
of the facilities available in Egret by also describing the ``CSDL
way'': the method for system design, implementation, and documentation
that has evolved over the years in CSDL to support collaborative
system development.  Some knowledge of the CSDL way is essential
simply to understand the current system.  Beyond that, the CSDL way is
a framework for development that provides useful tool support and
results in systems that can be more easily understood, used, and
improved by others.

The current structure of {\em The Annotated Egret} includes the following chapters.
Each of them is summarized next, along with potential quicky quiz topics. 
(Yes, you can't even escape from quicky quizzes by going on-line...)

\begin{itemizenoindent}

\item {\bf Chapter 0: The Egret Navigator.} 

This initial chapter contains a user's guide to the hypertext system used
to present the document.  It will discuss concepts of navigation, query,
annotation, and instrumentation with as little reference to Egret concepts
as possible.  It is designed to be the first thing read by students when
they bring up the system, and should enable them to begin reading the
actual course contents and creating questions.

QQs will ask the students to read every node in this chapter, to create
at least one question about the document, and to respond to at least one
question raised by another student. 

\item {\bf Chapter 1: The CSDL Way: Requirements}

Not every problem domain requires a collaborative application, and not
every collaborative application is appropriately implemented using Egret.
The goal of the chapter is to present those properties of a problem domain
that make it well-suited to an Egret implementation, and, conversely, those
properties of Egret that make it well-suited to the implementation of
collaborative systems.  The previous section of this document which
motivated the design of the Egret Navigator in terms of hypertext,
collaboration, instrumentation, and implementation is an example of a
problem domain description which is well-suited to an Egret implementation.
This chapter should help students to focus their project ideas in areas for
which an Egret solution is both suited and advantageous.

QQs will ask the students to discuss which of several sample problem
domains in Appendix B appear well-suited to Egret applications, and if not,
why not.

\item {\bf Chapter 2: The CSDL Way: Research}

Not every project in this class needs to lead to publishable research, but
it is useful for the class members to get some understanding of what might
constitute a useful research project and how to plan one.  This chapter
provides an overview of CSDL research objective generation, which will be
adapted from \cite{csdl-ro-93-01}.

QQs will ask students questions about this research model, its scope, and
its limitations.

\item {\bf Chapter 3: The CSDL Way: Design.} 

This chapter will present an overview of how to design and implement
applications using the CSDL notion of object orientation.  It will describe
the hierarchical organization of CSDL systems into applications,
subsystems, classes, operations, and variables.  It will describe the
naming conventions for Emacs Lisp functions, and show how they are realized
in a simple class (such as the u*table class).  Finally, it will discuss
how to properly document systems at each level in the hierarchy.  This
material will be adapted from \cite{csdl-93-02}.

QQs will ask students to compare and constrast the CSDL view of object
orientation to other OO models, such as those embedded in C++ and CLOS.
QQs will also involve excerpts of code or class definitions, asking the
students to analyze them for design-level problems. 

\item {\bf Chapter 4: The CSDL Way: Implementation.}  

This chapter will overview the tools and method of system implementation
used in CSDL collaborative development.  Information about defsys, the
designbase, latex, RCS, the required directory structure, and so forth will
be provided. Information and examples on how to use these tools to do CSDL
design will be provided.  Material in this section will be adapted from the
dsb documents and man pages for relevent tools.

QQs will ask the students to generate and release very simple systems using
defsys and document them using DSB.

\item {\bf Chapter 5: The CSDL Way: Software Quality Assurance.}

This chapter will overview both testing and review-based techniques to
assure and improve the quality of the software.  It will include a user
guide to a simple CSRS-based method to support informal technical review of
designs and implementations.

QQs will ask students about software quality and have them critique a
simple system using CSRS. 

\item {\bf Chapter 6: HBS---The HyperBase Server.}

This chapter will present information on the Hyperbase Server system,
including its history, its design, and its current user-level
functionality.  Material for this section will be taken from published
documents on HBS.  In addition to design insights, this section will also
provide a tutorial on bringing up HBS server processes. 

QQs will ask the students to compare HBS to other database systems they
have used and test their abilities to bring up an HBS. 

\item {\bf Chapter 7: The ELC Kernel.}

This chapter presents information on the kernel facilities (i.e. the Utils
and Server subsystems) of the Emacs Lisp Client\foot{Formerly known as
``Egret'', but henceforth known as ``ECS''.} system.  This chapter will
overview the various classes, how they related to each other, and will
include hypertext links into the most recent version of the DSB.  Since
Egret will be evolving during the semester, these references must be
dynamically generated so that they correspond to the most recent release. 

QQs will ask the students to bring up a client system and devise simple 
programs to add and link nodes automatically. 

\item {\bf Chapter 8: The ELC Type System.}

This chapter presents the concepts and implementation of the Exploratory
Collaborative Type System implemented in Egret. Material for this chapter
will be adapted from the ECS DSB and \cite{csdl-93-09}.

QQs will ask the students to implement a simple typed data model and create
nodes with fields and field contents. 

\item {\bf Chapter 9: Basic ELC Interface Utilities.}

This chapter will document interface mechanisms such as the summary
buffer and node buffer classes provided in the generic interface subsystem of ECS.

QQs will ask students to extend their simple application developed in the
last chapter with these interface facilities.

\item {\bf Chapter 10: Measurement Utilities.}
  
  The chapter will present the concepts of measurement for collaborative
  systems, and the facilities for measurement and analysis provided in Egret.
  These facilities include the timestamp class, the timeplot system, 
  interfaces to spreadsheets, and  activitylog.
  
  QQs will ask students various measurement related questions and ask
  them to add measurement facilities to their last chapter with these
  interface facilities.

\item {\bf Chapter 11: The Egret Browser.}

This chapter will present information on using and customizing the generic
Egret browser.

QQs will ask students to bring up the browser and add browsing facilities
to their system.

\item {\bf Chapter 12: Application Case Study: The Egret Navigator.}

This chapter will conclude the document by introducing the design and 
implementation of the hypertext system used to present the document itself.

QQs will ask students to extend the Egret navigator with new facilities. 

\item {\bf Appendix A: Environment Setup.}

This chapter contains a guide to setting up Egret in a new user's
environment.  It will contain all of the necessary information about X
windows, Unix, Emacs, the dot files, as well as information on supplemental
facilities necessary to the CSDL way (such as RCS, LaTeX, etc.)  This
chapter is listed as an appendix because it is assumed that this
configuration will have already been accomplished by the time the user
brings up the system, since successfully bringing up the system means that
at least much of the environment has been set up successfully.

\item {\bf Appendix B: Sample Problem Domains.}

This chapter includes descriptions of several potential application
domains, such as: a shared Emacs application; a Web/Weave or literate
hypertext programming system for C++; a USENET reader; an Egret MUD; a
virtual bookstore; a C++ review guideline library; an Egret nameserver; and a
Mosaic interface to Egret. 

\item {\bf Appendix C: Sample Research Definition}

This chapter provides a sample research definition statement.  
Current candidates include either this document or Robert Brewer's 
URN research definition.

\end{itemizenoindent}


\section{Hypertext Network Structure}

An important usability goal of this system is to keep it as simple as
possible while still providing enough structure to support services.
For this reason, it appears that the following basic types of nodes
are sufficient for this system: Document, Figure, Comment,
QQ-question, and QQ-answer, with analogous links.

\paragraph {Document nodes.}

These are the basic holders of textbook information in this
system.  Document nodes can be embedded within other document nodes via an
includes link.  When a LaTeX document is generated from the system, the 
Chapter/section/subsection hierarchy is automatically inferred from the 
nesting of documents within other documents via includes links.

There is exactly one document node which contains the property called Top
with value t.  This flag is used to determine the ``root'' of the document
for linearization purposes.  Each of the chapters are linked in order to
this top level document.  (However, this top-level document node is usually
not seen by students.  Instead, the ``Table of Contents'' page, discussed
below, is used to represent the structure of the document.)

\paragraph {Figure nodes.}

Figure nodes are used to store and display graphical information.
Lucid Emacs is not extremely well-equipped to display graphical
information, so alternative graphical display mechanisms must be
provided.  One simple strategy is as follows.  First create the figure
in a Unix graphics package like Island Draw.  Then resize the window
to display only the graphic, then use xwd to dump a file containing
the image.  In Egret, ``traversing'' the link to the node containing
the xwd data will actually result in calling xwud to display the
contents, rather than formatting it into an Egret buffer.

Additional work is required to allow LaTeX document generation.
Basically, the postscript version of the figure will have to be dumped from
Island Draw and saved in a different Figure node, which is then included
into the LaTeX document. 

\paragraph {Comment nodes.}

Comment nodes contain all of the questions, comments, and responses
generated by reviewers.  Links to comments can be created in Document,
Comment, QQ-question, and QQ-answer nodes.

\paragraph {QQ-question nodes.}

QQ-question nodes will be interspersed throughout the document.  Some could
be annotated with ``Daily Double'' bells and so forth to add some
excitement when they are retrieved. Each of them poses a question to the
reader to be responded to by creating a QQ-answer node.  

\paragraph {QQ-answer nodes.}

These answers to QQ-questions will be saved in an encrypted format for
which only the instructor knows the de-encryption key.  (The key will be
loaded in a compiled object file whose source is protected.)  Once the
deadline for answering the QQ is past, the instructor will de-encrypt the
responses and allow students to read and comment on each other's responses.

\paragraph {Links.}

There is a very simple set of link types in the system. There are two links
used to associate document nodes to other document nodes: an ``Include''
link which is used to hierarchically nest document nodes, and an ``Xref''
link to associate document nodes.  Other than that, the ``See-Comment''
link associates any node type with a comment node, the ``See-QQ-Question''
associates any node type with a QQ-question node, and the ``See-QQ-Answer''
link associates a QQ-question node with its associated answer.

\section{Basic Process Characteristics}

The class will be organized as a sequence of reading assignments, where a
reading assignment consists of all the nodes (transitively) associated with
one or more chapters through any link except an Xref link.  In other words,
students are initially required to read all Document, Figure, Comment, and
QQ-question nodes associated with the first chapter, and to keep up with
the readings as students add new comments.  The reading assignment will
then be expanded to the first two chapters, and so forth.  

A mailer agent will be used to help students find out each day how much
reading they have to do (in terms of number of nodes and number of bytes of
text. It could even include the average time spent on these nodes thus far,
so that students can estimate how much time they'll need!)  In addition, a
summary buffer of unread nodes will be generated for them to directly
access new material once in the system. 

Process measurements of the following types should be collected:
\begin{itemize}
\item Total and average time spent on each individual Node and aggregated
  across each chapter;
\item Total and average time spent per day and per user and aggregated
  across days and users.
\item Total and average visits to each individual node and aggregated across
  each chapter.
\item Total and average visits per day and per user and aggregated across
  days and users.
\item Total and average comments generated per node and aggregated across
  each chapter.
\end{itemize}

These should be computed automatically and made available to students and
the instructor in periodic e-mail messages by an instrumentation agent
process. 


\section{AEN Research Hypotheses and Experimental Design}

One primary hypothesis to be investigated in this research is this: is
the AEN paradigm for collaborative learning effective?  Answering this
question requires a definition of the AEN paradigm for collaborative
learning: the data and process model used by the class in learning how
to construct collaborative systems.
Interestingly, the second primary hypothesis of this research is that
both the process of collaborative learning in this system, and the
organization of the knowledge is an emergent property of
collaboration.  This creates an experimental problem: how do we design
a test for our primary hypotheses which are incompletely specified
by definition?

The approach to be used is as follows.  We will collect three forms of
data during the class.  The first is standard Egret process and
outcome data. The second is performance data, which will be generated
by evaluation of quicky quiz answers and the final projects.  The
third is subjective data, which will be generated by questionnaires
administered to the students before, during, and after the course.






\section{Miscellaneous Design Issues}

This research definition concludes with a loosely organized list of 
design issues related to the processing, interface, and manipulation of 
the system.  It also reveals some new HBS operations.

\begin{itemizenoindent}
  
\item {\bf Field-level structure of nodes.} As currently envisionned, there is no need
  to internally structure the contents of Document nodes.  They can appear as
  simple free text, with hypertext links interspersed through the document.
  However, comment nodes could be split into ``description'' and
  ``followups'' fields, and QQ-questions could be split into ``Question'' and
  ``Answer'' fields.
  
\item {\bf Table of contents page.} It would be useful to dynamically
  generate a table of contents page, consisting of an indented list of the
  document node names that reflects their hierarchical structure.  Each line would
  be double-clickable and allow retrieval of that document node.  This
  might be the typical ``default'' screen to be generated and displayed
  whenever the user brings up the system.  For this page, a more standard
  CSRS-style link label would be appropriate.  It might be useful to use
  different colors or highlighting to indicate which nodes have been seen
  by the current user. 
  
\item {\bf Pop-up menus.} Right-mouse will pop-up a menu of all commands
  possible on the current node. If possible, this pop-up menu should be the
  only mechanism needed to invoke commands (besides link traversal through
  middle-double-clicking.)
  
\item {\bf Link creation is typically implicit.} In most cases, link
  creation is an implicit part of new node creation (i.e. a comment is
  always created with a new link to it anchored where the point is in the
  current document.)
  
\item {\bf Link anchor manipulation.} It should be possible to move the
  link anchor within the current node though a simple procedure of selecting
  the link anchor, moving the point to the new anchor location, and selecting
  the ``move selected link anchor'' command.

\item {\bf Links.}  Links can be placed anywhere in the document. It
  might be more user-friendly to implement them as simple glyphs, since
  the typical long CSRS link labels will probably be pretty disruptive
  in the middle of a paragraph.  We can look at CLARE to see how to do
  this.  It would be {\em really} nice if we emulated the xbiff mailbox
  icon idea of inverting the foreground and background colors to provide
  a visual indication of whether or not the node pointed to by this link
  has already been read by this user.
  
\item {\bf Locking.} As much as possible, students should not have to
  explicitly lock and unlock nodes. For example, all the document nodes are
  unlocked by default (i.e. read-only).  When a student creates a new issue
  node, the document node is automatically and briefly locked for the
  purposes of inserting the new link anchor, then unlocked.  The newly
  created issue node is locked automatically to allow entry of information,
  and then unlocked when removed.  

  If a student attempts to add a link to a node that is locked by another
  user, the system will attempt, say, 20 tries to lock it and then give up
  with a message to the user to try again later. 
  
\item {\bf Personal, Private, and Public nodes.} (This is a
  supplemental feature that is not a high priority for the system.) Users
  are provided with three flavors of privacy when creating comment nodes.
  A ``Personal'' comment is one that can only be read by its creator.  The
  link to a personal comment node does not even appear in other user's
  nodes.  A ``Private'' comment is one directed only to the author of the
  node where the link is created. The link anchor will be visible only to
  the author of the node that generated the comment, and to the author of
  the comment herself.
  
  This property of nodes can be switched at any time, and allows a user
  to begin creating a node ``privately'', thus not allowing any other user
  to see it.  When the node is ready for release, it can be changed to
  ``public'' and it will become visible to others.

\item {\bf Node with implicit link creation.}  To create, for example a
comment to a document node, the following sequence of five HBS operations are 
currently required:

\begin{enumerate}
\item Lock document node. (abort if failure after, say, 20 tries.)
\item Create comment node.
\item Create link from document node to comment node.
\item Insert link anchor in document node.
\item Write out document node.
\item Unlock document node.
\end{enumerate}

This sequence reveals an opportunity for optimization of this very frequent
operation sequence.  By creating a composite ``create link to new node''
HBS operation (that combines steps 2 and 3) and a composite HBS ``write and unlock
node'' (that combines steps 5 and 6), the number of HBS operations can be
reduced from 5 to 3, for a 40\% gain in efficiency.

\item {\bf Lock Events discouraged.} Because there will be a great deal of
  locking and unlocking going on in this system, it appears important to not
  subscribe to these events and to not maintain a locks gtable, because
  maintaining this information will introduce a substantial amount of event
  processing overhead.  The disadvantage of not maintaining lock events is
  that, in the absence of information, the system must always assume that a
  node is read-only (i.e. unlocked, or locked by another user) when
  retrieved.  This means that to edit a newly retrieved but previously
  created node, one must explicitly lock it even if the user already holds
  the lock.  This small and rare additional overhead seems a small price to
  pay for the overall reduction in overhead in not maintaining lock
  information locally.
  
\item {\bf Screen pool interface.} The relatively unstructured nature of
  user traversal of the network seems to call for a relatively loose style of
  screen layout.  My current idea is that of a dynamically resizable ``screen
  pool'': a circular FIFO queue of screens that are reused as the user
  traverses the network. For example, the default value of the screen pool
  might be 5.  This means that up to five screens can be displayed on the
  screen at once, and once all five screens are present, then the next node
  to be retrieved will overwrite the contents of the oldest node currently
  displayed. Users can reset this number of maximum concurrently displayed
  screens to a new value at any time.  (Given that this resizing will occur
  relatively infrequently, an easy implementation is simply an array of
  pointers to screens with an index variable and the use of MOD. When
  resizing, a new array is created and the old values copied to it.)
  
\item {\bf Quicky Quiz links.} Quicky quiz links are always created in
  ``private'' mode, so that only the author of the quicky quiz and the author
  of the quicky quiz answer can see them.  
  
  There are some ``hacking'' level issues to quicky quizzes that need to
  be thought about.  My feeling at this point is that if a student can
  figure out how to defeat the privacy mechanism for quicky quizzes, then
  they've learned something interesting about Egret.  In fact, I tend to
  think this should be made an explicit QQ exercise at some point in the
  semester.
  
\item {\bf User preferences for Screen Number/Size/Fonts.} In
  addition to setting the screen pool size, it would be nice (but not
  necessary) to allow the students to configure the size of the screens and
  the font size used to display them.  An easy way to do this would be a
  ``User Preferences'' menu item in the standard pop-up menu, with submenus
  for Screen Number, Screen Size, and Font Size.  Each of these would have
  their own submenus: the Screen Number submenu would list the integers from
  1-10, the Screen Size would list values indicating the percentage of the
  monitor to filled by each screen (100\%, 75\%, 50\%, 25\%), and the Font
  Size would list several point size options (6, 8, 10, 12, 14, 16).  The
  goal of this is to provide a basic level of user customization of the
  system interface with little implementation cost and without requiring
  extensive user training.
  
\item {\bf Linearization.} One research goal for this system is to learn
  about alternative forms of linearization for a hypertext document.  I would
  like to provide utilities to automatically generate LaTeX documents
  providing various ``perspectives'' on the information.  I'm not sure what
  these perspectives should be, but the following ideas occur to me: (a) a
  Reference Guide (document, figure, and QQ nodes only without any
  annotation), (b) a Teacher's Guide (document, figure, QQs, Model QQ
  answers, Instructor's private comments), (c) Class Log (document, figure,
  QQ, and comments in margin notes), (d) Individual Log (document, figure,
  QQ, and QQ answers and personal comments.)
  
\item {\bf Deletion.} When nodes and links are re-represented or combined
  with other information, or when a node is rewritten to satisfy a comment,
  the corresponding nodes and/or links might be deleted.  There are two kinds
  of deletions: (a) Delete link.  This occurs when, for example, an xref is
  deleted, or when a comment is being relinked to a different node.  (b)
  Delete node.  This occurs when the content of a node should be permanently
  removed from the system.

  Deletion should be very easy to accomplish. 
  
\item {\bf Versioning.} Since the document will be updated extensively
  throughout the semester in response to student input, the question arises
  as to the role of versioning.  In some ways, it would be nice to maintain
  old versions of the hypertext network, since that would allow comments to
  remain in context even after the problem they have identified has been
  fixed in the most current version of the document.
  
  However, support for versioning introduces excessive new complexity into
  the design and implementation of the system. For this reason, the hypertext
  document will be edited ``in-place'': there will be only the most recent
  version of the document in existance at any one time.  This introduces its
  1own complexity: what happens to a comment that was created to note a
  problem in a node which was subsequently edited in response to that
  comment?  For the time being, this will be dealt with manually by the users
  of the system: such comments must be occasionally ``garbage collected.''

  
\item {\bf Integration with DSB.} This document will refer to lots of
  functions contained in lots of CSDL applications.  It would be very helpful
  for students to be able to double click on the name of a function and
  bring up the most recent documentation on that function in a new screen
  (this screen would not allow the creation of comments on the function,
  however, it would be a strict form of ``read-only'' node.  The pop-up
  menu associated with this screen would only have the ``Delete Screen'' and
  a ``Quit Navigator'' commands within it.  

  To make this work, there needs to be a way to map from any function
  mentionned in the document to its corresponding DSB.  As long as
  subsystem prefixes are unique across all applications, this shouldn't be
  a problem: a simple table that maps subsystem prefixes to the directory
  containing the DSB should be good enough.  The command would then parse
  the DSB directly to extract the documentation. 
  
\item {\bf Performance measures.} Before beginning the class, it will be
  helpful to establish certain concrete educational performance goals for
  this system.  For example, students should be able to effectively learn how
  to build collaborative systems by interacting with this document; students
  should be able to easily find relevent and useful information; each
  participant should be able to provide ``helpful hints'' to each other, thus
  appropriating the instructional role.  The instructor should be able to
  efficiently and easily add new information and revise old information in
  response to student feedback, and he should be able to effectively manage
  and monitor student use of the system and their progress through the
  course.  These performance goals should be tied to explicit empirical
  measurements.
  
\item {\bf Keeping Track/Unread Nodes.} In such a dynamic, evolving state,
  it is very important to be able to keep track of: what is the current
  assigned reading; what has been updated since the last time you've looked
  at it; what new information has been added; whether or not there is
  anything new to look at today.  

  It will be extremely helpful to implement a mailer agent that sends out
  a daily ``Newspaper''  via e-mail to each class participant that notes
  any new information (and allows the instructor to supply a ``headline''
  or lead article. 

  In addition, there should be various summary buffers that display unread
  or updated nodes. 
  
\item {\bf Backup.} Corruption seems a certainty.  One way around this is
  to set some time in the middle of the night for a backup agent to wake up,
  check to see if all users are off the system or idle, and if so, to
  write out the databases to a backup file.   If we indeed have
  participation from the East Coast, finding such a time might be
  difficult. 

  
\item {\bf Buttons and Menus.} As much as possible, the interface should be
  simple and uniform.  One idea for this is to provide only buttons across
  the menubar, with a pop-up menu providing all additional functionality.
  The ``Button Bar'' on the top of an AEN window could resemble the button bar 
  on the bottom of Mosaic windows.  

  Some candidates for the button bar include:

  \begin{itemize}
    
  \item Next.  Move to the next node in the linearized version of the
    document.  (Not always defined.)
  \item Prev.  Move to the last node in the linearized version of the
    document.  (Not always defined.)
  \item Back.  Move to the last node before this one. 
  \item Home.  Move to the table of contents node. 
  \item Close. Delete this screen and window.
  \item Select.  Make this node the selected one, and add some sort of
    visual indication (a * to the button bar?)  This is useful for creating
    links between nodes, by first selecting a node, then moving the focus to
    another node and creating a link between it and the selected node.
  \item Comment.  Make a link at point and create a comment.

  \end{itemize}

  I'm not sure how to decide which operations go in the button bar and
  which operations go in the pop-up menu.  Presumably the most frequently
  used operations (particularly navigation ones) should go in the button
  bar, but there may be other criteria.

  It would also be extremely helpful to have a Mosaic-style history window
  that pops up and allows you to select one of your previously visited
  nodes.
  
\item {\bf Structure of nodes.} As noted previously, in addition to the
  explicit document links (which will form a tree-like hypertext structure)
  document nodes will also dynamically generate (or be manually set) with a
  Next and Previous property, containing a node-ID.  The set of Next and
  Previous properties simply provide a depth-first traversal of the hypertext
  document tree.

  Example: The tree structure
  \begin{verbatim}
  AEN
   Chapter 1
     Section 1.1
     Section 1.2
     Section 1.3
       Subsection 1.3.1
         Subsection 1.3.1.1
   Chapter 2
     Section 2.1
     Section 2.2
     Section 2.3
  \end{verbatim}
     
     Now, note that AEN will contain links to two chapters.  The
     Chapter 1 node will contain perhaps an introductory piece of text
     followed by three links.  Section 1.3 will contain text followed
     by a link to 1.3.1, and so forth in 1.3.1.1 Once you get down to
     1.3.1.1, the problem is that the ``next'' node that you want to
     read is Chapter 2, but that node requires backing up all the way to
     the AEN node before you see that link again.  By providing a Next and
     Previous property and corresponding buttons, you allow the user both
     the conceptual benefits of the tree-like layout, as well as the
     ease-of-use of a linear thread through the document. 
     
     On another note, I believe that it will be easier to provide a property on
     document nodes that explicitly indicates the section type (i.e. Chapter,
     section, subsection, etc.)  The screen-local variable
     screen-title-format can be set to a string to control the name that
     appears on your window.

\end{itemizenoindent}
