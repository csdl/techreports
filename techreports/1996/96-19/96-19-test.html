<html>
<HEAD>
<TITLE>PSP/Baseline SRS (14-Dec-1996)</TITLE>


</HEAD>
<BODY>
<center>
<H1>PSP/Baseline:<br> Software Requirements Specification</H1>
Philip Johnson<br>
Collaborative Software Development Laboratory <br>
Department of Information and Computer Sciences <br>
University of Hawaii <br>
ICS-TR-96-19<br>
http://www.ics.hawaii.edu/~csdl/techreports/96-19/96-19.html <br>

Last updated: Wed Jan  8 11:39:09 1997

<b>This version frozen for Requirements Review.</b>

</center>


122<p><blockquote><hr>
<H2>Introduction</H2>

<h3>Purpose</h3>

This software requirements specification document describes the
PSP/Baseline system.  The document is intended for use by CSDL developers
to help guide them in the design, implementation, and evaluation of the
system.

<h3>Scope</h3>

This document motivates the development of the PSP/Baseline
system by describing its expected contributions and benefits, 
specifies the functional aspects of the system, and provides
a high-level project plan. It does not attempt
to specify the exact user interface layout requirements,
which depend upon the JClass user interface toolkit.
It also does not specify performance or platform requirements,
because we expect that the use of the Java platform
will automatically provide sufficient performance and
portability. 
</blockquote>122<p><blockquote>

The scope of the requirements elicitation process involved direct
experience with manual PSP data gathering, extensive feedback on PSP by
students over two semesters, and input by CSDL members.


<h3>Overview/Motivation</h3>

The "lifecycle" of empirically-guided software process improvement 
can be viewed as follows:
<ol>
<li> <em>Collect</em> data on the process and products of development.
<li> <em>Analyze</em> this data in such a way that proposals for 
     potential process improvements result.
<li> <em>Implement</em> one or more of these proposals as changes to 
     the current process.
<li> <em>Evaluate</em> the changes over time by continued data collection.
     If the changes are indeed improvements, this should be reflected in 
     the process and/or product data.
</ol>
</blockquote>122<p><blockquote>
Strategies for implementing process improvement at the organizational level
exist, such as ISO 9000 or the Capability Maturity Model.  However, these
approaches typically require large organizational resources, such as
Software Process Improvement Groups, and top-level management support.  The
breadth and complexity of organizations means that such process improvements may
require years before adoption and demonstrable improvements result.
</blockquote>122<p><blockquote>

The Personal Software Process provides a strategy for implementing process
improvement at the individual level, rather than organizational level.  By
focussing on the individual, PSP eliminates the need for large
organizational resources and top-level management support.  PSP-based
process improvement can show results in months, rather than years.  PSP is
described in <em>A Discipline for Software Engineering</em> by Watts
Humphrey, which provides a phased introduction to PSP through a set of 10
programming assignments and seven different PSP processes. Humphrey shows
how PSP principles can be comprehensively applied to all facets of the
software engineering process. 
</blockquote>122<p><blockquote>

Despite the revolutionary nature of a personal approach to
empirically-guided software engineering, two semesters of experience
teaching and using PSP indicates that it suffers from three problems that
hinder (though do not necessarily prevent) its successful adoption and
long-term use:

</blockquote>122<p><blockquote>
<ol>
</blockquote>122<p><blockquote><li><em>PSP is manual.</em> The (psychological, as well as physical)
overhead of PSP process and product data collection is substantial.  For
many people trying the PSP, any potential positive improvements made
possible by PSP are overwhelmed by the negative overhead of data collection
and analysis.

</blockquote>122<p><blockquote><li><em>PSP is broad and comprehensive.</em> PSP processes are applied
to defect analysis, time analysis, quality assessment, task and schedule
planning, size estimation, time estimation, reuse, design, and testing.  While
each of these application areas are very legitimate 
and interesting uses of PSP, the
overall effect can be overwhelming for the novice PSP user. It can be
difficult for them to extract the "core PSP discipline" from the wealth of 
techniques and analyses presented, which hinders transfer from classroom
to professional use.   
</blockquote>122<p><blockquote>

In addition, this comprehensive application means that the PSP curriculum
tends to focus on Step 1 (collect data) and Step 2 (analyze data) of the
four step software process lifecycle. Furthermore, Step 2 analyses become
increasingly complex and time-consuming in later stages of the PSP
curriculum.
This can result in PSP users becoming "stuck" at Steps 1 and 2---collecting
and analyzing more and more process data, yet perceiving
little concrete "return on investment" from these efforts. 


</blockquote>122<p><blockquote><li><em>PSP processes are hard-wired.</em> To enable the PSP curriculum
to explore its numerous application areas effectively and efficiently,
Humphrey designed an incremental sequence of seven processes, each with
several accompanying data collection and analysis forms.  Due to the effort
involved in manual form and process design, and the potential for
undesirable and unanticipated impacts upon later PSP process applications,
Humphrey strongly discourages departures from the built-in PSP processes
during the course.  
</blockquote>122<p><blockquote>
Unfortunately, this tends to leave students with the sense of PSP as a 
monolithic and unchangeable set of seven processes which must be adopted
in their entirety or not at all.  In my experience, PSP students leave the course 
ill-equipped to "deconstruct" the hard-wired PSP processes and "reconstruct"
them appropriately within their professional environments. 
</ol>


One motivation for the PSP/Baseline system is to facilitate better
understanding and long-term adoption of the "core PSP discipline" by
overcoming these three problems in the following ways:

<ol>
</blockquote>122<p><blockquote><li><em>PSP/Baseline is fully automated.</em> It provides tool support
for process and product data collection, analysis, process improvement
proposals, and process improvement evaluation. The tools are designed with
reduction in user overhead as a primary requirement. 

</blockquote>122<p><blockquote><li><em>PSP/Baseline is narrowly applied.</em> Unlike PSP, the
PSP/Baseline system is currently focused on support for only two of the many
possible application areas: time and defect analysis.  However, it
supports and encourages users in carrying out the full process
improvement lifecycle for those two process areas.  This is intended 
to provide users with a better sense for the "core PSP discipline"
and will give them a better opportunity to experience a 
concrete return on their investment in process data collection and 
analysis.


</blockquote>122<p><blockquote><li><em>PSP/Baseline processes are easily customized by end-users.</em>
Because PSP/Baseline has a limited set of process improvement application
areas, it can support user customization more easily.  The PSP/Baseline
system allows users to customize the set of process phases, work product
types, defect type classifications, and checklist items associated with
projects, and implement both personal and group reviews. These capabilities
both facilitate adoption of PSP/Baseline within a professional environment
and increase user experience with PSP-style process deconstruction and
reconstruction.

</ol>

Satisfaction of these requirements can be evaluated in the 
following way:
<ul>
<li> Users will subjectively view the cost of process data collection as
minimal, and will adopt time and defect data collection into their
subsequent software development activities. 
<li> Users will experience all four steps in the process improvement
lifecycle, and will be able to describe a specific skill or capability
they have acquired through empirically-guided process improvement.
<li> Users will successfully implement a new process within 
PSP/Baseline (through definition of .prj and .phase files) and 
use it successfully outside of the original setting.
</ul>


<h3>Organizational Context/Motivation</h3>

CSDL is the organization sponsoring this development process
and the initial target user population. Since CSDL is also
the principle audience for this SRS, an organizational description
is unnecessary.
</blockquote>122<p><blockquote>
CSDL is motivated to develop the PSP/Baseline system to support its
research, education, and funding activities.
</blockquote>122<p><blockquote>

</blockquote>122<p><blockquote><b>Research:</b> 
<ul>
<li>The development and initial evaluation of PSP/Baseline will constitute
significant research contributions that will result in reports to be
submitted to journal and conference publications.  These reports will
include descriptions of the system, its evaluation, and also the (manual)
process used (CSDL/Baseline) and process data collected during its
development.

<li> The expected novel research contributions of PSP/Baseline include:
<ul>
<li> Automated support for the "core" PSP processes concerning time and
defect management.
<li> Automated support for "full lifecycle" personal process improvement.
<li> A design that minimizes measurement dysfunction.
<li> Integration of group-based formal technical review and 
     individual review within a common process and software architecture.
<li> Basic support for building repositories of checklists, defect types,
     and development process descriptions, as well as individual defect
    and time data repositories. 
</ul>
<li> These research directions and contributions will support the 
development of several future CSDL B.S., M.S., and Ph.D. theses.
</ul>


</blockquote>122<p><blockquote><b>Education:</b>
<ul>
<li> PSP/Baseline will provide software infrastructure for 
ICS 613, Spring 1998, which will teach PSP concepts.  It is
expected that PSP/Baseline will significantly improve the
educational outcome of a PSP curriculum. It is also possible
that a second, "distance education" section 
of ICS 613, Spring 1998 will be taught to a neighbor island, 
and PSP/Baseline will provide essential support for making
the process and product data from remote students easily available.
</ul>

</blockquote>122<p><blockquote><b>Funding:</b><br></blockquote>122<p><blockquote>
PSP/Baseline will provide a cornerstone for new funding opportunities:
<ul>
<li> Government (i.e. NSF, ARPA)  grant proposals to explore issues
     in empirically-guided individual process improvement in a 
     measurement dysfunction-free paradigm.
<li> Industry (i.e. Tektronix, Motorola, HP, DEC) grant proposals to
     perform technology transfer of PSP/Baseline and associated 
     customization/integration with their development environments.
<li> Educational proposals to explore extensions to PSP/Baseline
     that further support distance education of software engineering
     and personal process improvement.
</ul>
In addition, successful academic and industry experience with 
PSP/Baseline could potentially lead to commercial ventures, including:
<ul>
<li> Consulting services to industry on personal process improvement.
<li> A re-designed and re-implemented commercial version of PSP/Baseline.
</ul>



</blockquote>122<p><blockquote><hr>
<H2>General Description</H2>

<h3>System Functionality</h3>


As noted above, a primary system functionality is to provide support for
the complete "lifecycle" of empirically-guided software process improvement
with respect to time and defects. PSP/Baseline will enable users to:

<ol>
<li> <em>Collect</em> process data on time and defects easily.
<li> <em>Analyze</em> time and defect data and generate process
     change proposals. These process changes can include addition, 
deletion, or modification of:
     <ul>
     <li> Process phases.
     <li> Work products.
     <li> Planning, Design, Testing, Coding, or Review procedures.
     <li> Review application.
     <li> Review checklist items.
     </ul>
<li> <em>Implement</em> one or more of these proposals as changes to 
     the current process, and record each process change.
<li> <em>Evaluate</em> the effectiveness of process changes by 
      analysis of trends in defect and time process data. For example, 
      users should be able to measure reductions in the occurrence of 
      frequent or time-consuming defects as a result of determining which 
      defects occur frequently or require large amounts of time to remove,
      then implementing process changes to prevent or minimize their
      occurrence. 
</ol>

</blockquote>122<p><blockquote>

Although the PSP/Baseline system can support many different
processes, it will be initially deployed using a specific process
called CSDL/Baseline, which is documented at:
<A HREF="http://www.ics.hawaii.edu/~csdl/Primer/Baseline/">
http://www.ics.hawaii.edu/~csdl/Primer/Baseline/</a>.  
</blockquote>122<p><blockquote>
This process will also be used to develop the system, and is
the process used in the operational scenarios presented below.

<h3>Similar Systems</h3>

There are several reports of individuals and groups who have
developed basic tool support for PSP process analysis.
These tools are typically implemented as a spreadsheet, as an
add-on to Emacs, or as an MS Access database system.  
Unlike PSP/Baseline, none of them appear to be designed or
implemented with support for the full process improvement lifecycle.

</blockquote>122<p><blockquote>
There is a conceptual design for automated support for the 
PSP at <A HREF="http://www.sei.cmu.edu/technology/pspAuto/index.html">
http://www.sei.cmu.edu/technology/pspAuto/index.html</A>.  
This is a design, not an implementation, and focusses on direct
transcription of PSP processes.  As noted above, PSP/Baseline 
deliberately chooses not to support PSP completely in an attempt
to improve adoption and integration with professional environments.


</blockquote>122<p><blockquote>
Many workflow systems exist which implement software
development process support. To my
knowledge, none support personal software process improvement.

</blockquote>122<p><blockquote>

PSP/Baseline is expected to provide both a conceptual basis and code
libraries useful for other similar CSDL systems currently in the planning
stages. Brief details on these systems can be found in:
<A HREF="http://www.ics.hawaii.edu/~csdl/Primer/systems97.html">
http://www.ics.hawaii.edu/~csdl/Primer/systems97.html</a>.

<h3>User Characteristics</h3>

Initial use of the PSP/Baseline system will be limited to 
the CSDL environment and CSDL members.  Initial versions of 
the documentation will presuppose CSDL-level familiarity with
PSP, software engineering, and process improvement concepts. 
Initial versions of the code will assume the CSDL run-time 
environment. 
</blockquote>122<p><blockquote>

Later versions of the system will extend the documentation and 
package the tool in such a manner as to support external installation
and use. 

<h3>User Objectives</h3>

Prior sections of this SRS described high-level motivations and goals for
the system.  This section describes user-level requirements for the
PSP/Baseline system.

<ul>

</blockquote>122<p><blockquote><li> A primary user goal is a tool that substantially
reduces the overhead of manual, forms-based PSP data collection and
analysis.  Manual PSP methods feel, at least psychologically, like they
incur tremendous process overhead.  An ideal tool will make the
user feel as if process data collection, analysis, change, and 
evaluation incurs little overhead relative to its benefits. 
</blockquote>122<p><blockquote>
This implies that typical PSP/Baseline data <em>collection</em> "events"
should last no more than than one to two seconds and require less than
three or so user "gestures", such as mouse presses or menu selections.  The
speed with which typical process data collection events must be
accomplished means that typing must be minimized or eliminated whenever
possible. Events involving the remaining three steps of analysis, 
change, and evaluation occur far less frequently than data collection, 
and thus have less stringent constraints upon user interaction.

</blockquote>122<p><blockquote><li> Another important user objective is a tool that makes
<em>useful</em> development information available that is <em>not</em>
normally available. Thus, the system must not only succeed in reducing
process overhead, but it must also provide some sort of immediate process
benefits.  Ideally, the information should be useful both "instantaneously"
(i.e. after or within a single development project) and "continuously"
(i.e. as a trend over several projects).  Examples of such information
includes:

<ul>
</blockquote>122<p><blockquote><li> <b>Most frequently occurring defects.</b>

      <br> <em>Instantaneous benefit:</em> Directs the user toward
     prime opportunities for improvement in their current development techniques.
     <br> <em>Continuous benefit:</em> Shows the user if they are successfully
     practicing defect prevention (i.e. are certain defects that they used
     to make frequently no longer occurring?)

</blockquote>122<p><blockquote><li> <b>Time spent per phase.</b>
     <br> <em>Instantaneous benefit:</em> Shows the user the current
     costs of requirements, design, coding, testing, etc.
     <br> <em>Continuous benefit:</em> Helps the user determine: (a) how costs 
     are changing over time, (b) the relative costs of phases over different projects,
     (c) the range of costs per phase for all projects accomplished so far, and 
     (d) whether costs are shifting between phases over time.

</blockquote>122<p><blockquote><li> <b>Productivity.</b> 
     <br> <em>Instantaneous benefit:</em> Provides an easily computed, if somewhat marginally
     meaningful, measure of efficiency, as Finished LOC/hour. The problem
     with productivity is that it is a direct function of project complexity.
     <br> <em>Continuous benefit:</em> Provides a sense for the user's spectrum of 
     productivity values. The user's productivity is expected to vary over time,
     depending upon the complexity of the project.  It is irrational to
     expect or strive for a monotonically increasing value of productivity,
     since as one becomes more skilled, one tackles more complex projects. 
     Instead, continuous productivity measures provide valuable information
     on the range of productivity values experienced, which can help in
     future prediction and process improvement activities. 

</blockquote>122<p><blockquote><li> <b>Rework.</b> 

     <br> <em>Instantaneous benefit:</em> Provides a more meaningful measure of
     development efficiency. Although the conventional measure of
     productivity provided above is expected to vary dramatically depending
     upon project complexity, the proportion of time allocated to rework
     activities is expected to be less dependent upon project complexity
     and more dependent upon personal process quality. The CSDL/Baseline
     process definition at 
     <A HREF="http://www.ics.hawaii.edu/~csdl/Primer/Baseline/">
     http://www.ics.hawaii.edu/~csdl/Primer/Baseline/ </a>  describes
     one method for calculating Rework.

     <br> <em>Continuous benefit:</em> Since rework effort is less dependent upon
     project complexity, it is reasonable to strive to 
     decrease the proportion of time allocated to rework activities over
     time.  Thus, an "optimally" efficient project would not be one in
     which productivity rises to infinity, but rather one in which rework
     effort drops to zero. Note that zero levels of rework have been 
     documented for non-trivial software projects using the Cleanroom
     development process.

</blockquote>122<p><blockquote><li> <b>Interval time.</b>
     <br> <em>Instantaneous benefit:</em> Helps the user understand end-to-end development
     time, and direct/indirect hour rates. 
     <br> <em>Continuous benefit:</em> Shows the user how direct hours and
     end-to-end development times vary over projects. This can provide
     insight into process improvement opportunities to lower interval time
     and improve direct hour rates. 



   

</blockquote>122<p><blockquote><li> <b>DesignDiff.</b>

     <br> <em>Instantaneous benefit:</em> DesignDiff measures the structural
     difference between the conceptual design and the final implementation,
     and thus helps the user assess their design quality.  DesignDiff is
     calculated as a tuple (ClassDiff, MethodDiff), where ClassDiff is the
     difference in the total number of classes present in conceptual design
     and the final implementation, and MethodDiff is the difference in the
     total number of methods (aggregated over all classes) between the
     conceptual design and the final implementation.  While somewhat crude,
     DesignDiff is extremely easy to implement within the CSDL environment
     through the JavaDiff system and will provide a reasonable first-order
     approximation of design quality.

     <br> <em>Continuous benefit:</em> Shows the user if their design quality is
     improving or not. Optimal design quality (according to this coarse
     measure) occurs when the the conceptual design correctly predicts both
     the total number of classes and the total number of methods in the
     final system.  

</ul>


</blockquote>122<p><blockquote><li> Another primary user objective is software development process
support that results over time in some combination of:
<ol>
<li> Greater efficiency in development activities, as measured by 
reduction in rework
effort, for example.
<li> Higher quality of completed systems, as measured by 
reductions in the frequency and
severity of defects found, for example.
<li> Increased developer skills, allowing implementation of more complex
systems, as measured by the types of skills and systems successfully
completed, for example.
</ol>

Note that Goal 3 interacts with Goal 1 and Goal 2: the growing capability
of the user to tackle increasingly complicated system development projects
may lead to an observed <em>decline</em> in development efficiency or
quality, when compared to data on previous, less complicated projects.
However, such a decline does not indicate a failure in
process improvement, since the developer may now be capable of 
successfully completing a project that she would have failed to 
complete previously, even though her efficiency may drop to a 
low level on these more demanding projects.   


</blockquote>122<p><blockquote><li> The final goal is a tool that enables and encourages developers to
practice software development in such a way that a database of discrete,
comparable project "data points" results.  This also means that the tool
must help maintain standardization of process phases, document types, defect
types, and so forth among the projects developed by an individual
over time.

</ul>
</blockquote>122<p><blockquote><hr>
<H2>Operational Scenarios: Time Recording Log</H2>

The next several sections present operational scenarios for
each of the tools in the PSP/Baseline system. All scenarios
assume that the PSP/Baseline system is being used in conjunction
with the CSDL/Baseline software process, as defined at
<A HREF="http://www.ics.hawaii.edu/~csdl/Primer/Baseline/">
http://www.ics.hawaii.edu/~csdl/Primer/Baseline/ </a>.  
</blockquote>122<p><blockquote>

This first operational scenario section focusses on the use of the Time
Recording Log.

<h3>Starting a new project</h3>

Assume the CSDL member "Anne" is beginning the development of the first
major version of a Java software system called "Pali" using the
CSDL/Baseline process.

</blockquote>122<p><blockquote>

First, Anne creates a /group/csdl/java/pali directory, with 
subdirectories dev/, doc/, rel/, srs/, and psp/anne/.  The srs/
subdirectory will hold the software requirements specification,
while the psp subdirectory will hold the psp data files for all
people working on the project. Anne creates her personal 
subdirectory under psp/ to hold her files. She restricts
access to this subdirectory to herself alone, although all
other directories have broader access permissions. 
(For details on CSDL conventions for directory structures, see
<A HREF="http://www.ics.hawaii.edu/~csdl/Primer/Java/java-dirs.html">
http://www.ics.hawaii.edu/~csdl/Primer/Java/java-dirs.html </A>. )

</blockquote>122<p><blockquote>

Next, Anne invokes the PSP/Baseline TRL (Time Recording Log) tool
from the Unix command line using:
<pre>
% pali-trl
</pre>
</blockquote>122<p><blockquote>
Anne previously established "pali-trl" as an alias for the 
full invocation of the trl tool for the Pali project. Here's
what pali-trl is actually an alias for:
<pre>
% java csdl.java.pspbase.Trl /group/csdl/csdlbase/base.prj
                             /group/csdl/java/pali/psp/anne/anne.trl
</pre>
</blockquote>122<p><blockquote>
The TRL tool must always be invoked with two kinds of files:
(1) one or more (read-only) .prj files containing project information, 
and (2) a single (readable and writeable) .trl file containing
time log entries. 
</blockquote>122<p><blockquote>

Anne's personal style is to maintain a separate time recording log file for
each project she works on. Another member might decide to maintain a single
.trl file containing time data for all current projects, in which case they
might establish an alias called simply "trl", rather than "pali-trl".


<h3>Entering time data. </h3>

Upon invoking the "pali-trl" command, the TRL "active entry" window
appears. This one-line window contains entries for the Date, Project,
Phase, Start, Stop, Interrupt, Elapsed, Add, Log, and Quit.  A
simplified representation of this window in HTML format follows:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=14>TRL Active Entry
<tr><td>12/03/96
    <th>Project
    <th>Phase
    <th>Start<td>01:14
    <th>Stop<td>_____
    <th>Int<td>0:00
    <th>Elapsed<td>0:00
    <th>Add
    <th>Log
    <th>Quit
</table>
</center>
</blockquote>122<p><blockquote>

There are several things to note here. First, the tool tries to fill
in as much as it can automatically. It assumes the current date and 
time.
</blockquote>122<p><blockquote>

The TRL active entry window contains the following fields:
<ul>
<li> <b>Project</b> is a menu containing the projects defined in 
the .prj files provided as command-line arguments.
<li><b>Phase</b> is a menu that depends upon the current value
of the Project menu. Each time a project is selected, this
menu is rebuilt to reflect the set of phases defined in the 
.phase files associated with that project in one or more .prj files.
<li> <b>Start</b>, when pressed, sets the last entry 
start time to the current start time (24-hour format).
<li> <b>Stop</b>, when pressed,
sets the stop time to the current time (24-hour format) if no stop time has been
set. If a stop time has been set, pressing stop removes it from the display.
<li> <b>Int</b>, when
pressed, begins the Interruption timer, which begins displaying
interrupt time in real time.  During this time the "Start" and "Stop" buttons
get grayed out and their normal actions are disabled until the 
interrupt button is pressed again, indicating the end of the 
interruption.  
<li> <b>Elapsed</b> records in real time the current elapsed time from
start to stop (or to the current time if no stop time has been 
specified) minus the cumulative interrupt time.
<li> <b>Add</b> saves the current time log entry and resets
the display.  
<li> <b>Log</b> brings up a new window allowing the user to 
edit and delete old entries.
<li> <b>Quit</b> terminates execution.  If an entry is running,
it prompt the user and ask whether to "add" the entry to the .trl file before
terminating execution.

</ul>
</blockquote>122<p><blockquote>

Note that there is no "Save" button in the active entry window. Saving of
data to the .trl file is normally done automatically (every few minutes, if
needed) as well as when the user quits the application.  Saving the .trl
file can also be performed manually from the review window.

</blockquote>122<p><blockquote>

A couple of examples may make the time data calculation clearer. Here's 
a simple case where Anne has specified "Pali/1" as the project, 
"Reqs" as the phase, and presses the <b>Start</b> button.
She then fires up her editor, makes a copy
of the 
<A HREF="http://www.ics.hawaii.edu/~csdl/Primer/csdl-reqs-template.html">
CSDL SRS Template</A>, and starts work on the Pali SRS.
At 1:19am, after five minutes of work, the display would look
as follows:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=14>TRL Active Entry
<tr><td>12/03/96
    <td>Pali/1
    <td>Reqs
    <th>Start<td>01:14
    <th>Stop<td>_____
    <th>Int<td>0:00
    <th>Elapsed<td>0:05
    <th>Add
    <th>Log
    <th>Quit
</table>
</center>
</blockquote>122<p><blockquote>

Let's say she now gets a phone call.  She hits the <b>Int</b> button and
talks for three minutes. At the end of this time (1:22am), the display
would look similar to the following (note that the Start and Stop buttons
are grayed out):

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=14>TRL Active Entry
<tr><td>12/03/96
    <td>Pali/1
    <td>Reqs
    <td>Start<td>01:14
    <td>Stop<td>_____
    <th>Int<td>0:03
    <th>Elapsed<td>0:05
    <th>Add
    <th>Log
    <th>Quit
</table>
</center>
</blockquote>122<p><blockquote>


She ends the phone call, hits the <b>Int</b> button again, and works
for 30 more minutes. At 1:52am the display would look like this:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=14>TRL Active Entry
<tr><td>12/03/96
    <td>Pali/1
    <td>Reqs
    <th>Start<td>01:14
    <th>Stop<td>_____
    <th>Int<td>0:03
    <th>Elapsed<td>0:35
    <th>Add
    <th>Log
    <th>Quit
</table>
</center>
</blockquote>122<p><blockquote>

At this point, quite tired (it is, after all, almost two in the
morning), she hits <b>Stop</b>:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=14>TRL Active Entry
<tr><td>12/03/96
    <td>Pali/1
    <td>Reqs
    <th>Start<td>01:14
    <th>Stop<td> 01:52
    <th>Int<td>0:03
    <th>Elapsed<td>0:35
    <th>Add
    <th>Log
    <th>Quit
</table>
</center>
</blockquote>122<p><blockquote>

She now presses <b>Add</b> to enter this phase data into the
log, then <b>Quit</b>, leaves the editor, and
goes home to sleep.  (Note: had she pressed <b>Quit</b> without
first pressing <b>Add</b>, a dialog box would have been 
displayed asking her whether she wanted to commit the last 
entry before quitting.


<h3>Editing the current entry</h3>

Somewhat later in the day, Anne is interrupted by a phone call 
during the middle of her  work.  However, she forgets to 
press the <b>Interrupt</b> button while she is on the phone, 
so the time entry continues to accumulate time while 
she talks. After about fifteen minutes, she gets off the phone
and realizes that she has not informed the tool of the 
interruption.  To fix the time entry, she manually edits the 
Interrupt field and adds 15 minutes to its current value. 

</blockquote>122<p><blockquote>

Note that all of the other fields can also be hand-edited as
necessary to change their setting.   There is a dialog box
that pops up when clicking on a field that provides a GUI
interface to setting the time.  This prevents syntactically
incorrect data from being entered.


<h3>Entering inconsistent field data</h3>

When Anne first attempts to enter the Interrupt field value, she makes a
mistake. Instead of entering "0:15", which represents 15 minutes, she
enters "15:00", which represents 15 hours. This is an illegal value for
this entry, because the elapsed time in the absence of any interruptions is
less than 15 hours.  The tool pops up a window warning Anne of the
inconsistency. This window notes that "15:00" is an inconsistent value, and offers
Anne two buttons: "OK", which restores the contents of the Interrupt field
to its previous value, or "Override", which keeps "15:00" as the value of
the field even though this appears inconsistent.  
</blockquote>122<p><blockquote>
Anne presses "OK", retypes the entry as "0:15", and continues. 
</blockquote>122<p><blockquote>
Other fields check for internal inconsistencies, and allow the user to 
either repair or override the warning. 

<h3>Reviewing the TRL Log</h3>

At the end of the day, Anne decides to check her effort so far. 
She presses the <b>Log</b> button and a window similar
to the following appears:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=7>TRL Log
<tr><td colspan=7><center>/group/csdl/java/pali/psp/anne/anne.trl</center>
<tr><th>Date<th>Project<th>Phase<th>Start<th>Stop<th>Int<th>Elapsed
<tr><td>12/03/96<td>Pali/1<td>Reqs<td>16:30<td>17:00<td>0:00<td>0:30
<tr><td>12/03/96<td>Pali/1<td>Reqs<td><em>15:00</em><td>16:00<td>0:30<td>1:30
<tr><td>12/03/96<td>Pali/1<td>Reqs<td>11:14<td>15:14<td>0:00<td>4:00
<tr><td>12/03/96<td>Pali/1<td>Reqs<td>01:14<td>01:52<td>0:03<td>0:35
<tr><th colspan=7><hr>
<tr><th colspan=3>Data Inconsistencies:<td>1<th colspan=2>Recheck
<tr><th>Save<th>HTML<th>Quit
</table>
</center>
</blockquote>122<p><blockquote>

This window presents all of the time log entries in the file anne.trl in 
reverse chronological order (i.e. most recent entry at the top).
The entries are listed within a scrollable window.
</blockquote>122<p><blockquote>
The review window serves the following purposes:
<ol>
</blockquote>122<p><blockquote><li> Detecting Inconsistencies.  <br>
     The following inconsistencies are checked in the Log Window:
<ul>
<li> Stop Time prior to Start Time. (Note that although Start and Stop time
are listed as date-less 24 hour times, they are internally maintained as 
full dates. This allows, for example, a single time entry to "roll-over" at
midnight, or to even last longer than 24 hours without representational problems.)
<li> Interrupt time exceeding difference between Start and Stop Time.
<li> Overlapping entries. An overlapped entry is one which starts before
     the preceding entry ends.
</ul>
Inconsistent entries are highlighted. A counter of all inconsistencies
found is indicated so that the user does not have to scroll through
the entire log of entries to make sure than all inconsistencies have
been eliminated.


</blockquote>122<p><blockquote><li> Correcting old entries. <br> Each field in each entry can be
edited. In addition, entire entries to be deleted.  To add a new entry,
however, the active entry window must be used.

</blockquote>122<p><blockquote><li> Saving the current .trl file. <br>
     The user can save out the current set of entries, or use the review 
     window to load in a new .trl. file. 

</blockquote>122<p><blockquote><li> Printing out an HTML file containing the TRL entries.
</ol>

</blockquote>122<p><blockquote><hr>
<h2>Operational Scenarios: Customizing the Process</h2>

Once Anne completes the requirements document for the Pali project, she has
the idea of performing a user survey to test the market potential of the
Pali system and writing a report that summarizes the results. She
hypothesizes that the survey process might uncover important defects in the
current requirements specification that would not be uncovered by the
normal review process involving CSDL members, who are not representative of
the Pali/1 user population.

</blockquote>122<p><blockquote>
In order to evaluate the effectiveness of this idea, Anne needs to 
track both the time spent on the user survey and the defects uncovered
as a result.  Unfortunately, no user survey phase is
provided in the csdlbase/base.phase file associated with the Pali/1 project
in the csdlbase/base.prj file. Similarly, no survey results document type
is provided in the csdlbase/base.doctype file.

</blockquote>122<p><blockquote>
To make this clearer, here's the contents of the csdlbase/base.prj file:

<pre>
# base.prj--- Example projects using the CSDL/Base process.
Date/1	/group/csdl/csdlbase/base.phase	/group/csdl/csdlbase/base.doctype
Description/1	/group/csdl/csdlbase/base.phase	/group/csdl/csdlbase/base.doctyep
Pali/1	/group/csdl/csdlbase/base.phase	/group/csdl/csdlbase/base.doctype
</pre>

</blockquote>122<p><blockquote>
This .prj file associates the files base.phase and base.doctype with the Pali/1
project.  Here's what the csdlbase/base.phase file looks like:
<pre>
# base.phase
# Not necessarily a linear lifecycle, despite appearances.
Reqs
ReqsRev
Design
DesRev
TestPlan
TestRev
Code
CodeRev
Compile
Test
ReleaseDoc
ReleaseFix
</pre>

And here's what the csdlbase/base.doctype file looks like:
<pre>
# base.doctype
SRS
Java
Lisp
DesignDoc
TestPlanDoc
RelDoc
TestCode
</pre>

These files provide the "standard" CSDL/Baseline projects, phases, and
document types. Now, one way to make the user survey phase and document
type available to the Pali/1 project is to add them to the csdlbase/base.phase
and csdlbase/base.doctype files.  Then, the next time Anne invokes
"pali-trl", this phase and doctype would be available. They would also become
available to all other projects using these CSDL/Baseline process files, 
such as Date/1 and Description/1.
In many cases, this form of "global" process customization is exactly what
is desired.

</blockquote>122<p><blockquote>
However, at this point in time, user surveys have not been proven to be a
process improvement for the CSDL/Baseline process.  So, Anne and the rest
of CSDL agree that the standard CSDL/Baseline process files should not be
changed.  Instead, Anne will create a "local" customization of the
CSDL/Baseline process for her own personal development purposes that will
support user surveys. This customization involves creating a new .prj file,
a new .base file, and a new .doctype file that will be loaded in addition
to the CSDL/Baseline versions of these files. If the user survey process
extension proves to be a useful process improvement, it might later be
added "globally" to CSDL/Baseline.

</blockquote>122<p><blockquote>
Here's how Anne does the local customization. First, she creates a usersurvey.phase
file within her personal PSP directory for the Pali project that specifies
the name of this new phase:
<pre>
# usersurvey.phase---Extension to csdlbase/base.phase for Pali/1 project.
UserSurvey
</pre>

</blockquote>122<p><blockquote>
Second, Anne creates a usersurvey.doctype file within her personal PSP directory
for the Pali project that specifies the type of the 
document produced by the User Survey:
<pre>
# usersurvey.doctype---Extension to csdlbase/base.phase for Pali/1 project.
SurveyDoc
</pre>

</blockquote>122<p><blockquote>
Third, Anne creates a usersurvey.prj file in the same directory 
that ties the new .phase and .doctype files to the Pali/1 project:
<pre>
# usersurvey.prj--- Extension to csdlbase/base.prj for the Pali/1 project.
Pali/1	/group/csdl/java/pali/psp/anne/usersurvey.phase	/group/csdl/java/pali/psp/anne/usersurvey.doctype
</pre>
</blockquote>122<p><blockquote>

Finally, Anne edits the alias for her pali-trl command to load this
usersurvey.prj file in addition to the standard .prj file:
<pre>
% java csdl.java.pspbase.Trl /group/csdl/csdlbase/base.prj
                             /group/csdl/java/pali/psp/anne/usersurvey.prj
                             /group/csdl/java/pali/psp/anne/anne.trl
</pre>
</blockquote>122<p><blockquote>

Now, when Anne invokes pali-trl, the set of CSDL/Baseline phases for the
Pali/1 project will be augmented with the single phase "UserSurvey".  
In addition, the set of doctypes associated with the Pali/1 project
will be augmented with "SurveyDoc".   Note that no other users of
the CSDL/Baseline process will see these changes unless they load
Anne's extensions. 


</blockquote>122<p><blockquote>
There are two other process element files whose definition would further
extend this process customization.  First, a .deftype file could be defined
to provide the defect type classification associated with SurveyDoc
documents. Second, a .chkdef file could be defined to provide the
checklist items used when reviewing SurveyDoc documents. Anne decides not
to define either of these process elements, because this is her first
experience with User Surveys and she does not know what kinds of defect
types or checklist items to specify.  Also, she thinks it is better to
wait on these files until after the User Survey process change has
demonstrated enough potential to warrant the extra effort on process
definition.  In the interim, the PSP/Baseline system will function smoothly
despite the lack of .deftype and .chkdef files for the SurveyDoc
document type.

</blockquote>122<p><blockquote><hr>
<H2>Operational Scenarios: Process Change Log</H2>

The preceding scenario ended with Anne making a change to the set of phases
defined for the Pali/1 project. This process change should be explicitly
recorded in the Process Change Log (PCL), so that Anne can later assess
whether or not the change was an improvement, and so that later
analyses of process data can explicitly represent the existance of a
process change at this point in development.  PCL information also helps
make the data collected from two projects more comparable by providing
insight into how the processes used were similar or different.

</blockquote>122<p><blockquote>

The PCL tool is similar in function to the PSP PIP (Process Improvement
Proposal), but not identical.  First, the PCL uses "change" rather than
"improvement" to indicate that it is not always certain that the
manipulation of the process will have a positive impact.  To determine that
a change is actually an improvement, evaluation of the impact of the change
over the course of several projects should be performed.

</blockquote>122<p><blockquote>

Second, the PCL does not collect "proposals" for changes to the process,
but rather records only actual changes.

</blockquote>122<p><blockquote>

CSDL maintains a .pcl file to record changes to the CSDL/Baseline process
in /group/csdl/csdlbase/base.pcl.  However, as the addition of a user
survey was a process change to an individual project rather than
group-wide, Anne decides to record this change in her Pali/1 PSP directory.

</blockquote>122<p><blockquote>
To do this, Anne invokes pali-pcl from the command line, which she has aliased
to the following:
<pre>
% java csdl.java.pspbase.Pcl /group/csdl/csdlbase/base.doctype
                             /group/csdl/csdlbase/base.phase
                             /group/csdl/csdlbase/base-java.deftype
                             /group/csdl/csdlbase/base-srs.deftype
                             /group/csdl/csdlbase/base-srs.chkdef
                             /group/csdl/csdlbase/base.phase
                             /group/csdl/java/pali/psp/anne/anne.pcl
</pre>
</blockquote>122<p><blockquote>
The PCL tool takes a set of files containing the 
elements used to define the current process, as well as a
.pcl file which stores the process changes made.

</blockquote>122<p><blockquote>
This brings upon the following window:
</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=5>PCL Active Entry
<tr><th>Date<th>Affected Elements<th>Add<th>Log<th>Quit
<tr><th>Description<td colspan=4><pre>                                     </pre>
<tr><th>Intended Impact<td colspan=4><pre>                                 </pre>
</table>
</center>
</blockquote>122<p><blockquote>

Anne fills out an entry for this process change:
</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=5>PCL Active Entry
<tr><td>12/04/96<th>Affected Elements<th>Add<th>Log<th>Quit
<tr><th>Description<td colspan=4> 
<pre>Added UserSurvey phase.</pre>
<tr><th>Intended Impact<td colspan=4> 
<pre>Should yield requirements defects whose removal 
increases market for Pali/1 system.</pre>
</table>
</center>

</blockquote>122<p><blockquote>
Of course, this phase also has other consequences, such as an
increase in development time.  The purpose of the PCL is to
establish when such a change was instituted, and thus to allow
a comparison of data before the change with data collected
after the change.  The "Affected Elements" button brings up
a menu of all currently defined process elements. The user
can check one or more of these elements as an intended
target of the process change.  Process evaluation tools
will then list these process change entries when graphing
trends in the values of this process element. 



</blockquote>122<p><blockquote><hr>
<H2>Operational Scenarios: Defect Recording Log</H2>

The defect recording log (DRL) tool shares the following "look
and feel" characteristics with the TRL:
<ul>
<li> Command line arguments that specify process element and data files.
<li> A single line "active entry" window that supports new defect entry.
<li> A Log window that allows correction and deletion of prior entries. 
</ul>


<h3>Starting a new DRL</h3>

As Anne anticipated, the user survey phase quickly began to generate 
defects in her Pali/1 software requirements specification. Anne uses
the Defect Recording Log (DRL) tool to record these defects. She invokes
the DRL with:

<pre>
% pali-drl
</pre>
</blockquote>122<p><blockquote>
This is aliased to:
<pre>
% java csdl.java.pspbase.Drl /group/csdl/csdlbase/base.prj
                             /group/csdl/java/pali/psp/anne/usersurvey.prj
                             /group/csdl/csdlbase/base-srs.deftype
                             /group/csdl/java/pali/psp/anne/srs.deftype
                             /group/csdl/java/pali/psp/anne/anne.drl
</pre>
</blockquote>122<p><blockquote>
As with the time recording log tool, Anne provides the same two .prj files
that specify the Pali/1 project name, the standard  phases associated with
it (augmented with the UserSurvey phase), and the set of document types
produced (augmented with the UserSurvey document type). 
</blockquote>122<p><blockquote>
Anne also provides two .deftype files to the DRL tool.  These files specify
defect type categories in the standard PSP fashion.   The DRL 
allows incremental building of the defect classification list by combining
entries from multiple files.  This allows a standard set of "top-level"
defect types that are shared by the group to be specified in one file
(csdlbase/srs-base.deftype) while each individual extends this initial
classification with entries based upon their personal defect history
(anne/srs.deftype).  
</blockquote>122<p><blockquote>
To illustrate, here's the contents of the base-srs.deftype file:
<pre>
# base-srs.deftype
SRS
10	Syntax	Any syntax or grammatical error.
20	Intro	A semantic/structural error in the Intro section.
30	Scenarios	A semantic/structural error in the Scenarios section.
40	Func. Reqs	A semantic/structural error in the Func. Reqs. section.
50	Gen. Desc.	A semantic/structural error in the Gen. Desc. section.
60	Interface	A semantic/structural error in the Interface section.
70	Data	A semantic/structural error in the Persistant Data section.
80	Conc. Des.	A semantic/structural error in the Conc. Design section.
90	Schedule	A semantic/structural error in the Preliminary Schedule section.
</pre>
</blockquote>122<p><blockquote>

Anne's personal SRS .deftype file currently looks like this:

<pre>
# anne/srs.deftype
SRS
11	Run-On	A sentence that should be split into two or more sentences.
12	Parallelism	An error where multiple verb tenses do not agree.
</pre>

</blockquote>122<p><blockquote>

In addition to the .prj and .deftype files, Anne also specifies a .drl
file, where is where additional defect log entries for the Anne's work on
this project will be stored.
</blockquote>122<p><blockquote>

Upon invoking the DRL tool, its active entry window appears in its initial
configuration:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=11>DRL Active Entry
<tr><th>Project
    <th>DocType
    <th>Occur
    <th>ChkList
    <th>DefType
    <th>Inj
    <th>Rem
    <th>0:00
    <th>Add
    <th>Log
    <th>Quit
<tr><td rowspan=2 colspan=11><pre> 

</pre>
</table>
</center>
</blockquote>122<p><blockquote>

The DRL active entry window contains the following fields:
<ul>
</blockquote>122<p><blockquote><li><b>Project</b>. The Project menu allows selection of one of the
projects specified in the .prj files supplied as command line
arguments to the TRL tool.

</blockquote>122<p><blockquote><li><b>DocType</b>. The contents of the DocType menu depends upon the
current value of the Project menu. Each time a project is selected, this
menu is rebuilt to reflect the set of document types provided in the
.doctype files associated with this project.

</blockquote>122<p><blockquote><li><b>Occur</b>. This menu allows selection of an integer 
between 1 and 10 reflecting the number of occurrences of this 
defect within the document. If the defect occurred more than 
10 times, then multiple defect log entries will be required
to record all the occurrences. 

</blockquote>122<p><blockquote><li><b>ChkList</b>.  This menu allows selection of a 
checklist item name in the event that a checklist was used
to discover the defect being entered. The contents of 
the ChkList menu depends upon the current value of the
DocType menu. Each time a new DocType is selected, the
ChkList menu is rebuilt to reflect the Checklist items
stored in the .chkdef files associated with that document type.
</blockquote>122<p><blockquote>
This menu item is
normally used only during personal or group review. It's use
will be illustrated in an upcoming operational scenario. 

</blockquote>122<p><blockquote><li><b>DefType</b>. The contents of the DefType menu depends upon
the current value of the DocType menu.  Each time a DocType is 
selected, this menu is rebuilt to reflect the set of defect types
associated with this document type in the .deftype files provided.

</blockquote>122<p><blockquote><li><b>Inj</b>. This menu indicates the phase during which
this defect appeared to be injected into the work product.
The contents of the Inj menu depends upon the current value
of the Project menu. Each time a project is selected, this menu
is rebuilt to reflect the set of phases associated with that
project in one or more .phase files.

</blockquote>122<p><blockquote><li><b>Rem</b>. This menu indicates the phase during which this defect
was removed from the work product, which is typically the current phase.
The contents of the Rem menu depends upon the current value of the Project
menu. Each time a project is selected, this menu is rebuilt to reflect the
set of phases associated with that project in one or more .phase files.

</blockquote>122<p><blockquote><li><b>Fix</b>. This field specifies the length of time
it took to fix the defect.  It can operate either in "stopwatch" mode
or the user can enter the time manually.

</blockquote>122<p><blockquote><li><b>Add/Log/Quit</b>.  These fields have the same
meaning as in the TRL.

</blockquote>122<p><blockquote><li><b>Comment</b>. This scrollable two line window allows
entry of a multi-line comment describing the defect. 
</ul>

<h3>Recording a defect</h3>

The first error found in the SRS by the user survey was the failure to
include an operational scenario describing Internet-based access to the
Pali/1 system.  Anne fixes this error by writing the new section, and
records the defect this way:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=11>DRL Active Entry
<tr><td>Pali/1
    <td>SRS
    <td>1
    <th>ChkList
    <td>30: Scenarios
    <td>Reqs
    <td>UserSurvey
    <td>0:30
    <th>Add
    <th>Log
    <th>Quit
<tr><td rowspan=2 colspan=11><pre>Missing scenario on Internet-based access.

</pre>
</table>
</center>
</blockquote>122<p><blockquote>

</blockquote>122<p><blockquote>
Once Anne finishes fixing this defect, she presses "Add". This
records the defect and resets the active entry window to look
like this:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=11>DRL Active Entry
<tr><td>Pali/1
    <td>SRS
    <td>1
    <th>ChkList
    <th>DefType
    <th>Inj
    <td>UserSurvey
    <td>0:00
    <th>Add
    <th>Log
    <th>Quit
<tr><td rowspan=2 colspan=11><pre>

</pre>
</table>
</center>
</blockquote>122<p><blockquote>

Note that the Project, Doctype, and Rem fields retain
their value from the last recorded defect.

<h3>Reviewing the defect list</h3>

After recording and removing the defects discovered by the survey
participants, Anne decides to review them. She presses the Log button in
the DRL Active Entry window and the following window appears. This DRL Log
provides a scrolling window displaying five defect entries at a time, where
each entry includes a scrolling window showing the first line of the
comment associated with the defect, if any.

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=9>DRL Log
<tr><td colspan=9><center>/group/csdl/java/pali/psp/anne/anne.drl</center>
<tr><th>Date<th>Project<th>DocType<th>Occur<th>ChkList<th>DefType<th>Inj<th>Rem<th>Fix
<tr><td>12/10/96<td>Pali/1<td>SRS<td>1<td><td>30: Scenarios<td>Reqs<td>UserSurvey<td>0:30
<tr><th><td colspan=8><pre>Missing scenario on Internet-based access.</pre>

<tr><td>12/10/96<td>Pali/1<td>SRS<td>9<td><td>10: Syntax<td>Reqs<td>UserSurvey<td>0:05
<tr><th><td colspan=8><pre>Passive voice</pre>

<tr><td>12/10/96<td>Pali/1<td>SRS<td>4<td><td>11: Run-On<td>Reqs<td>UserSurvey<td>0:05
<tr><th><td colspan=8><pre>   </pre>

<tr><td>12/10/96<td>Pali/1<td>SRS<td>1<td><td>90: Schedule<td>Reqs<td>UserSurvey<td>0:05
<tr><th><td colspan=8><pre>Missing time for User Survey!</pre>

<tr><td>12/10/96<td>Pali/1<td>SRS<td>2<td><td>30: Scenarios<td>Reqs<td>UserSurvey<td>0:50
<tr><th><td colspan=8><pre>Missing scenario on external tool interoperability.</pre>

<tr><th colspan=9><hr>
<tr><th>Save<th>HTML<th>Quit
</table>
</center>
</blockquote>122<p><blockquote>

In this case, the UserSurvey yielded only five entries, so they all fit
within this DRL window. These five entries record a total of 17 defect
occurrences, however.  Although most users surveyed seemed to concentrate
on major errors, one guy was a real English professor wannabe and caught
Anne on grammar issues.

</blockquote>122<p><blockquote>
As with the TRL Log window, the DRL Log window
allows each entry field to be edited and entire entries to be deleted,
if the user realizes an error has been made in the DRL.

<h3>Adding a new defect type</h3>

Upon reviewing the DRL, Anne reluctantly decides that passive voice may
well be a nontrivial problem with her writing, and that she should 
begin keeping more careful records of this problem.  As a first step,
she decides to make "Passive Voice" into a defect type so that 
occurrences of this error will not be lumped together with all 
generic "10: Syntax" errors. 

</blockquote>122<p><blockquote>
To do this, Anne finds her personal SRS .deftype file and updates it
to the following:

<pre>
# anne/srs.deftype
SRS
11	Run-On	A sentence that should be split into two or more sentences.
12	Parallelism	An error where multiple verb tenses do not agree.
13	Pass. Voice	Passive voice verb construction.
</pre>

</blockquote>122<p><blockquote>
After saving this file, she reinvokes the pali-drl tool so that this
change will be seen within the DefType menu.
Finally, she manually edits the Passive Voice entry
in the DRL Log to use the new defect type number. The resulting
DRL Log looks like this:


</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=9>DRL Log
<tr><td colspan=9><center>/group/csdl/java/pali/psp/anne/anne.drl</center>
<tr><th>Date<th>Project<th>DocType<th>Occur<th>ChkList<th>DefType<th>Inj<th>Rem<th>Fix
<tr><td>12/10/96<td>Pali/1<td>SRS<td>1<td><td>30: Scenarios<td>Reqs<td>UserSurvey<td>0:30
<tr><th><td colspan=8><pre>Missing scenario on Internet-based access.</pre>

<tr><td>12/10/96<td>Pali/1<td>SRS<td>9<td><td>13: Pass. Voice<td>Reqs<td>UserSurvey<td>0:05
<tr><th><td colspan=8><pre> </pre>

<tr><td>12/10/96<td>Pali/1<td>SRS<td>2<td><td>11: Run-On<td>Reqs<td>UserSurvey<td>0:05
<tr><th><td colspan=8><pre>   </pre>

<tr><td>12/10/96<td>Pali/1<td>SRS<td>1<td><td>90: Schedule<td>Reqs<td>UserSurvey<td>0:05
<tr><th><td colspan=8><pre>Missing time for User Survey!</pre>

<tr><td>12/10/96<td>Pali/1<td>SRS<td>2<td><td>30: Scenarios<td>Reqs<td>UserSurvey<td>0:50
<tr><th><td colspan=8><pre>Missing scenario on external tool interoperability.</pre>

<tr><th colspan=9><hr>
<tr><th>Save<th>HTML<th>Quit
</table>
</center>
</blockquote>122<p><blockquote>


</blockquote>122<p><blockquote><hr>
<H2>Operational Scenarios: Personal Review</H2>

Following the completion of the SRS document, but before starting the User
Survey phase, Anne performed reviews of the SRS. Thus, the operational
scenario described in this section and the next section actually occurred
<em>before</em> the User Survey phase whose defect recording was described
above. Anne decided to review of the SRS before doing the User Survey in
order to test whether a User Survey will find errors not uncovered through
review.

</blockquote>122<p><blockquote>

The reason this scenario is not located prior to the DRL scenarios is
because the PSP/Baseline review tool is implemented as a combination of the
DRL tool along with additional features for checklist display and data
collection.  By presenting the Review tool after presentation of the DRL
tool, presentation of both the DRL tool and the Review tool is
simplified. This ordering issue does not otherwise affect the operational
scenarios for the DRL and Review tools.

</blockquote>122<p><blockquote>
To perform a personal review, Anne invokes the PSP/Baseline review tool as follows:
<pre>
% pali-review
</pre>
which is aliased to:
<pre>
% java csdl.java.pspbase.Rev /group/csdl/csdlbase/base.prj
                             /group/csdl/java/pali/psp/anne/usersurvey.prj
                             /group/csdl/csdlbase/base-srs.deftype
                             /group/csdl/java/pali/psp/anne/srs.deftype
                             /group/csdl/java/pali/psp/anne/anne.drl
                             /group/csdl/csdlbase/base.chkdef
                             /group/csdl/java/pali/psp/anne/srs.chkdata
</pre>
</blockquote>122<p><blockquote>

The PSP/Baseline Review tool is invoked with the same files as the DRL
tool, plus two additional file types. In this case, the first five file
arguments to the Review tool duplicate the entire set of file
arguments Anne provides to her DRL tool. These five files mean the same
thing and are used in the same way as they were in the DRL operational
scenario. In addition to these five files, the
Review tool also accepts two additional file types: a .chkdef file and a
.chkdata file.  
</blockquote>122<p><blockquote>
The .chkdef file contains definitions of checklist items for use during
review.  For example, here's the csdlbase/base.chkdef file 
passed by Anne to the tool:
</blockquote>122<p><blockquote>
<pre>
# base-srs.chkdef
SRS

10	Object Consist.	Identify all data objects in the overview:
\n 1. Are all objects mentioned described in at least one scenario?
\n 2. Is each object's specification consistent with its description?
\n 3. If an object represents a physical quantity, are its units specified?
\n 4. If an object's value is computed, can the computation generate an 
illegal value?

20	I/O objects	Identify all I/O objects in the func. reqs:
\n 1. Are all values written consistent with their function?
\n 2. Identify at least one function that uses each output object.

30	System Events	Identify all system events in the func. reqs:
\n 1. Is there a sequence of events that allows the system to enter 
an illegal state?
\n 2. Is there a sequence of events that allows the system to enter
a state but never leave (i.e. deadlock)?

40	Weasel Words	Do any of the following words occur:
\n  various mostly suitable integrate maybe consistent user-friendly robust
superb modular good

50	Traceable	Identify all external references to "standards", etc.
\n 1. Is a citation for each external reference provided?
\n 2. Indicate any reasonable alternative/superior standards/sources.

60	Customer Needs	Pretend you are the customer for this SRS.
\n 1. For each requirement, ask yourself, "Do I care about this?"
\n 2. Are there any requirements you care about that are not discussed?

70	TBD's	Are there any implicit or explicit "to be determined's".
</pre>

</blockquote>122<p><blockquote> 
The anne.chkdata file is used to store process data on the checklist items
used during review. It records which checklist items were used on what
date. In combination with the .drl file, this information allows analysis
tools to monitor the effectiveness and usage of checklist items. 

</blockquote>122<p><blockquote>
After Anne executes the pali-review command, the 
Review Active Entry window appears in its initial configuration:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=11>Review Active Entry
<tr><th colspan=8>Checklist Name<th>Check<th>Log<th>
<tr><th colspan=11><pre>  
<pre>

<tr><th>Project
    <th>DocType
    <th>Occur
    <th>ChkList
    <th>DefType
    <th>Inj
    <th>Rem
    <th>0:00
    <th>Add
    <th>Log
    <th>Quit
<tr><td rowspan=2 colspan=11><pre> 

</pre>
</table>
</center>
</blockquote>122<p><blockquote>

As should be evident, the Review Active Entry tool looks just like 
the DRL active entry tool, with the addition of some initial fields:
<ul>
<li> <b>Checklist Name</b> is a menu whose contents depend upon the 
value of the DocType field. Each time a DocType is selected, the 
Checklist Name menu is rebuilt with the set of checklist items 
associated with that DocType.
<li><b>Check</b> is a button used to indicate that the current selected
checklist item is actually been used to support review during this 
invocation of the Review tool. Whenever a checklist item is 
being displayed, it takes on one of two values, "Used" and "Unused".
Pressing it toggles back and forth between these two values. 
<li><b>Log</b> is a button that brings up the Checklist Review window.
<li><b>Checklist Procedure</b> is a multi-line, full width field that 
displays the procedure associated with the Checklist Name. (It is 
currently empty.)
</ul>

Anne performs the personal review in the following way. First, she
uses her TRL tool (not shown) to record the start of the "ReqsRev"
phase. Next, she specifies the "Project" and "DocType" fields as 
"Pali/1" and "SRS".  Once the DocType has been specified, the 
"Checklist Name" menu is rebuilt with the set of checklist items
available for documents of type "SRS". (These checklist items were
supplied to the tool in the csdlbase/base-srs.chkdef file.) 
Finally, she pulls down the "Checklist Name" menu and selects the 
first item shown, "10: Object Consist.".  The results of these
actions on the Review Active Entry window follow:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=11>Review Active Entry
<tr><td colspan=8>10: Object Consist.<td>Unused<th>Log<th>
<tr><td colspan=11><pre>Identify all data objects in the overview:
 1. Are all objects mentioned described in at least one scenario?
 2. Is each object's specification consistent with its description?
 3. If an object represents a physical quantity, are its units specified?
 4. If an object's value is computed, can the computation generate an 
illegal value?
<pre>

<tr><td>Pali/1
    <td>SRS
    <th>Occur
    <td>10: Object Consist.
    <th>DefType
    <th>Inj
    <th>Rem
    <th>0:00
    <th>Add
    <th>Log
    <th>Quit
<tr><td rowspan=2 colspan=11><pre> 

</pre>
</table>
</center>
</blockquote>122<p><blockquote>

After reading the procedure, she decides to use this checklist item and
presses the check button, which is currently displaying "Unused".  It
changes to display "Used".
</blockquote>122<p><blockquote>
After a few minutes of work on this checklist item, Anne discovers a defect
in the SRS--a "Distance" object is referred to in the specification but 
its units are never specified. After spending 10 minutes to fix the defect,
the entry appears as follows:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=11>Review Active Entry
<tr><td colspan=8>10: Object Consist.<td>Used<th>Log<th>
<tr><td colspan=11><pre>Identify all data objects in the overview:
 1. Are all objects mentioned described in at least one scenario?
 2. Is each object's specification consistent with its description?
 3. If an object represents a physical quantity, are its units specified?
 4. If an object's value is computed, can the computation generate an 
illegal value?<pre>

<tr><td>Pali/1
    <td>SRS
    <td>1
    <td>10: Object Consist.
    <td>70: Data
    <td>Reqs
    <td>ReqsRev
    <td>0:10
    <th>Add
    <th>Log
    <th>Quit
<tr><td rowspan=2 colspan=11><pre>Distance measure not specified.

</pre>
</table>
</center>
</blockquote>122<p><blockquote>

Anne adds this defect to her .drl file (using the <b>Add</b> button). She then 
uses the <b>Checklist Name</b> menu to select the next checklist item for
review. She works through the entire checklist in this manner: reading each
procedure, pressing the <b>Check</b> button if she decides to follow the 
checklist item's procedure to look for defects, and recording the defects
she finds (if any) as a DRL entry. 
</blockquote>122<p><blockquote>
After working through the checklist, Anne decides to take one final pass
through the document. On this pass, which is not associated with any 
checklist procedure, she finds yet another defect and fixes it. She
records this defect in the DRL but clears the <b>ChkList</b> menu item 
so that the defect is specified as having been found during the ReqsRev
phase but without use of a checklist item.
</blockquote>122<p><blockquote>
At the conclusion of review, Anne decides to check the Review Log window
to make sure she has not forgotten to specify all checklist items that
she used. She presses the <b>Log</b> button found on the Checklist line
and the following window is displayed:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=5>Review Log
<tr><td colspan=5><center>/group/csdl/java/pali/psp/anne/anne.chkdata</center>
<tr><th>Date<th>Project<th>DocType<th>CheckList Name<th>Status
<tr><td>12/05/96<td>Pali/1<td>SRS<td>10: Object Consist.<td>Used
<tr><td>12/05/96<td>Pali/1<td>SRS<td>20: I/O objects<td>UnUsed
<tr><td>12/05/96<td>Pali/1<td>SRS<td>30: System Events<td>UnUsed
<tr><td>12/05/96<td>Pali/1<td>SRS<td>40: Weasel Words<td>Used
<tr><td>12/05/96<td>Pali/1<td>SRS<td>50: Traceable<td>Used
<tr><td>12/05/96<td>Pali/1<td>SRS<td>60: Customer Needs<td>Used
<tr><td>12/05/96<td>Pali/1<td>SRS<td>70: TBD's<td>Unused
<tr><th colspan=5><hr>
<tr><th>Save<th>HTML<th>Quit
</table>
</center>
</blockquote>122<p><blockquote>

This window allows Anne to check how the status of each checklist item 
in the base.chkdef file will be written out to the .chkdata
file.  The Status field can take three values: 
<ul>
<li> Used: Indicates that the checklist item was used to search for
defects, regardless of whether any defects were actually uncovered or not. 
<li> Unused: Indicates that the user considered using this checklist item
but decided against it. 
<li> UnConsidered: Indicates that the user never even considered if this
checklist item should be used. This value may see usage when checklists
grow large. 
</ul>

</blockquote>122<p><blockquote>

After finishing checking the Review Log, Anne goes back to the Review Active
Entry window and presses the "Log" button on the DRL entry panel to 
bring up the DRL Log.  She checks these entries to ensure that all defects
associated with this review were recorded correctly.  Finally, she
exits the Review tool, presses <b>Stop</b> on the TRL tool to indicate
the end of work on this Requirements Review, and exits that tool as well. 



</blockquote>122<p><blockquote><hr>
<H2>Operational Scenarios: "Two-Person" Reviews</H2>

The PSP/Baseline tools support "two person" as well as personal
reviews.  A "two person" review is a review in which a person
other than the author reviews the document using the 
PSP/Baseline review tools and files.

</blockquote>122<p><blockquote>
For example, after Anne finishes her personal review, she decides
to ask Philip to do a two person review of her SRS document. 
She supplies Philip with pointers to:
<ul>
<li> The SRS document.
<li> The csdlbase/base.prj file containing the Pali/1 project entry.
<li> The csdlbase/base-srs.deftype and a copy of the anne.deftype
files to be used as the defect type classification.
<li> The csdlbase/base-srs.chkdef file to be used to guide the review.
</ul>
</blockquote>122<p><blockquote>

After receiving the file pointers, Philip invokes the Review and TRL tools
with them.  He performs a checklist-guided review as illustrated in the
last scenario, building a review.trl file holding time process data, a
review.drl file containing defect entries, and a review.chkdata file
containing review process data. As Philip discovers defects in 
Anne's SRS document, he makes a defect log entry but does not
attempt to fix the defect. When Philip finishes, he sends pointers
to these files back to Anne.

</blockquote>122<p><blockquote>
Anne makes copies of these files in her pali/psp/anne directory.  She then
invokes the DRL tool, replacing the reference to anne.drl by review.drl,
and brings up the DRL Log window.  This presents Anne with a list of all
the defects Philip found during review, and the checklist item (if any) he
used to discover them.  Anne then either deletes the entry (if she decides
it is not a defect), or edits fields (such as the defect type, if Philip
did not classify it in the way Anne would), and finally removes the
remaining defects from the SRS document. She then updates the Fix Time
value with the time required to remove the defect.

</blockquote>122<p><blockquote>
Anne uses the review.chkdata file as additional data on the 
effectiveness of the csdlbase/base-srs.chkdef checklist items
for the Pali/1 project. Finally, she uses the review.trl file
when generating reports on the aggregate time spent by the 
entire group on the Pali/1 project. 

</blockquote>122<p><blockquote>
In keeping with the requirement to minimize measurement dysfunction
pressure, nothing in the files provided by Philip connect him to 
this process and product data. Actually, for the purposes of supporting
Anne's defect classification and prevention efforts, it does not
matter who was the discoverer of defects in Anne's work products.
In fact, Anne may decide to either keep the review.drl file separate from
the anne.drl file, or merge the contents of the 
two files together.  Since all analysis tools allow multiple 
instances of the same file types to be provided, either approach
is supported.

</blockquote>122<p><blockquote><hr>
<H2>Operational Scenarios: "Multi-Way Two-Person" Reviews</H2>

The two-person review process can be straightforwardly extended
into a "multi-way two-person" review by incorporating more 
reviewers.

</blockquote>122<p><blockquote>
For example, after receiving Philip's review and removing the 
defects he found from the SRS, Anne decides to ask Cam, Jennifer,
and Russ to review her SRS in a multi-way two-person review. 
She carries out this review quite similarly to the two-person
review, providing the same file pointers to each of the three
reviewers. However, in this case Anne decides to focus the 
efforts of the three reviewers in slightly different ways. 
Anne accomplishes this by telling Cam to focus on checklist
items 30, 40, and 50, Jennifer to focus on checklist items
40, 50, and 60, and Russ to focus on 50, 60,and 70. Anne
felt that Philip did a good job on items 10 and 20 and the 
results would not justify the efforts by other reviewers
on those items. 

</blockquote>122<p><blockquote>
Just as Philip did previously, Jennifer, Cam, and Russ carry
out their reviews and provide pointers to the process data
files they produced back to Anne. Anne makes copies of these
files in her psp/anne directory. 

</blockquote>122<p><blockquote>
It is interesting to note that this PSP/Baseline multi-way
two-person review implements very closely the Active
Design Review Process invented by David Parnas
(See <A HREF =
"http://www.ics.hawaii.edu/~johnson/FTR/Bib/bib-master.html#Parnas85">Parnas85</A>.)



</blockquote>122<p><blockquote><hr>
<h2>Operational Scenarios: "True Group" Reviews</h2>

The last three scenarios illustrated three kinds of reviews 
supported by the PSP/Baseline process: personal reviews,
two-person reviews, and multi-way two-person reviews. These
reviews are supported by PSP/Baseline because they require
no particular support for group process, and because the 
process data collected is oriented toward personal process
improvement. 

</blockquote>122<p><blockquote>
Support for "true group" reviews is more complicated, 
because support for group process and group process
improvement is required. Such group-level support falls outside
the scope of the PSP/Baseline system requirements, which
is limited to personal software process improvement.  However,
an appropriately designed system for true group review
could interoperate with the PSP/Baseline tools in such a
way as to provide a continuum of support from individual
to group process improvement, each form of support
synergizing with the other. Thus, it is worth at least 
briefly mentioning some possible characteristics of a
true group toolkit, incarnations of which might be codenamed "TekInspect/1"
or "AFTR".
</blockquote>122<p><blockquote>

First, the true group review system might utilize the following
files types:
<ul>
<li> A .irev file providing the results of an individual's
    review (i.e. the "preparation" phase, using FTR terminology).  This
    file provides all the fields in a .drl file (indeed, the initial
    fields of a .irev entry would be identical to the fields in a .drl
    entry). It also includes three new fields: the document instance,
    the location of the defect within the document, and the defect
    severity.
<li> A .location file specifying how locations are represented 
    and implicitly defining a sorting order for defect locations.
<li> A .severity file defining the severity values for a given DocType.
<li> A .docinstance file defining the names of the actual document
instances under review and their associated document types.
<li> A .grev file providing the results of group review of the 
individual .irev files (i.e. the "meeting" phase, using FTR terminology).
</ul>

</blockquote>122<p><blockquote>
The true group review system woiuld provide several tools
to support creation and manipulation of 
associated process elements and data:
<ul>
</blockquote>122<p><blockquote><li> A "Prep" tool supporting individuals in the production of 
the .irev data files. It takes a
.location, .severity, .deftype, and .docinstance file and writes out or 
updates a  .irev file.

</blockquote>122<p><blockquote><li> A "Meeting" tool supporting the moderator in the 
review meeting.  It takes  one or more .location,
.severity, .deftype, .docinstance files, and all the .irev files produced by 
individuals.  It displays defects ordered either by location,
severity, defect type, or document instance.   It produces
a .grev file as output, which documents the outcome of review.

</blockquote>122<p><blockquote>
The .grev file also directs rework (and can be read and
updated as if it were a .drl file by the user's PSP/Baseline tools.)
This allows the outcome from review to be fed back as data into
the user's personal process database. 

</blockquote>122<p><blockquote><li> A set of review analysis tools to perform
various instantaneous or continuous data analyses on the review 
process data. 
</ul>




</blockquote>122<p><blockquote><hr>
<H2>Operational Scenarios: The DefectFrequency Analysis Tool</H2>

Recall that the four step process improvement lifecycle consists of:
<ol>
<li> Collect data on process and products.
<li> Analyze data to produce process changes
<li> Implement process changes 
<li> Evaluate the changes to verify that they are indeed improvements
through positive changes to process and product data.
</ol>

</blockquote>122<p><blockquote>
So far, the operational scenarios have demonstrated how the PSP/Baseline
system supports Steps 1 and 3. Step 1, data collection, is facilitated
through the DRL, TRL, and Review tools. Step 3, process change
implementation, is aided through the PSP/Baseline structured process
element definitions (i.e. the .doctype, .deftype, chkdef, and .phase files)
and the PCL tool for recording process changes.

</blockquote>122<p><blockquote>
This scenario demonstrates how PSP/Baseline supports Step 2, process
analysis.  The most important form of process analysis in PSP/Baseline
concerns defects. Using the DefectFrequency tool, Anne can determine which
types of errors she is currently making most frequently and which types of
errors are most time consuming to fix. Anne uses this information to
generate process improvements intended to reduce or eliminate her most
frequent or time consuming errors.

</blockquote>122<p><blockquote>
Anne invokes the DefectFrequency tool as:
<pre>
% pali-df 
</pre>
which is aliased to:
<pre>
% java csdl.java.pspbase.DefFreq /group/csdl/csdlbase/base.prj
                             /group/csdl/java/pali/psp/anne/usersurvey.prj
                             /group/csdl/csdlbase/base-srs.deftype
                             /group/csdl/java/pali/psp/anne/srs.deftype
                             /group/csdl/java/pali/psp/anne/anne.drl
                             /group/csdl/java/pali/psp/anne/all-revs.drl
</pre>

Note that these are the same command line arguments used for the DRL
tool, except for the last argument, which is a file Anne created that
merges all of the .drl files provided to her by group members during
the various reviews of the SRS.
</blockquote>122<p><blockquote>

The tool provides menus allowing her to select a project and a document
type in the normal way.  She selects "Pali/1" and "SRS".  Based upon these
criteria, the tool finds all the defects associated with the SRS document
type within the Pali project in the anne.drl file. It then sorts these
defects and presents them in any of the following orders:

<ul>
<li> Ascending order by Defect type number
<li> Descending order by frequency of detected occurrence
<li> Descending order by cumulative fix time
</ul>
</blockquote>122<p><blockquote>

In this case, Anne selects the following Defect Frequency Report for her SRS documents:
</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=4>Defect Frequency Analysis
<tr><td colspan=2><center>Pali/1</center><td colspan=2><center>SRS</center>
<tr><th colspan=2>Defect Frequencies by:<td colspan=2><center>Fix Time</center>
<tr><th>Type              <th>Fix Time  <th>Freq
<tr><td>40:  Func. Reqs   <td>7:20      <td>2     <th>List
<tr><td>30:  Scenarios    <td>1:20      <td>4     <th>List
<tr><td>70:  Data         <td>0:60      <td>6     <th>List
<tr><td>60:  Interface    <td>0:45      <td>4     <th>List
<tr><td>20:  Intro        <td>0:25      <td>2     <th>List
<tr><td>11:  Spelling     <td>0:20      <td>18     <th>List
<tr><td>13:  Parallelism  <td>0:20      <td>18     <th>List
<tr><td>10:  Syntax       <td>0:15      <td>12     <th>List
<tr><td>12:  Pass. Voice  <td>0:15      <td>6     <th>List
<tr><td>50:  Gen. Desc.   <td>0:00      <td>0     <th>
<tr><td>80:  Conc. Des.   <td>0:00      <td>0     <th>
<tr><td>90:  Schedule     <td>0:00      <td>0     <th>
<tr><th>Totals            <td><b>11:00</b> <td><b>72</b>
</table>
</center>
</blockquote>122<p><blockquote>

This report reveals to Anne that she spent over half of her defect fix time
on six errors involving her functional requirements and scenarios. To start
understanding these defects in more detail, she presses the <b>List</b>
button to see the actual defects associated with each of these categories.
This results in the creation of a DRL Log window containing instances of
just the specified defect type.

</blockquote>122<p><blockquote>
Here's what she finds for Functional Requirements:

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=9>DRL Log
<tr><td colspan=9><center>/group/csdl/java/pali/psp/anne/anne.drl</center>
<tr><th>Date<th>Project<th>DocType<th>Occur<th>ChkList<th>DefType<th>Inj<th>Rem<th>Fix
<tr><td>12/20/96<td>Pali/1<td>SRS<td>1<td><td>40: Func. Reqs<td>Reqs<td>Code<td>1:00
<tr><th><td colspan=8><pre>Olomana joint file incompatibility.</pre>

<tr><td>01/12/97<td>Pali/1<td>SRS<td>1<td><td>40: Func. Reqs<td>Reqs<td>Test<td>6:20
<tr><th><td colspan=8><pre>Class integration error with olomana.jplan</pre>

<tr><th colspan=9><hr>
<tr><th>Save<th>HTML<th>Quit
</table>
</center>
</blockquote>122<p><blockquote>

She notes that these two errors both slipped through the requirements
review and design phases.  She also realizes that both of them resulted
from a failure to coordinate the Pali development process with a related
project, Olomana. Furthermore, she remembers that she did not ask the
Olomana developer to participate in any Requirements Reviews, which might
well have led to these problems being caught and fixed before Code and
Test.
</blockquote>122<p><blockquote>
To help prevent this class of expensive problems from occurring in 
future, Anne creates a file called anne-srs.chkdef with the following 
contents:

<pre>
# anne-srs.chkdef
SRS

11	Inter-project Consistency	Identify all related dev. projects:
\n 1. What functional dependencies exist between the projects?
\n 2. Are all functional dependencies described completely?
</pre>

</blockquote>122<p><blockquote>
She also updates her defect classification list with a new Functional
Requirements subclass called "41: Inter-project dependencies", and
reclassified these two defects from 40 to 41.

</blockquote>122<p><blockquote>
Because this is a change to her
personal development process that should impact upon future 
process measures, Anne makes a note of this process change in 
her personal PCL as follows:
</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=5>PCL Active Entry
<tr><td>12/04/96<th>Affected Elements<th>Add<th>Log<th>Quit
<tr><th>Description<td colspan=4> 
<pre>Added checklist item 11 on inter-project dependencies.</pre>
<tr><th>Intended Impact<td colspan=4> 
<pre>Reduction in Defect Type 41 (interproject dependency) errors.</pre>
</table>
</center>
</blockquote>122<p><blockquote>

</blockquote>122<p><blockquote><hr>
<h2>Operational Scenarios: The DefectTrend Evaluation Tool</h3>

The Defect Trend tool is an example of PSP/Baseline support for Step 4,
process evaluation. The defect trend
tool illustrates how the frequency of defects and rework effort 
required to remove them is changing over time, and marks the 
occurrence of relevant process changes on these trend lines. 

</blockquote>122<p><blockquote>
If personal process improvement is occurring, then over time there should
be a reduction in either the frequency of errors, the cost of errors, or
(hopefully) both.  Furthermore, there should be some demonstrable
connection between the process changes that were implemented by the user
and these reductions. The Defect Frequency Trend tool graphs these trends
and facilitates the user in assessing the impact of process changes.
</blockquote>122<p><blockquote>

As an example, after Anne works her way through a half dozen projects,
She invokes the DefectTrend tool as follows:

<pre>
% java csdl.java.pspbase.DefTrend /group/csdl/csdlbase/base.prj
                             /group/csdl/java/pali/psp/anne/usersurvey.prj
                             /group/csdl/csdlbase/base-srs.deftype
                             /group/csdl/java/pali/psp/anne/srs.deftype
                             /group/csdl/java/pali/psp/anne/anne.drl
                             /group/csdl/java/pali/psp/anne/anne.pcl
                             /group/csdl/java/pali/psp/anne/anne.size
                             /group/csdl/java/kula/psp/anne/anne.drl
                             /group/csdl/java/kula/psp/anne/anne.pcl
                             /group/csdl/java/kula/psp/anne/anne.size
                             /group/csdl/java/kai/psp/anne/anne.drl
                             /group/csdl/java/kai/psp/anne/anne.pcl
                             /group/csdl/java/kai/psp/anne/anne.size
                             /group/csdl/java/pau/psp/anne/anne.drl
                             /group/csdl/java/pau/psp/anne/anne.pcl
                             /group/csdl/java/pau/psp/anne/anne.size

</pre>

The DefTrend tool takes a set of .prj files defining projects, a set of
.deftype files defining defect classifications for various document types,
a set of .drl files providing defect entries for the projects to be
analyzed, a set of .pcl files containing process change data, and a set of
.size files containing size data for the projects.

</blockquote>122<p><blockquote>
Invocating the DefTrend tool brings up a window that allows the user to
select:
<ul>
<li> The document type on which to show defect trends.
<li> Whether to graph the points by month or by project. Graphing by Project is generally
better when the user undertakes one project at a time and finishes one
before starting the next. Graphing by month is generally better when a user
is working on several projects simultaneously, and so process improvements
take effect on multiple projects at a time.
<li> Whether to graph the defect types by frequency or fix time.
</ul>

</blockquote>122<p><blockquote>
Anne selects the SRS document type, graphing by project, and frequencies.
These selections generate the following graph: 

</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th colspan=3>Defect Frequency Trend Report
<tr><td>SRS<td>Graph by Project<td>Show Frequencies
<tr><td colspan=3><IMG SRC=DefFreqTrend.gif>
</table>
</center>
</blockquote>122<p><blockquote>

This graph shows each of the defect types associated with Anne's
SRS documents and their frequency values
over time.  Defect Frequencies are "normalized" between projects by
dividing the number of occurrences of the defect by the work product's
size. 
In the case of Anne's SRS documents, she chose the total number of pages 
as the size metric and provided these values for each of the SRS
documents in the associated .size file.  

</blockquote>122<p><blockquote>
Whenever one or more process changes that were predicted to affect a defect
type were instituted within a project, that project's defect frequency
value is indicated with a large red square rather than the normal icon. In
this case, three process changes predicted to affect defect type data were
instituted by Anne over the course of these projects.  Clicking on these
red boxes would bring up a PCL Log window showing the associated process
change.

</blockquote>122<p><blockquote>
Anne makes the following assessments about her process improvement
activities on SRS documents as a result of the frequency and fix
time graphs generated by the DefTrend tool:
<ul>
<li> At a high level, the defect trend is encouraging. Total defect frequency
per unit size has decreased from about 9 defects per page in her
Pali/1 SRS to about 6 defects per page in the Pau/1 SRS.  The 
graph of defect fix time shows similar improvement. 
<li> Three process changes occurred that were predicted to impact
on defect types. The process change on defects of type 70 were
followed by a sharp decrease in their frequency of occurrence. 
The process change on defects of type 30 made no impact upon 
a gradually increasing trend in frequency of 
defects of that type. Finally, the process change on defects of 
type 80 did not appear to have much impact at all. 
<li> Three defect types account for the majority of defects found
in Anne's SRS documents. This fact can guide her future process
improvement activities. 
<li> The increasing trend in defects of type 30 is particularly worrisome,
and bears further exploration.  Could the process changes made to decrease
the frequency of other defect types be inadvertantly increasing the
frequency of type 30 defects? Or is this increasing trend a function of a
change over time in the type of projects?  Or has Anne simply become more
sensitive to errors of this type and is thus recording them more
accurately?  Based upon this graph, Anne decides to investigate the
instances of type 30 errors over all of these six projects in an attempt to
determine which of these hypotheses might be correct, and what to do in
response.

</ul>


</blockquote>122<p><blockquote><hr>
<h2>Operational Scenarios: The Time Trend Evaluation Tool</h2>

Another example of process evaluation support in PSP/Baseline is
the Time Trend evaluation tool.  This tool takes as input a set
of .trl files from various projects and displays the percentage
of time allocated to each phase. If different projects use 
different sets of phases, then (for this invocation of the report,
at least) a project without a definition for a phase is simply
reported as having allocated no time to that phase. 
</blockquote>122<p><blockquote>

For example, Anne invokes the TimeTrend tool as follows:

<pre>
% java csdl.java.pspbase.TimeTrend /group/csdl/csdlbase/base.prj
                             /group/csdl/java/pali/psp/anne/anne.trl
                             /group/csdl/java/kula/psp/anne/anne.trl
                             /group/csdl/java/kai/psp/anne/anne.trl
                             /group/csdl/java/pau/psp/anne/anne.trl
</pre>

This generates the following report:


</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th>Time Trend Report
<tr><td><IMG SRC=TimeTrend1.gif>
</table>
</center>
</blockquote>122<p><blockquote>

This rather complicated looking bar graph shows the percentage of time
allocated to each phase in the CSDL/Baseline process for the six projects
that Anne was involved in. Looking over this graph, Anne notices that 
later projects had a more complex development process involving more phases
than the earlier ones (the later project bars have more "stripes" than the
earlier ones.)

</blockquote>122<p><blockquote>
Anne decides to investigate time trends a bit further by defining a 
"Virtual Phase" file.  This file allows the user to define a set
of new phases that support renaming and/or aggregation of the original
phase set. This has several uses. For example, suppose that in one
project, the requirements review phase is called "ReqsRev", but in another,
it's called "RequirementsReview".  This would show up as two distinct
phases in the Time Trend graph, although they are semantically equivalent.
One good solution is to go through all the .trl and .phase files and 
provide uniform names.  Another is to define a virtual phase file that
renames the RequirementsReview phase to ReqsRev.
</blockquote>122<p><blockquote>
The more interesting use is to support aggregation.  Virtual phases can
be used to represent a complicated software process consisting of many
phases (such as CSDL/Baseline) as a much simpler set of aggregate phases.
This can sometimes makes trends much more obvious.  Anne creates the 
following virtual phase file to reduce her time data to four categories:
PreCompile, Review, CompileTest, and Release:

<pre>
# anne.vphase --- 
Reqs	PreCompile
ReqsRev	Review
Design  PreCompile
DesRev  Review
TestPlan	PreCompile
TestRev Review
Code	PreCompile
CodeRev Review
Compile Compile/Test
Test    Compile/Test
ReleaseDoc      Release
ReleaseFix      Release
</pre>

</blockquote>122<p><blockquote>
Anne now reinvokes the time trend tool as before, but this time 
supplies the anne.vphase file along with the other file arguments:


<pre>
% java csdl.java.pspbase.TimeTrend /group/csdl/csdlbase/base.prj
                             /group/csdl/java/pali/psp/anne/anne.trl
                             /group/csdl/java/kula/psp/anne/anne.trl
                             /group/csdl/java/kai/psp/anne/anne.trl
                             /group/csdl/java/pau/psp/anne/anne.trl
                             /home/5/anne/psp/anne.vphase
</pre>

This time, the Time Trend tool generates the following report:


</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th>Time Trend Report (virtual phases)
<tr><td><IMG SRC=TimeTrend2.gif>
</table>
</center>
</blockquote>122<p><blockquote>

First, Anne looks at ranges in the individual virtual phases:
<ul>
<li> Release time seems to stay relatively stable at around 20% of development
time across all the projects. 
<li> PreCompile time is more volatile: ranging from around 10% to 30% of total
development time.
<li> Compile/Test time is extremely volatile, ranging from around 5% to
about 50% of development time. 
<li> Reviews ranged from 0% on some projects to about 40% on the Kai/1
project.
</ul>
</blockquote>122<p><blockquote>

However, these phase percentages appear correlated.  The project with the
least amount of compile/test time had the most review time, and vice-versa:
the projects without reviews had the highest percentage effort allocated
to compile/test. This time trend data seems to support the hypothesis that
increased effort on design and review directly reduce the time spent in 
compile and test.

</blockquote>122<p><blockquote>
Anne concludes that, with respect to time/phase data, the most important
process changes over these six projects has been the initiation of review
activities and increases in design.  These process changes appear to have
had an effect on the time required for compile and test, but not much
impact on post-release effort. 
To further evaluate the process changes revealed by the TimeTrend tool,
Anne needs to explore some other process questions, such as:
<ul>
<li> What is the impact upon scheduling, planning, and estimation
activities? Does increased design and review make the project easier
to manage (i.e. more predictable) or harder (less predictable)?
<li> What is the impact upon quality, as measured by process yield,
ReleaseFix effort, and total defect frequency/fix times?
<li> What is the impact upon productivity?
</ul>

If designs/reviews are merely a substitution for
compile/test time and do not provide any other residual benefits, then this
might be a case of "six of one, a half-dozen of the other."  

</blockquote>122<p><blockquote>
Anne uses other PSP/Baseline tools to investigate these questions. She
finds that she cannot determine if increased design/review time has a
positive effect upon project manageability, since time and size predictions
are not done in CSDL.  However, she sees a substantial increase in 
process yield, and a substantial decrease in defect frequencies and fix
time for the projects using reviews. She also finds a slight increase
in productivity occuring. As a result, she evaluates this process change
to be positive and intends to continue using reviews and design in future
projects. She also decides to try making time and size predictions in order
to test whether project manageability is feasible and useful. 

</blockquote>122<p><blockquote><hr>
<h2>Other Analysis/Evaluation Tools</h2>

The completed PSP/Baseline system will provide several other 
analysis and evaluation tools. This section provides a brief
description of these tools.


<ul>
<li><em>Productivity.</em> Tool support for productivity will provide
measures of productivity (such as LOC/hr) both within a single project
and across several projects. 
<li><em>DirectTime.</em>  This tool support will show how the user's
direct time varies on a daily, weekly, and monthly basis. Reports can
be based upon a single project or multiple projects.
<li><em>DesignDiff.</em> This tool will show the difference between the 
conceptual design and final implementation, and graph the trends in
this value over multiple projects. 
<li><em>Yield.</em> Yield measures the percentage of defects known to
be in a work product during a particular phase that were removed during
that phase. Measures of yield per phase can be provided on a single
project basis and as a trend over time. 
<li><em>Project status.</em> This tool can provide a "snapshot" of 
development efforts by a user to date on a single project, combining 
together reports on defects, time, yield, productivity, and so forth.
</ul>


</blockquote>122<p><blockquote><hr>
<H2>Functional Requirements</H2>

This section lists important functional requirements.  Functional
requirements describes the possible effects of a software system, in other
words, <EM>what</EM> the system must accomplish. 

<h3>PSP data collection incurs low overhead.</h3>

<dl>
<dt> Description
<dd> Collection of PSP data on time and defects must be extremely fast and
easy for the most common situations.  In general, little to no typing
should be required: a typical TRL or DRL entry should require no more
than a few mouse gestures and should be completable in less than 2-3
seconds. 
<dt> Technical issues
<dd> This functional requirement implies a great deal of attention to be
paid to the GUI interface to make it as simple and efficient to use as
possible.
<dt> Risks
<dd> If the system is high overhead, people will not record their time
or defect information accurately, which will result in data that does
not reflect reality.
<dt> Dependencies
<dd> This requirement permeates the entire system design.
</dl>

<h3>Useful process analyses are provided.</h3>

<dl>
<dt> Description
<dd> Process data will only be collected accurately when the users
understand and value the kinds of analyses that can be performed upon the
raw data.  For the tool to be successful, it must be clear how the data
will be used, and it must be clear how the data will be useful to
individuals.
<dt> Technical issues
<dd> Some analyses may require a high number of historical 
"project data points" before they are useful.  
<dt> Risks
<dd> If the analyses are vague and their implications unclear, then 
collection of basic process data will cease to be motivated.
<dt> Dependencies
<dd> 
</dl>

<h3>All persistant data is human-readable (ASCII) format.</h3>
<dl>
<dt> Description
<dd> All persistant data is kept in an ASCII format

<dt> Technical issues
<dd> The advantages of this requirement are:
<ul>
<li> Users and developers can construct, modify, split, and join data files 
manually. This simplifies the requirements for the PSP/Baseline system, as 
certain activities (such as phase and defect type definition) can be assumed to be accomplished by use of a normal 
text editor. 
<li> We do not have to learn (or commit ourselves to) a persistant object
system (such as PSE) or database back-end (such as Oracle). 
<li> We do not have to engineer in mechanisms for database file
manipulation (split, join, rename, etc.).
<li> Interoperability with other systems is vastly simplified. The file
format specification is open, which allows other tools to read our files or
produce files compatible with our tool kit.
<li> System errors in reading/writing that result in corrupted files can be much more easily detected and
repaired by users and/or developers. 
<li> System implementation/integration/testing will be simplified.  Developers can
manually build data files for input and testing. 
<li> An ASCII file format does not preclude later development of
PSE/Oracle/etc interfaces. Indeed, these facilities could be a natural part
of a contract with an external customer to customize PSP/Baseline to their
development environment. 
<li> ASCII data minimizes measurement dysfunction: users know exactly what
information is being provided when a file is released. 
</ul>
The disadvantages of this requirement are:
<ul>
<li> Users and developers can construct, modify, split, and join data files 
manually. The possibility exists that they will occasionally corrupt the
files. 
<li> The performance of the system may suffer. Reading and writing ASCII
will take longer. 
<li> No concurrency control is provided initially, and building it in will
be more complicated, since it has to occur at the OS file level.
<li> There are dependencies between files that must be maintained
manually. File inconsistencies can occur more easily.
</ul>
<dt> Risks
<dd> This decision reduces many system development and integration
risks. One major negative risk is that reading these files may be so
slow as to impact upon system usability.
<dt> Dependencies
<dd> 
</dl>



<h3>Objects can be combined/reconfigured.</h3>
<dl>
<dt> Description

<dd> The system is implemented in such a manner that each level (the
top-level GUI interface, the intermediate class objects, and the low-level
files) can be combined and reused in a variety of ways. For example: each
button should be encapsulated and reusable in a variety of tools. Each 
set of related buttons should be placed in its own panel so that it can be
easily reused in other GUI interfaces.  Objects such as dates and durations
should be tool-independent.

<dt> Technical issues
<dd> This is just standard high-quality object-oriented design, but is
quite important to the success of this system, since the PSP/Baseline
system is just the first in a long stream of systems to support PSP and 
software quality improvement. The best way to help ensure reusability is 
review of both initial conceptual designs and final implementations with
all other developers. This will also minimize duplication of effort, and
help to converge design and implementation styles within the group.

<dt> Risks
<dd> A failure to produce reusable components will greatly increase
development effort and slow down progress.
<dt> Dependencies
<dd> 
</dl>


<h3>Process element names are maintained externally and are read-only.</h3>
<dl>
<dt> Description

<dd> Process elements are things like project names, phase (phase) names,
defect types, and so forth.  PSP/Baseline tools maintain all process
elements in external files.  These files are "read-only" with respect to the
toolset: users cannot modify, add, or delete process elements using
PSP/Baseline tools.  (They can, of course, modify process elements
using normal text editors, usually under RCS control.)
</blockquote>122<p><blockquote>
Because process elements are read-only, menu items providing selection
of process elements do not allow users the option of typing in a 
new process element "on the fly".  To define a new process
element, users must go outside the PSP/Baseline tool, edit the
corresponding process element file manually, and reload the modified file
into the tool. 
</blockquote>122<p><blockquote>
Process "elements" are distinct from process "data", such as time
log entries, defect log entries, and process change log entries. 
This latter process data is both read and written by PSP/Baseline
tools. 
<dt> Technical issues
<dd> This advantages of this requirement are:
<ul>
<li> Process element names change slowly.  It is not extremely costly to
the user to have to edit process element names manually and external to the
tool.
<li> Process element names should be consistent and stable to facilitate
trend analysis.  By disallowing dynamic process element name creation, the
tools help maintain consistency and stability.
<li> The usability of the system increases. Under normal usage, users do
not type process element names, but simply select them from menus.
<li> The reliability of the system increases. Users cannot enter an
incorrect process element name.
</ul>
<dt> Risks
<dd> This assumes that process element names change slowly.  In highly
volative process contexts, this assumption may be violated. 
<dt> Dependencies
<dd> 
</dl>


<h3>All "read-only" data can be provided to tools in multiple files.</h3>
<dl>
<dt> Description
<dd> Read-only process elements are stored in .prj, .phase,
.doctype, .deftype, and .chkdef files. Any tool that requires
at least one file of this type as a command-line argument 
must also accept more than one file of this type as a command-line
argument.  Each tool thus "merges" process elements of the same
type that are spread across multiple files. 
</blockquote>122<p><blockquote>

In addition, some analysis tools require only read-only access to writeable
process data files (i.e .trl, .drl, and .pcl files).  In this case, too,
multiple files of the same type must be supported. 

</blockquote>122<p><blockquote>
The rationale for this requirement is to allow "group-wide"
standardized process elements to be stored in one common
file used by all group members, with each group member
augmenting the standard process element with additional
"personal" process elements that they privately maintain. 
</blockquote>122<p><blockquote>
For example, CSDL may define a single .prj file containing
all the current CSDL projects in development. An individual
may augment this process element with another .prj file 
containing projects they've defined to support their classroom
activities, for example. 

<dt> Technical issues
<dd> Minor. Command line parsing is minimally more complex.
Name conflicts among group-level and individual project names
must be avoided. 
<dt> Risks
<dd> The ability to merge process elements from different sources
may give rise to incompatibilities or inconsistencies, but none
are foreseen at present. 
<dt> Dependencies
<dd> 
</dl>


<h3>Tools that write process data accept only one file of that
type.</h3>
<dl>
<dt> Description
<dd> The TRL, DRL, and PCL tools write files of type .trl, .drl, 
and .pcl, respectively.  Those tools, for example, cannot accept
multiple files of those types, since it would be unclear into 
which file the new information should be written. 
</blockquote>122<p><blockquote>
Those tools would, of course, continue to accept multiple 
files for any read-only process elements they require.

<dt> Technical issues
<dd> None. The rationale for this requirement is to simplify 
the design of the tool. 
<dt> Risks
<dd> This requirement forces the user to manually merge or split
the contents of any writeable files. 
<dt> Dependencies
<dd> 
</dl>

<h3>No assumptions are made about the project-level organization of .trl, .drl, or .pcl files.</h3>
<dl>
<dt> Description
<dd> The PSP/Baseline system makes no assumptions about how users and
groups decide to organize data within file types.  For example, one user may 
decide to maintain individual .trl, .drl, and .pcl files for all their  work
across multiple projects, and start a new .trl and .drl file on the first
day of each month.  A second user may decide to keep separate .trl, .drl,
and .pcl files for each project, and start new files only when starting
a new project.  A third user may do a review of a work product, and give
the resulting .drl file to the author of the work product, who then
simply appends this .drl file to her own. 
The system supports all of these situations. 

<dt> Technical issues
<dd> It is quite unclear as to how users will wish to organize their 
data files, and it is quite possible that the desired organization may
vary from user to user and even within an individual user over time. 
By maintaining the files in ASCII format, and by not making any assumptions
about how data of a given type (i.e. .trl, .drl, or .pcl) is split across
files, the system accomodates this lack of certainty.
<dt> Risks
<dd> There is relatively little risk to this requirement, and it is quite
easy to implement.
<dt> Dependencies
<dd> 
</dl>


<h3>Data is anonymous.</h3>
<dl>
<dt> Description
<dd> No username information is required within any of the 
data files. Any user information provided in file names or in comments
inside data files is optional.
<dt> Technical issues
<dd> None. The rationale for this requirement is to support the
exploration of measurement dysfunction issues and to determine the
costs and benefits of anonymous process data.
<dt> Risks
<dd> Some analyses may be impacted by lack of user identification
information.
<dt> Dependencies
<dd> 
</dl>

<h3>Defect type and instance relationships are maintained manually.</h3>

<dl>
<dt> Description
<dd> For example, the contents of the .deftype file (containing the defect type
classifications) and the contents of the .drl file (containing 
actual defect instances) will have a tendency to diverge over
time, and consistency between them must be maintained manually.
This is also true for any other inter-file data references. 
<dt> Technical issues
<dd> This is a problematic issue.  The .deftype file will evolve
over time to reflect each individual's defect tendencies. 
Yet each time the .deftype file changes, it may be necessary to 
revise one or more .drl files if it is desired that these
.drl files be consistent with the .deftype file (and, indeed, this
consistency <em>will</em> be necessary to support defect
trend analysis.)
<dt> Risks
<dd> There is a real risk that the overhead of maintaining 
consistency between .deftype and .drl files will make defect trend analysis
a high overhead activity.  It may be necessary to implement a
special purpose tool specifically for defect type classification
maintenance that reads in a single .deftype file and all related 
.drl files, and provides automated support for consistency maintenance.
<dt> Dependencies
<dd> 
</dl>

<h3>All tools provide standardized real-time status messages.</h3>

<dl>
<dt> Description
<dd> All PSP/Baseline tools should include a small "status" 
area dedicated to indicating the activity of the tool and readiness for user
input is constantly displayed. If the tool is waiting for
user input, it should indicate "Ready" in the status area. 
If the system is reading or writing files, it should indicate
this fact in the window. If it is performing some other
activity that precludes user input or system response, this
should be indicated as well.
<dt> Technical issues
<dd> The major technical issue is how to provide this feedback to the 
user on the status of the tool while using a minimum of screen 
real estate. </blockquote>122<p><blockquote>
It is worth investigating whether this info can be displayed, for
example, in the title of the window. </blockquote>122<p><blockquote>
All PSP/Baseline tools should implement the status area in 
the same way and provide a consistent set of messages.
<dt> Risks
<dd> The status line should be accurate. Inaccurate status info is
worse than none at all.
<dt> Dependencies
<dd> 
</dl>

<h3>Screen real estate is valuable and must be conserved.</h3>

<dl>
<dt> Description
<dd> The PSP/Baseline tools should assume that they must share
screen real estate with other development tools, and that they 
must assess their relative priority for screen real estate
with other development tools during interface design.
</blockquote>122<p><blockquote>
For example, tools such as the DRL and TRL are normally
viewed as "background" tools that should be unobtrusive while
the user is doing the "real work" of development. These tools
must occupy a minimum of screen real estate while still being
useful.  On the other hand, tools such as the Review Tool or
the analysis tools are "foreground" tools that occupy the 
user's direct and continuous focus when they are in use. 
Thus, these tools are free to require more screen real estate
as long as they use it appropriately and efficiently. 
<dt> Technical issues
<dd> Effort must be focussed on how to design the tools to 
provide maximal information in minimal space, and how to 
distribute functionality so that the user does not have 
screen real estate allocated to providing process information
that is not useful to them at the current time. 
<dt> Risks
<dd> Some tools (such as DRL and TRL) may not be usable if 
they cannot conform to a variety of screen sizes and shapes 
and if they do not allow usage alongside other tools such as editors. 
<dt> Dependencies
<dd> 
</dl>


<h3>Command line file argument processing is robust.</h3>

<dl>
<dt> Description
<dd> All PSP/Baseline tools accept a variable number of command line 
arguments, each being the name of a file. The processing of these files
should support at least the following situations:
<ul>
<li> One or more files are unreadable.
<li> One or more files have an invalid extension (example: ".project")
<li> One or more files, when read, have an internal syntax error. 
<li> Files can be specified in any order.
<li> Multiple files of the same type can be provided when read-only.
<li> Missing required files (such as the .drl file for the DRL tool) are
     recognized.
<li> Whenever multiple files with the same extension are provided, the
contents of the two files must be merged.  This merging process should be
validated and any warnings/errors presented to the user. (What constitutes
a "valid merge" depends, of course, on the specific file type.)
</ul>
In each of these cases, a standard modal dialog box should be presented
to the user that explains the problem. When the error is "continuable"
(such as an unreadable but optional file), then the user should be provided
with the option to continue the tool invocation process or abort. This 
should be presented as to the user as a "Warning". When 
the error is not continuable, the tool present the error in the dialog box
as an "Error", indicate what must be fixed, and provide an "OK" button
which terminates processing. 

<dt> Technical issues
<dd> This will require fairly sophisticated file processing that must also
be standardized across a half dozen different tools. 
<dt> Risks
<dd> Poor quality command line processing will make the tools unusable.
<dt> Dependencies
<dd> 
</dl>


</blockquote>122<p><blockquote><hr>
<H2>Interface Requirements</H2>

There are three basic interfaces to the system: a GUI user interface, 
an API interface to all of the classes in the system, and a file
interface. 

<h3>GUI User Interface</h3>

The GUI user interface is constructed from JClass, AWT, and BWT 
components. Some experimentation will be required to determine which 
GUI components are most appropriate in which contexts. Rough mockups
of GUI interface components are provided for most of the tools in 
the Operational Scenarios section above, with one exception.  We 
anticipate using the JClass "charts" package when it is released
(supposedly Q1 of 1997).


<h3>API Interface</h3>

Each component of the PSP/Baseline system has a programmable API.  In
particular, all GUI interactions should also be programmatically available
through standard Java method invocations.
</blockquote>122<p><blockquote>
Specific API details will be determined during the conceptual design of each 
component of the system.

<h3>File Interface</h3>

Persistant data collected by the system is stored in files.  These files
are in ASCII format and have a public specification associated with them
(provided in the next section).  The persistant files form a third
interface to the system. Files written by one tool may be read by another
tool.  Each of these tools may be PSP/Baseline tools, or may also be other
tools within the development environment. 


</blockquote>122<p><blockquote><hr>
<H2>Persistant Data Requirements</H2>

All persistant data is maintained in ASCII files.  This section specifies
the format for the constituents of a file and the structure of each 
persistant file.

<h3>General Requirements</h3>

All PSP/Baseline files conform to the following requirements:
<ol>
<li> A "#" in the first column indicates that the entire line is a comment and
     must be ignored by the tool. This allows users or tools to
     insert information into files for documentation purposes that will not
     be read as data by the tool.  Such comment lines can occur anywhere
     within the file.

<li> A line consisting of only the newline character is also interpreted as
     a comment line and must be ignored by the tool. 

<li> A tab character separates elements within a line.  Thus, tab
     characters are illegal within any data element. Any field containing
     user text must be checked and any tab characters inserted by the user
     must be removed before storing in a PSP/Baseline persistant file.

<li> A newline character ends each entry.  Thus, newline characters
     are illegal within any data element. Any field containing
     user text must be checked and any newlines inserted by the user
     must be removed before storing in a PSP/Baseline persistant file.

</ol>

<h3>Dates</h3>

Dates are found throughout the PSP/Baseline files.  All date instances are stored in the
following 19 character format:
<pre>
YYYY/MM/DD HH:NN:SS
</pre>
where:
<ul>
<li> YYYY is a four digit year, such as "1996".
<li> MM is two digits from "01" to "12".  
<li> DD is two digits from "01" to "31". 
<li> HH is two digits from "00" to "23".
<li> NN is two digits from "00" to "59".
<li> SS is two digits from "00" to "59".
</ul>
</blockquote>122<p><blockquote>
This is a controversial design.  The ECS date package provides equivalent 
functionality in six ASCII characters, which is a 60% savings in size. 
However, the ECS date encoding is essentially unreadable by users.
</blockquote>122<p><blockquote>
The advantages of this design are as follows:
<ul>
<li> The format is extremely readable. Users can interpret and manually
create date instances without problem. 
<li> The format is extremely interoperable.  Other tools can read or produce
dates in PSP/Baseline format without any problem. 
</ul>
The disadvantages of this design are as follows:
<ul>
<li> The format is extremely consumptive of space. It will not scale to
support fine-grained process measurement, as we discovered in ECS.
However, fine grained process measurement (i.e. support for hundreds to
thousands of timestamped data) is not a current or anticipated requirement
for the PSP/Baseline system or its descendents.
</ul>
</blockquote>122<p><blockquote>

Finally, it should be noted that if this design decision is found to be
wrong, it will be reasonably easy to implement a new ASCII date
representation and automatically update previously created files to the new
format.

<h3>Durations</h3>

Durations represent time intervals. Each duration instance is stored in the
following format:
<pre>
HH:NN:SS
</pre>
where HH, NN, and SS have the same interpretation as provided for date
instances above. 
</blockquote>122<p><blockquote>
Durations are indicated within the file specifications as &ltduration&gt.

<h3>Descriptions</h3>

A description is any unstructured ASCII text.  A description instance
consists of (a possibly empty) sequence of ASCII characters except newlines
and tab characters.  A description instance is allowed to have the "#"
character, but this is because no PSP/Baseline file line starts with a
description, so it is impossible for a "#" within a description to result
in the line being interpreted as a comment.
</blockquote>122<p><blockquote>

Although descriptions cannot contain either tab characters or newlines,
users are allowed to compose comments with tab characters and newlines
which are stored in an encoded format in descriptions.  For each ASCII
string to be stored as a description, the encoding is as follows:

<ol>
<li> Replace all occurrences of the two character string "\n" within the
original ASCII string with "\\n", and all occurrences of "\t"
with "\\t".

<li> Replace all newline characters with the two character
string "\n", and all tab characters with the two character
string "\t".
</ol>
</blockquote>122<p><blockquote>

To decode a description back into the original ASCII string (which
may contain tabs and newlines):
<ol>
<li> Replace all occurrences of the two 
character string "\n" which are not preceded by a "\" by a newline
character, and all occurrences of "\t" not preceded by a "\" with
the tab character.
<li> Replace all occurrences of "\\n" with "\n" and "\\t" with "\t".
</ol>


</blockquote>122<p><blockquote>
Descriptions are indicated within the file specifications as &ltdesc&gt.


<h3>The .trl file</h3>

Each .trl file contains time recording log information.  The file is a 
mixture of comment lines
and time entry lines. Each time entry line has the following format:

<pre>
&ltproject&gt &ltphase&gt &ltstart&gt &ltstop&gt &ltint&gt &ltelapsed&gt
</pre>
where
<ul>
<li> any field may be empty.
<li> each field is separated by a tab.
<li> &ltproject&gt, &ltphase&gt, &ltstart&gt, and &ltstop&gt are all descriptions. 
<li> &ltint&gt and &ltelapsed&gt are durations.
</ul>
</blockquote>122<p><blockquote>
Example (with tabs replaced by spaces):
<pre>
# Author: Philip Johnson
Pali/1 Reqs 1996/12/10 13:00:00 1996/12/10 14:00:00 00:00:00 01:00:00
</pre>

</blockquote>122<p><blockquote>
There are no requirements that the lines of this file must be sorted in any
order. Any required sorting of this information must be done by the tool.

<h3>The .drl file</h3>

Each .drl file contains defect recording log information.  The file is a 
mixture of comment lines
and defect entry lines. Each defect entry line has the following format:
<pre>
&ltdate&gt &ltproject&gt &ltdoctype&gt &ltoccur&gt &ltchklist&gt &ltdeftype&gt &ltinj&gt &ltrem&gt &ltfix&gt &ltcomment&gt
</pre>
where
<ul>
<li> any field may be empty.
<li> each field is separated by a tab.
<li> &ltdate&gt is a date. 
<li> &ltproject&gt, &ltdoctype&gt, &ltchklist&gt &ltdeftype&gt, &ltinj&gt, &ltrem&gt,
and &ltcomment&gt are all descriptions. 
<li>  &ltoccur&gt is a number.
<li> &ltfix&gt is a duration.
</ul>
</blockquote>122<p><blockquote>
Example (with tabs replaced by spaces):
<pre>
# Author: Philip Johnson
1996/12/23 12:00:00 Pali/1 Java 1  11: Spelling Reqs Code 00:15:00 
1996/12/24 14:00:00 Pali/1 Java 1  10: Syntax Reqs Code 00:15:00 
</pre>

</blockquote>122<p><blockquote>
There are no requirements that the lines of this file must be sorted in any
order. Any required sorting of this information must be done by the tool.


<h3>The .pcl file</h3>

Each .pcl file contains process change log information.  The file is a
mixture of comment lines and process change lines. Each process change line
has the following format:

<pre>
&ltdate&gt &ltdescription&gt &ltimpact&gt {&ltelement&gt}*
</pre>
where
<ul>
<li> any field may be empty
<li> each field is separated by a tab.
<li> &ltdate&gt is a  date.
<li> {&ltelement&gt}* is zero or more instances of a process element, each
separated by a tab character.
<li> &ltelement&gt, &ltdescription&gt, and &ltimpact&gt are all descriptions. 
</ul>

</blockquote>122<p><blockquote>
Example (with tabs replaced by spaces):
<pre>
# PCL file
1996/12/31 00:00:00  Added phase UserSurvey Improve yield code compile test
1996/12/31 00:00:00  Added phase Code-Rev Improve yield  compile test
</pre>

</blockquote>122<p><blockquote>

There are no requirements that the lines of this file must be sorted in any
order. Any required sorting of this information must be done by the tool.

<h3>The .prj file</h3>

Each .prj file contains project information.  The file is a
mixture of comment lines and project information lines. Each 
project information line has the following format:

<pre>
&ltproject&gt {&ltproject_info_file&gt}*
</pre>
where
<ul>
<li> any field may be empty
<li> each field is separated by a tab.
<li> &ltproject&gt is a description.
<li> there are zero or more occurrences of &ltproject_info_file&gt 
<li> &ltproject_info_file&gt is a description.
</ul>
</blockquote>122<p><blockquote>
Example:
<pre>
# Author: Philip Johnson
Olomana/2 /group/csdl/psp/newdev.phase /group/csdl/psp/newdev.doctype
Pali/2 /group/csdl/psp/newdev.phase /group/csdl/psp/newdev.doctype
</pre>

</blockquote>122<p><blockquote>
There are no requirements that the lines of this file must be sorted in any
order. Any required sorting of this information must be done by the tool.


<h3>The .phase file</h3>

Each .phase file contains a list of phases, one per line, in 
the following format:

<pre>
&ltphase&gt
</pre>
where
<ul>
<li> &ltphase&gt is a description.
</ul>

</blockquote>122<p><blockquote>
Example:
<pre>
# Author: Philip Johnson
# Last modified: 12/31/96
Plan
Design
Code
Compile
</pre>
</blockquote>122<p><blockquote>

The contents of the .phase file are assumed to be sorted according to 
the chronological sequence of phases in the process, if such a 
chronological ordering exists.


<h3>The .vphase file</h3>

Each .vphase file contains a pair of phases and 
their associated virtual phases, one pair per line, in 
the following format:

<pre>
&ltphase&gt &ltvphase&gt
</pre>
where
<ul>
<li> the phases are separated by a tab character.
<li> &ltphase&gt and &ltvphase&gt are descriptions.
</ul>

</blockquote>122<p><blockquote>
Example:
<pre>
# Author: Philip Johnson
# Last modified: 12/31/96
Plan    PreCompile
Design  PreCompile
Code    PreCompile
Compile Compile
</pre>
</blockquote>122<p><blockquote>

The .vphase file is used by the Time Trend tool. 

<h3>The .size file</h3>

Each .size file allows the user to store the size of work products
associated with a project in a manner that can used by 
analysis and evaluation tools. No assumptions are made about
the size metric other than that it be a numeric value. 

The .size file consists of a set of comment lines and size entry lines, 
where each size entry consists of the following:
<pre>
&ltproject&gt &ltdoctype&gt &ltsize_measure&gt &ltsize_val&gt
</pre>
where
<ul>
<li> &ltproject&gt, &ltdoctype&gt, and &ltsize_measure&gt are descriptions 
<li> &ltsize_val&gt is a number
</ul>

</blockquote>122<p><blockquote>
Example:
<pre>
# Current work product sizes for Pali/1 project
# Last modified: 12/31/96
Pali/1 SRS page 35
Pali/1 TestPlan page 23
Pali/1 Java LOC 244
</pre>
</blockquote>122<p><blockquote>

<h3>The .doctype file</h3>

Each .doctype file contains a list of document types, one per line, in 
the following format:

<pre>
&ltdocument_type&gt
</pre>
where
<ul>
<li> &ltdocument_type&gt is a description.
</ul>

</blockquote>122<p><blockquote>
Example:
<pre>
# Author: Philip Johnson
# Last modified: 12/31/96
SRS
Java
Lisp
</pre>
</blockquote>122<p><blockquote>

There are no requirements that the lines of this file must be sorted in any
order. Any required sorting of this information must be done by the tool.


<h3>The .deftype file</h3>

Each .deftype file contains a list of defect types to be associated with 
exactly one document type.  The file can contain comment lines.  Once
all comment lines are removed, the file must consist of a distinguished first line
containing the name of the document type in the following format:

<pre>
&ltdocument_type&gt
</pre>
where
<ul>
<li> &ltdocument_type&gt is a description.
</ul>

The remainder of the file consists of a list of defect type lines, where
each defect type line has the following format:

<pre>
&lttype_num&gt	&lttype_name&gt	&lttype_description&gt
</pre>
where
<ul>
<li> any field may be empty
<li> each field is separated by a tab.
<li> &lttype_num&gt is an integer.
<li> &lttype_name&gt and &lttype_description&gt are descriptions.
</ul>


</blockquote>122<p><blockquote>
Example (with tabs replaced by spaces):
<pre>
# Author: Philip Johnson
# Last modified: 12/31/96
SRS
10 Syntax Any syntax or grammatical error.
11 Spelling A spelling error
12 Parallelism An error where multiple verb tenses do not agree.
</pre>
</blockquote>122<p><blockquote>

There are no requirements that the lines of this file must be sorted in any
order. Any required sorting of this information must be done by the tool.


<h3>The .chkdef file</h3>

Each .chkdef file contains definitions of checklist items.  The file is a 
mixture of comment lines
and checklist definition lines. Each checklist definition line has the following format:

<pre>
&ltnum&gt &ltchecklist_name&gt &ltchecklist_procedure&gt
</pre>
where
<ul>
<li> any field may be empty.
<li> each field is separated by a tab.
<li> &ltnum&gt is a number.
<li> &ltchecklist_name&gt and &ltchecklist_procedure&gt are descriptions.
</ul>
</blockquote>122<p><blockquote>
Example (with tabs replaced by spaces):
<pre>
# Author: Philip Johnson
10 Inconsistency  Check each data item for inconsistency.
</pre>

</blockquote>122<p><blockquote>
There are no requirements that the lines of this file must be sorted in any
order. Any required sorting of this information must be done by the tool.

<h3>The .chkdata file</h3>

Each .chkdata file contains data on checklist item use.  The file is a 
mixture of comment lines
and checklist data lines. Each checklist data line has the following format:

<pre>
&ltdate&gt &ltproject&gt &ltdoctype&gt &ltchecklist_name&gt &ltchecklist_status&gt
</pre>
where
<ul>
<li> any field may be empty.
<li> each field is separated by a tab.
<li> &ltdate&gt is a date. 
<li> &ltproject&gt, &ltdoctype&gt, &ltchecklist_name&gt, and &ltchecklist_status&gt
are all descriptions. 
<li> 
</ul>
</blockquote>122<p><blockquote>
Example (with tabs replaced by spaces):
<pre>
# Author: Philip Johnson
1996/12/23 12:00:00 Pali/1 Java 10: Object Consist. Used
1996/12/23 12:00:00 Pali/1 Java 20: I/O Objects UnUsed
</pre>

</blockquote>122<p><blockquote>
There are no requirements that the lines of this file must be sorted in any
order. Any required sorting of this information must be done by the tool.



</blockquote>122<p><blockquote><hr>

<h2>Project Plan</h2>

The PSP/Baseline development project will be split up into a large number
of small, relatively autonomous subprojects. Each of these should
be developed as an independent PSP/Baseline project, using the 
normal time and defect measurement forms.  
</blockquote>122<p><blockquote>

All of these PSP/Baseline projects should follow this 
general procedure:
<ul>
<li> Follow the PSP/Baseline process phases and activities documented at
<A HREF="http://www.ics.hawaii.edu/~csdl/Primer/Baseline/">
http://www.ics.hawaii.edu/~csdl/Primer/Baseline/</a>.
<li> Use this SRS document as the requirements.
<li> The directory /group/csdl/csdlbase/ contains example data files.
<li> Establish a subdirectory in csdl/java/pspbase to hold all development work. In most
cases, the directory should be the project name without the version
information. For example, the Date/1 project should be developed within the
csdl/java/pspbase/date directory. 
<li> Develop a conceptual JavaDoc design specifying all classes
and methods for the specific project under development.
<li> Develop a detailed design (ASCII or HTML) specifying internal
representations and rationale (i.e. space or time or reliability performance goals). 
<li> Review conceptual and detailed design with Philip.
<li> Specify  regression test cases.
<li> Code, Compile, and Test system.
<li> Release system and regression test package.
</ul>

<em>Please do not start on any of these projects until you have
talked with me first. I want to make sure the (project and process)
requirements are relatively clear and correct before 
starting implementation activities. Thanks.</em>

</blockquote>122<p><blockquote>
<h3>SubProject Summary</h3>

Since there are a relatively large number of subprojects, here's a 
summary of their names and dependencies as currently specified:
</blockquote>122<p><blockquote>
<center>
<table border>
<tr><th>#<th>Name<th>Dependencies
<tr><td>0<td>Description/1 <td> none
<tr><td>1<td>Date/1<td> none
<tr><td>2<td>FileCheck/1<td>none
<tr><td>3<td>DateGUI/1<td>1
<tr><td>4<td>TimeLog/1<td> 0,2
<tr><td>5<td>DefectLog/1<td>0,2
<tr><td>6<td>PChangeLog/1<td>0,2
<tr><td>7<td>ProjectLog/1<td>2
<tr><td>8<td>DocTypeLog/1<td>2
<tr><td>9<td>PhaseLog/1<td>2
<tr><td>10<td>DefTypeLog/1<td>0, 2
<tr><td>11<td>TRLActiveEntryGUI/1<td>0,1,2,3,4,7,8,9
<tr><td>12<td>DRLActiveEntryGUI/1<td>0,1,2,3,5,7,9,8,10
<tr><td>13<td>PCLActiveEntryGUI/1<td>0,1,2,3,4,7,8,9
<tr><td>14<td>TRLLogGUI/1<td>0,1,2,3,4,7,8,9,11
<tr><td>15<td>DRLLogGUI/1<td>0,1,2,3,5,7,9,8,10,12
<tr><td>16<td>PCLLogGUI/1<td>0,1,2,3,5,7,9,8,10,12
<tr><td>17<td>ChkDefLog/1<td>0, 2
<tr><td>18<td>ChkDataLog/1<td>2
<tr><td>19<td>ReviewActiveEntryGUI/1<td>0,1,2,3,5,7,9,8,10,12,17,18
<tr><td>20<td>ReviewLogGUI/1<td>0,1,2,3,5,7,9,8,10,12,17,18,19
<tr><td>21<td>DefFreqGUI/1<td>0,1,2,3,5,6,7,9,8,10,12,17
<tr><td>22<td>DefTrendGUI/1<td>0,1,2,3,5,67,9,8,10,12,17
</table>
</center>

<h3>0. Description/1 Project</h3>

Requirements: 
<ul>
<li> Build a description.java class that implements encoding
and decoding of comment strings containing tabs and newline 
characters, as discussed previously in this SRS. 
<li> The class should have a regression test suite that tests
the encoding and decoding on all types of ASCII strings. 
</ul>
</blockquote>122<p><blockquote>
Project dependencies: None.

<h3>1. Date/1 Project</h3>

Requirements: 
<ul>
<li> Build a date.java class that implements all the functionality required
in the PSP/Baseline system for date creation, manipulation, and
file I/O, but not including the GUI interface.
<li> Build a duration.java class that implements all the functionality
required for duration creation, manipulation, and file I/O, but 
not including the GUI interface. 
<li> The date and duration classes must not only support all required
functionality, they 
must also be optimized for typical usage.  Analyze the PSP/Baseline
requirements to determine which operations on dates and 
durations occur most frequently and thus must be implemented efficiently.  
<li> Use the ECS date.el package as additional guidelines for what kinds
of operations on dates and durations are typically required.
<li> The date and duration classes must be fully documented and have a regression test
suite that fully exercises all functionality. 
<li> Input and output operations must be robust under error conditions.
</ul>
</blockquote>122<p><blockquote>
Project dependencies: None.


<h3>2. FileCheck/1 Project</h3>

Requirements: 
<ul>
<li> Build a FileCheck.java class that accepts any valid 
PSP/Baseline file, uses its extension (i.e. .phase, .drl, etc.)
to determine what kind of file it is, and verifies that the
file is syntactically valid according to the specifications
in this SRS.
<li> The system should be robust under various error conditions
(i.e. missing file, binary file, etc).
<li> The system should provide both a boolean response (true or false) as well as
a more informative error message (line number and invalid field
location).
<li> It would be nice if the system would not stop with the 
first syntactic error found, but rather try to find and report
on all lines with errors.
</ul>
</blockquote>122<p><blockquote>
Project dependencies: None.

<h3>3. DateGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a dateGUI class that provides 
     a button-based interface to the date class.  
<li> Build a durationGUI class that provides a button-based
     interface to the duration class.
<li> More than one GUI interface to the date and/or duration
     classes may be required, depending upon the context. 
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1 project must be released.

<h3>4. TimeLog/1 Project</h3>

Requirements: 
<ul>
<li> Build a TimeLog class that accepts a .trl file and builds an object
that provides programmatic access to its entire contents.
<li> The TimeLog class should be a container for a TimeEntry class that 
holds information related to one entry.
<li> Methods for all operations on TimeLog and TimeEntry objects implied by this
SRS must be provided, including
sorting, adding and deleting entries, writing .drl and .html files, and iteration through individual entries.
<li> The TimeLog class should be robust in the presence of File I/O errors.
<li> A TimeLog class instance should be able to be incrementally extended
with single TimeEntry class instances and with additional .trl files. 
</ul>

</blockquote>122<p><blockquote>
Project dependencies: FileCheck/1, Description/1.

<h3>5. DefectLog/1 Project</h3>

Requirements: 
<ul>
<li> Build a DefectLog class that accepts a .drl file and builds an object
that provides programmatic access to its entire contents.
<li> The DefectLog class should be a container for a DefectEntry class that 
holds information related to one entry.
<li> Methods for all operations on DefectLog and DefectEntry objects implied by this
SRS must be provided, including
sorting, adding and deleting entries, writing .drl and .html files, and iteration through individual entries.
<li> The DefectLog class should be robust in the presence of File I/O errors.
<li> A DefectLog class instance should be able to be incrementally extended
with single DefectEntry class instances and with additional .drl files. 
</ul>

</blockquote>122<p><blockquote>
Project dependencies: FileCheck/1.

<h3>6. PChangeLog/1 Project</h3>

Requirements: 
<ul>
<li> Build a PChangeLog class that accepts a .pcl file and builds an object
that provides programmatic access to its entire contents.
<li> The PChangeLog class should be a container for a PChangeEntry class that 
holds information related to one entry.
<li> Methods for all operations implied by this
SRS must be provided.
<li> The  class should be robust in the presence of File I/O errors.
<li> A  class instance should be able to be incrementally extended
with single PChangeEntry class instances and with additional .pcl files. 
</ul>

</blockquote>122<p><blockquote>
Project dependencies: FileCheck/1,  Description/1.

<h3>7. ProjectLog/1 Project</h3>

Requirements: 
<ul>
<li> Build a ProjectLog class that accepts a .prj file and builds an object
that provides programmatic access to its entire contents.
<li> The ProjectLog class should be a container for a ProjectEntry class that 
holds information related to one entry.
<li> Methods for all operations on ProjectLog and ProjectEntry objects implied by this
SRS must be provided.
<li> The ProjectLog class should be robust in the presence of File I/O errors.
<li> A ProjectLog class instance should be able to be incrementally extended
with single ProjectEntry class instances and with additional .prj files. 
</ul>

</blockquote>122<p><blockquote>
Project dependencies: FileCheck/1.


<h3>8. DocTypeLog/1 Project</h3>

Requirements: 
<ul>
<li> Build a DocTypeLog class that accepts a .doctype file and builds an object
that provides programmatic access to its entire contents.
<li> The DocTypeLog class should be a container for a DocTypeEntry class that 
holds information related to one entry.
<li> Methods for all operations implied by this SRS must be provided.
<li> The  class should be robust in the presence of File I/O errors.
<li> A  class instance should be able to be incrementally extended
with single entries and with additional .doctype files. 
</ul>

</blockquote>122<p><blockquote>
Project dependencies: FileCheck/1.


<h3>9. PhaseLog/1 Project</h3>

Requirements: 
<ul>
<li> Build a PhaseLog class that accepts a .phase file and builds an object
that provides programmatic access to its entire contents.
<li> The PhaseLog class should be a container for a PhaseEntry class that 
holds information related to one entry.
<li> Methods for all operations on PhaseLog and PhaseEntry objects implied by this
SRS must be provided.
<li> The PhaseLog class should be robust in the presence of File I/O errors.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: FileCheck/1.



<h3>10. DefTypeLog/1 Project</h3>

Requirements: 
<ul>
<li> Build a DefTypeLog class that accepts a .deftype file and builds an object
that provides programmatic access to its entire contents.
<li> The DefTypeLog class should be a container for a DefTypeEntry class that 
holds information related to one entry.
<li> Methods for all operations on DefTypeLog and DefTypeEntry objects implied by this
SRS must be provided.
<li> The DefTypeLog class should be robust in the presence of File I/O errors.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: FileCheck/1, Description/1.


<h3>11. TRLActiveEntryGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a TRLActiveEntryGUI class that provides 
     a window-based interface to a single active time recording log entry,
     as specified in this SRS.
<li> The TRLActiveEntryGUI should interface to both TimeLog and TimeEntry
classes: a TimeEntry instance should be displayable in the active entry
window, and the contents of an active entry should be able to be packaged
up as a TimeEntry instance and added to a TimeLog instance.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1, FileCheck/1, DateGUI/1, TimeLog/1,
ProjectLog/1, PhaseLog/1, DocLog/1, Description/1.

<h3>12. DRLActiveEntryGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a DRLActiveEntryGUI class that provides 
     a window-based interface to a single active defect recording log entry,
     as specified in this SRS.
<li> The DRLActiveEntryGUI should interface to both DefectLog and DefectEntry
classes: a DefectEntry instance should be displayable in the active entry
window, and the contents of an active entry should be able to be packaged
up as a DefectEntry instance and added to a DefectLog instance.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1, FileCheck/1, DateGUI/1, DefectLog/1,
ProjectLog/1, PhaseLog/1, DocLog/1, DefTypeLog/1, Description/1.

<h3>13. PCLActiveEntryGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a PCLActiveEntryGUI class that provides 
     a window-based interface to the PCL Active Entry window
     as specified in this SRS.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1, FileCheck/1, DateGUI/1, Description/1.


<h3>14. TRLLogGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a TRLLogGUI class that provides 
     a window-based interface to the time recording review log,
     as specified in this SRS.
<li> The TRLLogGUI should interface to the TRLActiveEntryGUI.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1, FileCheck/1, DateGUI/1, TimeLog/1,
ProjectLog/1, PhaseLog/1, DocLog/1, TRLActiveEntryGUI, Description/1.

<h3>15. DRLLogGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a DRLLogGUI class that provides 
     a window-based interface to the Defect Log Window,
     as specified in this SRS.
<li> The DRLLogGUI should interface to the DefectActiveEntryGUI.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1, FileCheck/1, DateGUI/1, DefectLog/1,
ProjectLog/1, PhaseLog/1, DocLog/1, DefTypeLog/1, DefectActiveEntryGUI/1, Description/1.

<h3>16. PCLLogGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a PCLLogGUI class that provides 
     a window-based interface to the PCL Log Window,
     as specified in this SRS.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1, FileCheck/1, DateGUI/1, Description/1.



<h3>17. ChkDefLog/1 Project</h3>

Requirements: 
<ul>
<li> Build a CheckDefLog class that accepts a .chkdef file and builds an object
that provides programmatic access to its entire contents.
<li> Other requirements as usual for a *Log class.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: FileCheck/1, Description/1.


<h3>18. ChkDataLog/1 Project</h3>

Requirements: 
<ul>
<li> Build a CheckDataLog class that accepts a .chkdata file and builds an object
that provides programmatic access to its entire contents.
<li> Other requirements as usual for a *Log class.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: FileCheck/1.


<h3>19. ReviewActiveEntryGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a ReviewActiveEntryGUI class that provides 
     a window-based interface to a single active defect recording log entry,
     as specified in this SRS.
<li> The ReviewActiveEntryGUI should interface to both DefectLog,
ChkDefLog, and ChkDataLog classes.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1, FileCheck/1, DateGUI/1, DefectLog/1,
ProjectLog/1, PhaseLog/1, DocLog/1, DefTypeLog/1, ChkDefLog/1,
ChkDataLog/1, Description/1.



<h3>20. ReviewLogGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a ReviewLogGUI class that provides 
     a window-based interface to the Review Log Window,
     as specified in this SRS.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1, FileCheck/1, DateGUI/1, DefectLog/1,
ProjectLog/1, PhaseLog/1, DocLog/1, DefTypeLog/1, DefectActiveEntryGUI/1,
ChkDefLog/1, ChkDataLog/1, Description/1.

<h3>21. DefFreqGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a DefFreqGUI class that implements the defect
     frequency analysis tool specified in this SRS.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1, FileCheck/1, DateGUI/1, DefectLog/1,
ProjectLog/1, PhaseLog/1, DocLog/1, DefTypeLog/1, DefectActiveEntryGUI/1,
PChangeLog/1, Description/1.

<h3>22. DefTrendGUI/1 Project</h3>

Requirements: 
<ul>
<li> Build a DefTrendGUI class that implements the defect
     trend process evaluation tool specified in this SRS.
</ul>

</blockquote>122<p><blockquote>
Project dependencies: Date/1, FileCheck/1, DateGUI/1, DefectLog/1,
ProjectLog/1, PhaseLog/1, DocLog/1, DefTypeLog/1, DefectActiveEntryGUI/1,
PChangeLog/1, Description/1.




</blockquote>122<p><blockquote><hr>

<h2>Current Unresolved Issues</h2>

<ul>
<li> Should the checklist menu be kept in the DRL or not?
<li> Should "Log" be kept as a generic button name, even though
it may appear multiple times in the same tool?
</ul>

</blockquote>

</BODY>
</HTML>
