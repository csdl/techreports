%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Latex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% citl.tex -- 
%% Author          : Philip Johnson
%% Created On      : Sat Sep 17 11:11:57 1994
%% Last Modified By: Philip Johnson
%% Last Modified On: Thu Oct 13 16:37:14 1994
%% Status          : Unknown
%% RCS: $Id$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Copyright (C) 1994 University of Hawaii
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 

\documentstyle[nftimes,/group/csdl/tex/lmacros,/group/csdl/tex/definemargins]{article}
\input{/group/csdl/tex/psfig/psfig}

\begin{document}

\title {Collaboration in the Small \\ vs. \\ Collaboration in the Large}
\author  {Philip M. Johnson\\
          Collaborative Software Development Laboratory\\
          Department of Information and Computer Sciences\\
          University of Hawaii\\
          Honolulu, HI 96822\\
          (808) 956-3489\\
          {\tt johnson@hawaii.edu}}

\maketitle

\section{Introduction}

For the past several years, the Collaborative Software Development 
Laboratory (CSDL) at the University of Hawaii has been
pursuing research along two general fronts: the development of computer
systems to support group activities (collaborative software), as well as
research on the process of developing software in a group setting
(collaborative development).  Our research projects include:

\begin{itemize}
\item Egret, a client-server system for implementing domain-specific,
  collaborative, hypertext systems
  \cite{egret-home-page,csdl-91-03,csdl-92-01,csdl-93-09};

\item CSRS, an Egret-based system for software review and quality
  improvement
  \cite{csrs-home-page,csdl-94-03,csdl-94-08,csdl-93-07,csdl-93-22,csdl-91-03,csdl-92-01,csdl-93-09};

\item AEN, an Egret-based system for 
     collaborative authoring and learning \cite{aen-home-page};
\item CLARE,  an Egret-based system
     collaborative learning and review \cite{clare-home-page,csdl-93-14,csdl-93-21,csdl-94-04}.
\item ICS-WWW, a WWW-based system
     for exploring community building through electronic means \cite{ics-www-home-page}.
\end{itemize}

From these experiences, we have begun to recognize two fundamentally different
styles of collaboration and collaborative system, which we term 
collaboration-in-the-large and collaboration-in-the-small.  

Collaboration in the large, embodied by such systems as WWW, scales to
thousands or millions of individuals.  Such domain-independent scale
requires a kind of collaborative "open world assumption": users do not know
the answers to such elementary questions as: Who are the other users?  What
is the set of artifacts in the system?  What has changed since yesterday?
What is interesting to me? Is the information repository structurally
consistent? What is user X doing right now?   

In contrast, the systems built by our lab exploit the possibilities of
domain-specific, collaboration-in-the-small where a ``closed world
assumption'' holds.  In our systems, in contrast to WWW, all of the
preceeding questions have answers, at least relative to the domain of
discourse embodied in the system.  The cost of collaboration in the small
is its lack of scalability both technically and socially: it is unlikely
that groups of more than 50 or 100 could work together effectively in our
systems, or that our system could provide adequate responsiveness to larger
groups.

\section{Architectural Implications}

Interestingly, collaboration-in-the-large vs. collaboration-in-the-small
appears not to be simply a question of usage style, but has basic
architectural implications.  These architectural issues provide a new way
of classifying CSCW systems that is orthogonal and complementary to the
traditional two-dimensional place/time classification system.  The basic
organizing principle for collaboration-in-the-large vs. collaboration in
the small appears to be {\em state}.

WWW, for example, is a fundamentally {\em stateless} architecture: the HTTP
protocol runs over a TCP connection that is held only for the duration of
one operation.  This stateless architecture is well suited to situations in
which links are equally likely to refer to the same server as the last
connection or to a different one. This stateless architecture is also
fundamentally {\em historyless}: the meaning of an action in a WWW client
such as Mosaic cannot depend in any important sense upon the results from
previous actions.  

Egret, on the other hand, is a fundamentally {\em statefull} architecture: 
the database server is connected to at least one active process for the entire
``life'' of the database, and both client and server state can be affected
by the actions of themselves or others, regardless of whether a client is 
connected or not when an action occurs.  This stateful architecture is 
also fundamentally {\em historyfull}: the meaning of an action in an Egret 
client can potentially have everything to do with the exact sequence of 
actions prior to the current one, not only by the current client, but
might potentially include all other client action sequences as well.  In
other words, the entire collective history of collaboration is potentially
available and can influence the meaning of actions. 

Here are the kinds of questions that distinguish a statefull architecture from a
stateless one:

\begin{itemize}
\item {\em What is the set of artifacts in the collaboration?}  A statefull
  architecture will be able to answer this query effectively.  Interestingly,
  the current set of artifacts in WWW is essentially unknowable. Not only
  that, the current ``structure'' of WWW is rife with inconsistencies,
  dangling pointers, and so forth.  Such structural problems are inevitable
  in a stateless architecture.

\item {\em What is the set of participants in the collaboration?}  Again,
  a statefull architecture can answer this question effectively, while a
  stateless architecture cannot.

\item {\em What is the behavior {\em B\/} of participant {\em P\/}?}  A
  statefull architecture can represent the history of actions by one
  participant and make some or all of that history available to other
  participants. (A simple example of a useful query along these lines is:
  tell me all the artifacts of mine that Bob has looked at since our last
  meeting.)  A stateless architecture lacks the capability of collecting
  that information and making it available when necessary.

\item {\em What were the artifacts at time {\em T\/}?} A statefull
  architecture represents and can answer queries about the history of the
  system, while a stateless architecture is trapped permanently in the
  present.

\item {\em Who were the participants at time {\em T\/}?}  Again, state
information is required for this kind of query.

\item {\em What was the behavior of participant {\em P\/} at time {\em T}?}
This also require state information.
\end{itemize}

It is clear from these questions that the decision to remain stateless and
historyless was crucial in the success of WWW in scaling to its global
size, and thus these omissions should not be looked at as oversights.  One
would not want to be able to enumerate in any effective manner the 10
million estimated current users of WWW, nor the millions of artifacts
potentially accessable.  


\section{Questions}

Our research group is only just beginning to articulate this perspective,
and many questions remain.  Please consider them with us:

\begin{itemize}
\item This classification of collaborative architectures as stateless and
  statefull appears to coincide well with collaboration-in-the-large
  vs. collaboration-in-the-small.  Does the correspondence bear up under
  closer scrutiny?

\item What is collaboration-in-the-medium?

\item Where do other systems, such as Lotus Notes or ConversationBuilder
  fit into this architectural classification?

\item How can a transition from statefull to stateless be made?  How can
  a transition from stateless to statefull be made?

\item There are many attempts to add greater collaborative functionality,
such as annotations and authoring, to WWW.  To the extent that these
collaborative functions require state, is this a fundamentally doomed endeavor?

\end{itemize}











\bibliography{/group/csdl/bib/csdl-trs,citl}
\bibliographystyle{plain}

\end{document}



 
