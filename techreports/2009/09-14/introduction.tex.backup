\chapter{Introduction}
Contemporary software projects typically have a considerably long life-cycle - 
well over decades, and their development and maintenance is usually carried out by 
teams which consist of often geographically distributed groups of people and individuals. 
Not only the project schedule and requirements change within this time frame, but 
the development pace, the experience, and the structure of these development 
teams continuously change as developers are joining and leaving. 
All these create numerous difficulties for stakeholders and project managers, ultimately 
affecting the project success. 

This phenomena, identified as ``Software crisis'' in 1968, was addressed by 
bringing the research and the practice of software development under the umbrella 
of Engineering in an effort to provide a control over the process of software development. 
Following the engineering paradigm, numerous \textit{models} of software processes were proposed.
Many of these models were extensively studied by researchers and adopted by practitioners, 
while the most efficient were accepted as industrial standards - CMMI, ISO, SPICE, and alike.
Today, these standards, guidelines, and recommendations ought to provide managers, teams, 
and individual developers with an ability to control their software processes.

However, despite to success of formalized approaches to manufacturing processes in other 
engineering fields, models of software processes perform somewhat poorly and 
do not deliver consistently. 
For example, the recent study by Standish Group (Rubinstein, ``Chaos Reports'', 2006) indicates that 
while `\textit{`Software development shops are doing a better job creating software than they were 
12 years ago}'', still, only ``\textit{35\% of software projects in 2006 can be categorized 
as successful meaning they were completed on time, on budget and met user requirements}‚Äù.

As alternatives to formalized, often top-down, software processes, the open-source software 
model (OSS) and the software craftmanship approaches gained a significant credibility among practitioners.
While the former \textit{holistic} software process paradigm emphasizes extensive collaboration, frequent releases 
and removes the boundary between developers and customers, the latter is focusing on the roles 
of highly motivated, creative and skilled individuals in a process of software creation. 

The existence of these distinct approaches and the vast amount of their application experiences 
ranging from success stories to complete failures continues to fuel the research community's interest. 
Not surprisingly, most of the research focused on formal software processes following business 
interests and the ability to perform experimentation in a controlled environment - where it is possible
to evaluate a proposed solution to a \textit{cherry-picked} problem. But, as pinpointed by 
van der Alast in \cite{citeulike:9758924}, the process inventors are often limited in their scope 
and tend to assume an idealized versions of real processes, thus producing ``paper lions'' - process models 
which are likely to be disruptive and unacceptable for end users, at least in their proposed form.

In my work, I attempt to explore an opposite, ``down-top'', non-intrusive, approach for the software 
process analysis - through the discovery of recurrent behaviors from software process artifacts trails. 
That is, by the analysis of software process artifacts, I attempt to infer the actual process that 
a developer or a team has followed.
Potentially, if there exists a mechanism allowing one to discover recurrent behaviors and associate
them with larger processes, it is possible not only to refine our understanding of the existing models, 
but to simplify and improve a process of design of novel software development methodologies.

My research rests on the previous contribution by many people to three research areas: 
software repository mining, time-series analysis, and information retrieval. By adopting current 
state-of-the art methods and practices from these domains, I have developed a generic workflow and 
implemented a software toolkit, that enables researchers and practitioners to discover significant 
recurrent behaviors.

In the next sections of this introductory chapter, I will introduce the research hypothesis and and 
briefly outline previous effort to software process research and discovery focusing on the known limitations. 
%
In chapter XX I describe the background of my exploratory study introducing software 
process artifacts and establishing relation with previous work in MSR field.
%
In chapter XX I describe and evaluate the novel, interpretable technique for time series classification which 
is used throughout my exploratory study.
%
In chapter XX I describe and evaluate the novel, interpretable technique for time series classification which 
is used throughout my exploratory study.
%
 Finally in Chapter 6
we conclude with a summary and describe future possibilities.

By applying data mining techniques to publicly-available software change repositories I 
introduce the concept of software process and software change entropy for quantifying development effort.
Presented in this thesis results from empirical studies of open-source projects identify development effort 
and software change patterns, present analysis and visualization methodology, 
and propose avenues for further research.

\section{Motivation}
Engineers build things and make them work by applying known theories, methods, 
and tools, appropriately and selectively, in systematic fashion, to reach the goal. 
It is also widely recognized, that the process of engineering is conducted 
within a restricted environment - engineers comply with organizational rules, 
financial restrictions, and schedule. Altogether - these methods and principles 
control the process of engineering, assuring it safety for life and property, 
and making engineering result predictable. Currently, engineering is considered to 
consist of four branches each of which consists of dozens of sub-disciplines. 
There are also numerous interdisciplinary 
engineering fields and many extensions as well. 

The new engineering discipline - Software Engineering (SE) was born in 1968, 
when the first NATO Software Engineering Conference was held. It is thought, 
that the assignment of computer programming into an engineering discipline 
was made with intent to bring that somewhat unpredictable and disorganized 
activities into the streamlined and controlled environment. 
Thus, similarly to many other engineering disciplines, Software Engineering was 
defined as the application of a systematic, disciplined, quantifiable 
approach to the design, development, operation, and maintenance of the 
final product - the software.
Delivering high quality software products within the budget and in 
time was set as the main goal and the most challenging task 
of Software Engineering.

As said before, back then, the Software Engineering thought to be not different 
from other engineering fields. Using existing engineering tradition, researchers 
and practitioners designed a number software development processes providing 
detailed guidelines on how to reach the goal efficiently and in time. 
These processes manifested themselves as the means for improvements in terms of quality, 
speed, and execution cost over existing practices. They were studied within academic 
settings and adopted by industry. Some of this processes were further standardized, 
shaping the best practices of contemporary 
software development \cite{citeulike:9962021}. 

The processes, that I am addressing here, found in numerous studies and described at length in 
academic and industrial literature. Too numerous to name, they can be categorized by the level 
of their application:
\begin{itemize}
 \item global organizational standards, like CMMI, ISO 9000, and SPICE. 
 \item large industrial software models, such as Waterfall, Spiral, Cleanroom, etc.
 \item smaller scale, flexible methodologies and agile approaches: XP, SCRUM, FDD, 
TDD, Pair Programming, etc.
 \item general guidelines and principles aiming to improve the software process flow, 
such as ``build before commit'' and others.
 \item and finally, there are processes for improving existing processes of software development 
on the organizational, team, and personal levels: TSP, PSP, Six Sigma, etc.
\end{itemize}
While some of these are products of a ``technology transfer'' - resulted by direct copying or by an 
application of existing engineering principles to software development process (like Waterfall model), 
some, and in particular agile methods, considered to be a software-engineering only processes. 

\section{Motivation}
As shown before, there are numerous software process, models, methodologies, and 
coding conventions exist for any level and any stage of the software development 
processes carried out by any arbitrary team size at any scale. 
This amount of well-grounded and documented knowledge creates an impression, 
that the area of software development process is thoroughly explored, 
and that there exists a deterministic choice for a model and a 
processes for any software project. 
In other words, the amount of our knowledge about how to engineer the software, 
leaves no doubts in the the faith of softare projects - that they will be completed 
succesfully. 

However, it is far from being true - software projects still fail at the considerably 
high rate and many unforeseen challenges exist in software product development.
This phenomena, also known as a ``software crisis'', was first recognized by Randell et al. in 1976 
\cite{naur1976software}. The attention was caught by the fact that many software projects ran 
over budget and schedule, some caused property damage \cite{citeulike:11044022}, and a few projects caused 
loss of life \cite{citeulike:712058}. Decades later, the ``Chaos Report'' from the Standish 
Group \cite{SDTimes} state, that only ``35\% of software projects in 2006 can 
be categorized as successful - meaning they were completed on time, on budget and met 
user requirements''. These thirty five percent of success clearly manifest that it is somewhat 
illusory statement that we are capable to understand and to control software processes.

This rather poor performance of the mainstream software engineering processes 
ignited a new wave of research in the field in recent decades. Gradually, researchers and 
practitioners alike recognized, that a direct application of classical engineering and a 
straightforward ``up-down'' software process governing might be somewhat erroneous. 
Also, it was recognized that over many years, continuous formalization of the field and 
excessive attention to software process metrics may malformed not only the software development 
practices landscape, but education and a professional code of conduct. 
This recognition forced some of the professional associations 
to review their licensing policies \cite{citeulike:11045517} and some educators to change their 
opinions \cite{citeulike:5203446}. 

In parallel with this search for industrial ``software crisis'' solution, another phenomena, 
the Open Source Software (OSS) 
development - an alternative software process arose and has proven its ability to deliver 
large, high quality software products. The OSS process is largely differ from typical SE process
on many levels - first of all it is carried out by a highly distributed community of people,
which significantly contradicts to developers collocation assumed by the most of the SE processes.
Secondly - OSS delivers a software free of charge and promotes its reuse, modification, and 
redistribution by anyone, moreover the OSS software is largely developed for a fraction of cost
of similar commercial projects. And finally, the OSS projects rarely governed by or can provide
any sort of documented software process. Yet, many OSS projects delivered large-scale, widely
adopted software systems fully comparable or superior to industrial projects.

Lately, third approach to software development emerged - software craftsmanship emerged 
\cite{citeulike:11058561}, \cite{citeulike:11058554}. The followers of this methodology 
are not only focused on the delivering ``well crafted'' software and continuously adding value,
but on the apprenticeship - on forming communities and engaging more people in software development.
While recommendation exists \cite{citeulike:11058784}, little known about the research 
in software craftsmanship and apprenticeship processes.

All this continues to engage thoughts and fuels the search not just for the exact definition 
of software development, but deep, fundamental for efficient processes resolving. 
Is software development an engineering discipline? Is it a craft \cite{citeulike:5203446}? 
Or is it an art \cite{citeulike:11045694}?

Answers to these questions would require extensive interdisciplinary studies to be made, 
but what is obviously clear, is that formal software development process, as an engineering 
is a creative, human activity. 
Whether software is coded 
by team where its members have a variety of skills and experience, or by a single individual,
they all driven by their believes and motivations. While usually developers agree on the use of 
particular technologies, development tools, and a development process with imposed timeline and 
a budget, the software process is - as many other human activities - highly creative and mostly 
non-recurring. Thus, the choice of methodology, technology, or tools provides only a marginal 
effect on this human-based and human-driven process. While this effect can be measured through 
the common approach by using a control environment factoring out human component, the most of 
the difference, which lies in human creativity, motivation and productivity is unknown and yet, 
mostly immeasurable.

\section{Research area overview}
\todo[inline]{here, describe in short the current state of the art and notable efforts which
shed light on the research area and identify a precise place where I am going.}
Here, lies a great room for the research and for improvement of our understanding of software 
processes. And my thesis is yet another attempt at the understanding of the role human activities 
in the software process. Before going further, I would like to emphasize, that in this work I will not 
address the need and means of the process synthesis, process quality assessment, productiveness
or any topics related to the software product itself; I would rather focus on the specific issue - 
on uncovering an existence and on studying the programming habits. 

