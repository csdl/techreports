\chapter{Introduction}
Contemporary software projects typically have a considerably long life-cycle well over decade, 
and their development and maintenance usually carried out by geographically distributed teams 
and individuals. The development pace, the experience, and the structure of these development 
teams continuously change as developers are joining and leaving. When combined 
often schedule and requirements changes, these create numerous difficulties for stakeholders
and project managers, ultimately affecting the project success. 

This phenomena, identified as ``Software crisis'' in 1968, was addressed by 
bringing the research and the practice of software development (or as it was called ``programming'') under the umbrella 
of Engineering in an effort to provide a control over the process of software development. 
Following the engineering paradigm, numerous \textit{models} of software processes were proposed.
Many of these models were extensively studied by researchers and adopted by practitioners, 
while the most efficient were accepted as industrial standards - CMMI, ISO, SPICE, and alike.
Today, these standards, guidelines, and recommendations ought to provide managers, teams, 
and individual developers with an ability to control their software processes.

Nevertheless, despite to success of formalized approaches to manufacturing processes in other engineering
fields, current state-of-the-art engineering-like models of software processes perform somewhat poorly and do not 
deliver consistently. 
For example, the recent study by Standish Group (Rubinstein, ``Chaos Reports'', 2006) indicates that 
while `\textit{`Software development shops are doing a better job creating software than they were 
12 years ago}'', still, only ``\textit{35\% of software projects in 2006 can be categorized 
as successful meaning they were completed on time, on budget and met user requirements}‚Äù.
Other problems with large models is the cost of their implementation and the rigidity. 
Once a project executed, the cost of incorporating a change not only becomes significant, but grows with time.

There exist a number of alternative software processes based on different to engineering principles. 
Among others, the open-source software model (OSS) and the software craftmanship approaches gained a 
significant credibility among practitioners.
While the former \textit{holistic} software process paradigm emphasizes extensive collaboration, frequent releases 
and removes the boundary between developers and customers, the latter is focusing on the roles 
of highly motivated, creative and skilled individuals in a process of software creation. 
\todo{in fact I want to tell about their }

The existence of these distinct by nature approaches and the vast amount of their application experiences 
ranging from success stories to complete failures continues to fuel the research community's interest. 
Not surprisingly, most of the research focused on formal software processes following business 
interests and the ability to perform experimentation in a controlled environment - where it is possible
to evaluate a proposed by a researcher or a practitioners solution to a \textit{cherry-picked} problem. 
But, as pinpointed by  van der Alast in \cite{citeulike:9758924}, the process inventors are often limited in their
scope and tend to assume an idealized versions of real processes, thus producing ``paper lions'' - 
process models which are likely to be disruptive and unacceptable for end users, at least in their proposed form.

In my work, I attempt to explore an opposite, ``down-top'', non-intrusive, approach for the software 
process analysis based on the discovery of recurrent behaviors from software process artifacts trails. 
Potentially, if there exists a mechanism which facilitates the discovery of recurrent behaviors, 
it might be possible to associate these with building blocks of larger processes and not only to 
refine our understanding of the existing models, but to simplify and improve a process of design of 
novel software development methodologies.

Finding the way of discovering recurrent behaviors and quantifying their significance is proven to be 
not a trivial task. A number of challenges was identified by previous research, and in particular, it
was pointed out that it is not only difficult to quantify the significance of discovered behaviors, 
but it also hard to interpret the findings. 

\section{Research problem statement and scope}
Software is coded by humans. Whether in team or individually, we perform relevant daily activities 
in order to reach the goal - to deliver a software. In the same time, we perform other kinds of activity

Understanding of these human activities spanning through the life-cycle of the software, 
in connection with personal and team's motivations, environment settings and various constraints enables one to
comprehend the software process. It is worth noting, that roughly \todo[inline]{put here something 
about two components - the human-driven, non-recurrent and creative activity - 
the behavioral component - and the process and the technology/toolkit component which
provides a measurable marginal effect}
\todo[inline]{Here, put stuff about observing the process and artifacts availability}

\todo[inline]{Here, put stuff about time-series analysis flexibility and its difference from 
convenient process mining.}

While it is shown by the large body of previous research, that it is technically possible 
to factor out the impact of the technology and the process, the impact of the behavioral 
component is yet to be studied. Hence, my primary research question is this:
\begin{myindentpar}{0.07\linewidth}
 \textbf{Can we discover recurrent behaviors in software processes from project
  repository artifacts?}
\end{myindentpar}

Obviously, in order to answer this question correctly two interconnected, secondary, question must be resolved:
\begin{myindentpar}{0.07\linewidth}
 \textbf{Which kind of software process artifacts reflect recurrent behaviors?}
\end{myindentpar}
\begin{myindentpar}{0.07\linewidth}
 \textbf{Which data-mining method is sensitive and selective enough to recover recurrent behaviors
from software process artifacts?}
\end{myindentpar}
These two can be broken down further to the problem of studying and classifying of software process artifacts,
methods of their extraction and partitioning, and, of course, the problem of recurrent behaviors discovery.

As was mentioned above, in this thesis I am focusing on a very narrow subject - exploring approaches
for uncovering of recurrent behaviors or ``programming habits'' out of software process artifacts.
While I will show, that, potentially, many software-development activity behaviors can be recovered,
their classification, impact and performance studies are beyond the scope of this thesis.



\section{Contributions}
I show a novel, generic algorithm for interpretable time series classification: SAX-VSM. 
While the performance of this algorithm is at the level of current state of the art, it offers an outstanding feature -
discovery, generalization and ranking of class-characteristic structural features. This feature, in turn, enables
knowledge discovery by offering much clearer insight into data specificity than any other competing technique.
In addition, SAX-VSM uses only N weight vectors for classification of unlabeled data by computing N cosines, where N is
a number of classes, - therefore it is very fast and has a very small memory footprint.
Overall, I expect this algorithm to play an important role in future because of the growing ubiquity of time series and
growing interest in behaviors.

I provide SAX-VSM implementation to the community. This implementation uses several computational tricks to optimize,
reduce, and reuse computation. Within last years, this implementation was regularly downloaded and used in academia and
industry. 

Powered by SAX-VSM, through the application of Software Trajectory Analysis (STA) to software process artifacts, I show
through the case studies: that it is possible to discover known recurrent behaviors, thus positively confirming the
research hypothesis. In the PostgreSQL study I was able to discover characteristic recurrent behaviors in source code
editing churns corresponding
to Software release and to the Commit Fest processes.
that STA and SAX-VSM can be used as a knowledge discovery tool in the StackOverflow case study. In particular, I show,
that the temporal primitives discovered by the algorithm provide not only quantitative evidence for processes
interpretation, but can be used for a qualitative assessment of discovered recurrent behaviors.
In Android case study...

Finally, I provide an implementation of STA analysis framework to the community. 

\section{Organization of the dissertation}