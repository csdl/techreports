\begin{abstract}
%Abstract goes here if needed.
Contemporary software projects typically have a considerably long life-cycle - 
well over decades, and their development is usually carried out by teams, which
consist of geographically distributed groups of people and individuals. 
The development pace, the experience, and the structure of a development team 
continuously change over software project life-cycle as it is passing through 
milestones and as developers are joining and leaving. All these create numerous 
difficulties for stakeholders and project managers, ultimately affecting the 
project success.

Currently, it is widely recognized, that the success of each of software projects is 
heavily affected by the complexity and unpredictability of individual and collaborative 
software processes. In an effort to control these processes, and in order
to bring software projects to success, the research and the practice of software 
development were brought under the umbrella of Engineering. Since then, following
the engineering paradighm, many formal models of software processes were proposed.
Many of these models were studied by researchers and adopted by practitioners, 
while the most efficient being accepted as industrial standards, such as CMMI, ISO, and SPICE.
Today, formal process models, standards, guidelines, and recommendations provide 
managers, teams, and individual developers with ability to control their software processes.
They also allow a great flexibility for every project needs, and exist for any of project 
scale, hierarchy level, or a lifetime stage.

Nevertheless, all of these knowledge is not proven to deliver consistently. Moreover, 
any of these models and methodologies fail with equal probability. This phenomena was widely 
observed observed over years and firstly identified as a ``Software crisis'' 
in 1968. Recently, the study by Standish Group (Rubinstein, ``Chaos Reports'', 2006) 
indicates that while `\textit{`Software development shops are 
doing a better job creating software than they were 12 years ago}'', still, only 
``\textit{35\% of software projects 
in 2006 can be categorized as successful meaning they were completed on time, 
on budget and met user requirements}‚Äù.

Ultimately, project managers, researchers, and educators recognize, that despite 
all of the effort aiming on the understanding and control of software processes, 
our knowledge is far from being complete. This defficiency has a significant impact 
on the software development industry making it highly error-prone.
The existence of unforeseen challenges in a course of software development, results in 
poorly executed projects: some of them are abandoned due to running over budget, 
some are delivered with such low quality or so late, that they are useless, 
and some, when delivered, are never used because they do not 
fulfill requirements. The cost of this lost effort is enormous and may in part be 
due to our incomplete understanding of software process.

Recently, as an alternative to classical engineering approach to this problem, 
the open-source software model (OSS) gained a significant credibility, as well as 
the software craftmanship approach. While OSS software process paradigm emphasizes extensive 
collaboration, frequent releases 
and removes the boundary between developers and customers, the craftsmanship approach 
is focused on the roles of highly motivated, creative and skilled individuals in software creation. 

However, software processes taught by these three schools, while supported by research work 
and industrial success stories, mostly follow a conventional ``top-down'' technique - at first someone has to invent a
process, design and implement its building blocks and empirically evaluate it after. 
The problem with this approach clearly shown by van der Alast in \cite{citeulike:9758924} - 
the process inventors, limited in their scope, always assume an idealized versions of real processes 
and tend to produce ``paper lions'' - process models which are likely to be disruptive and 
unacceptable for end users, at least in their proposed form.


In my work I attempt to explore an opposite, ``down-top'' approach for the software process analysis - 
through the discovery of recurrent behaviors (habits) from software process artifacts trails.
Potentially, if there will be a mechanism in place allowing one to recognize recurrent behaviors and associate
them with successful larger processes, it is possible not only to refine existing formal models,
but to design novel software development methodologies.

My research rests on the previous contribution by many people to three research areas: software repository 
mining, time-series analysis and knowledge discovery through the text mining. By adopting current 
state-of-the art methods and practices from these domains, I have developed a methodology and implemented 
a toolkit enabling researchers and practitioners to discover significantly supported recurrent behaviors. 
By applying data mining techniques to publicly-available software change repositories I introduce the concept 
of software process and software change entropy for quantifying development effort.
Presented in this thesis results from empirical studies of open-source projects identify development effort 
and software change patterns, present analysis and visualization methodology, 
and propose avenues for further research.

\end{abstract}