\section{Motivation}

As with baseball, physics, music, and other skillful human endeavors, there
is a vast range of ability associated with software development.  For
almost 40 years, software development researchers have been attempting to
understand, measure, and support the development of superior skill in
software development.  Sackman performed the seminal research on programmer
productivity in 1967, in which he reported a 28:1 difference between the
slowest and fastest programmers on a programming task.  Subsequent research
by Prechelt on a larger dataset indicates a smaller but still significant
multiple (from 2:1 to 6:1 depending upon conditions and the kind of
statistical comparison used).  

An alternative way to assess programmer productivity variability is with
the COCOMO II cost estimation model, where a set of parameters describing
characteristics of the programming team affect the predicted effort.  In
COCOMO, the effort differential between best and worst programming teams with
respect to capability is 3.53, applications experience is 1.51, language
and tools experience is 1.43, platform experience is 1.40, and team
cohesion is 1.29.  Multiply these together, and the COCOMO dataset
indicates a theoretical productivity difference of 13:1 between the most
suited and least suited programming teams for a given software project.

Of course, one can also argue that there is infinite variability between
programmers, since certain kinds of programming tasks are so challenging
that some programmers will never complete them no matter how much effort
they invest. (For example, in a private correspondance with a former member
of a tool development team for a major vendor, he indicated that his
product was inferior to a competitor's and most likely would remain so
regardless of the resources expended, because the competitor's team lead
was such a gifted designer.) However, to simplify the discussion, we will
focus on variability within a population of programmers who are all capable
of eventually satisfying the requirements for the system.

Programmer variability creates two basic kinds of challenges for the
software engineering research community: how to raise the average
productivity of software developers, and how to reduce the variability
between the best and worst.  In general, we respond to these challenges in
one of three ways: through abstraction, automation, or routinization.  The
evolution of programming languages from machine language to assembly
language to high level languages to executable specification languages
exemplifies the successful application of abstraction to improving the
average productivity of software developers by reducing the amount and
complexity of code required to accomplish a given task.  




