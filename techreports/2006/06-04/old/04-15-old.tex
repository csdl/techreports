%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Latex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 04-15.tex -- Thesis Proposal for Ph.D
%% Author          : Hongbing Kou
%% Created On      : Mon Sep 23 11:52:28 2002
%% Last Modified By: Hongbing Kou
%% Last Modified On: Tue Sep 28 13:49:42 2004
%% RCS: $Id$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Copyright (C) 2004 Hongbing Kou
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 


\documentclass[11pt,twocolumn]{article}
\input{/export/home/csdl/tex/psfig/psfig}
\usepackage{/export/home/csdl/tex/icse2003/latex8}
\usepackage{times}
%% A verbatim-like environment which allows font changes
%%\usepackage{alltt}
%% New LaTeX2e graphics support
\usepackage[final]{graphicx}
\usepackage{url}
%% \usepackage{rotating}
% uncomment the % away on next line to produce the final camera-ready version
% and uncomment the \thispagestyle{empty} following \maketitle
\pagestyle{empty}

\begin{document}

\title{Test-Driven Development Process Recognition and Evaluation}
\author{\protect\begin{tabular}{ccc}
Hongbing Kou\\
\end{tabular}\\
\em Collaborative Software Development Laboratory\\
\em Department of Information and Computer Sciences\\
\em University of Hawai'i\\
\em Honolulu, HI, 96822\\
\em hongbing@hawaii.edu}
\maketitle
\thispagestyle{empty}

\begin{abstract}
  ``Test-Driven Development (\textbf{TDD}), also called Test-First Design
  (\emph{TFD}), is a software development practice in which test cases are
  incremently written prior to code implementation\cite{George_2003}''.
  It's part of e\textbf{X}treme \textbf{P}rogramming. The rational of TDD is to
  ``analyze a little, test a little, code a little and test a little,
  repeat.'' This work is to recognize TDD-style development process
  consists of many \textbf{R}ed/\textbf{G}reen/\textbf{R}efactoring iterations by
  analyzing the development activity streams. Upon successful this research
  will provide the inspection support and help TDD practitioners
  continuously improve the development process in a measuable approach.
\end{abstract}

\Section{Introduction}
\label{sec:intro}

``Test-Driven Development (TDD) is a software development practice in which
test cases are incrementally written prior to code implementation.''
\cite{George_2003} Here test case is the unit test, which is a piece of
code written by a developer that exercises a very small, specific area
functionality of the code being tested. The rational of TDD is to ``analyze
a little, test a little, code a little, and test a little, repeat.'' The
goal of TDD is to write ``clean code that works''\cite{Beck_TDD_2003} and
it has two basic rules. \cite{Beck_TDD_2003}:

\begin{enumerate}
  \item Write new code only if an automated test has failed.
  \item Eliminate duplication (Refactoring).
\end{enumerate}

They imply an order to do programming task \cite{Beck_TDD_2003}:
\begin{enumerate}
\item \emph{Red}\newline Write a little test that does not work, and
  perhaps does not even compile at first.
\item \emph{Green}\newline Make the test work quickly, committing whatever
  sins(for example, constant, fake implementation) necessary in the
  process.
\item \emph{Refactor}\newline Eliminate all the duplications created in
  merely getting test work.
\end{enumerate}

In book ``Test-Driven Development by Example'', Ken Beck claimed that
red/green/refactor rhythm is the mantra of TDD, once you have an automated
suite of tests you will never go back. It gives incredible confidence in
your code. He also mentioned that TDD will naturally generate 100\% code
coverage and a coverage tool is not necessary at all if you do TDD
perfectly.  Unit tests are very important to software development because
it makes it easy to check whether the application works well or not. It
allows the programmer to refactor code at a later date, and be sure the
system still functions properly\cite{UnitTest}. Also the automatic unit
test suite created in the development process could be used as regression
tests. And ``a unit test behaves as executable documentation, showing how
you expect code to behave under the variation condition you've
considered.''\cite{Andy&Dave_2003}

In general software development unit test is not a must and is usually done
as an afterthought. Occasionally no tests are created at all, especially
with tight schedules. With TDD, before writing implementation, the automated
unit tests are written first and they are created on the ground of
requirement analysis, which leads to better and effective test suites.

However, in reality, software developers are educated to program first and walk
through the program to make sure the system works well to the dedicated
scenarios. In professional development a special test team might be assigned to
test the system against customer requirement analysis or system design. As
a new and counter-intuitive approach TDD requires discipline, training and
tool support. Kent Beck suggested the ``xUnit'' framework, which has
the following structure:

\begin{enumerate}
\item Invoke test method
\item Invoke setUp first
\item Invoke tearDown afterward
\item Invoke tearDown even if the test method fails
\item Run multiple tests
\item Report collected results
\end{enumerate}


``xUnit'' has many variances and it has been ported to more than 30
languages' support\cite{XPSoftware}. xUnit is a very light-weight tool and
it can be mastered by a novice programmer in a short while; however, the
limitation is that not every aspect of an application can be tested by xUnit
framework easily.  For instance, the applications such as graphic user
interface, socket programming, parallel computation, and database querying
need a lot settings and have many dependances on other systems to
function. It is hard to write small unit test to deploy them or not
practical at all. TDD practitioners suggest mock technique to mock up the
real operations for test purpose. Mock technique is still under development
and is welcomed by many practitioners in daily programming work. Mocking
makes it easy to test the complicated, time consuming or user involved
operations with small amount of effort.

Boby George's study of test-driven development concluded that both students
and professional TDD developers appear to have higher code quality
\cite{George_2002}. E. Michael Maximilien and Laurie A.  Williams found
that defect rate of project IBM Retail Store Solution was reduced by 50\%
compared to another system built with ad-hoc unit test approach
\cite{Maximilien_2003}, and TDD developers passed 18\% more functional
black-box tests than non-TDD developers.

\Section{Test-Driven Development Viewer and Application}
\label{sec:app}

This work is on the ground of Hackystat, which is a framework of automatic
development metric collection and analysis. In Hackystat, sensors or plugin
are attached to development tools such as Eclipse, JBuilder, or Emacs to
record the development activities and associated metrics. For TDD research
purpose not only the editing and test activities but also the refactoring
activities are recorded for us to do development activity stream analysis.
The latest edition of Hackystat Eclipse Sensor already has the capability
to collect unit tests exercises, compilation error, and refactoring
activities such as adding or deleting class/method/field, renaming
class/method/field, moving class between packages etc. In the future we may
add more activity types after we understand development activity stream
well.

I already implemented the so-called ``TDD Viewer'' to observe and
study the TDD-alike development stream. Figure \ref{fig:TDDViewer} shows the
TDD stop-light pattern:

\begin{figure*}[ht] 
  \centering 
  \includegraphics[width=1.0\textwidth]{TDDViewer.eps}
  \caption{TDD Activity Stream on June 9, 2004}
  \label{fig:TDDViewer}
\end{figure*} 

Red bar is either test error or failure and green bar means successful test
run. The compilation or build error will be yellow bar and cyan bar stands
for refactoring on java objects, which could be class/field/method
addition, renaming, deletion or moving from one package to another. In this 
model refactoring is not an isolated step as the TDD mantra, it happens
in the entire software development process. TDD viewer helps us to
visualize the development process and we can use it to interpret
software development activities. Next step is to implement the
quantification analysis over the activity stream to validate the research claims. 

\Section{Research}
\label{sec:research}
Software process has been introduced into software engineering field since
the Capability Maturity Model (CMM), which helps the stakeholders to
evaluate software contractors' development process. Generally software
process provides a series of guideline on how to develop software
successfully. Personal software process, team software process, rational
unified process and various extreme programming models are some well known
software process.

There are some substantial empirical studies on TDD and the unanimous
conclusion is that it helps to improve software quality. In these papers
the emphesis is on how they designed experiments and what kinds of result
they yielded at the end in their settings. As we experienced in our
development of Hackystat we have found that a lot of aspects in software
cannot be unit tested easily or it is too hard to test some aspects such
that developers gave up unit tests. This gap is either from test
difficulties or lack of discipline to execute the designated plan. The
previous experiments failed to address this issue. Hackystat provides a
light-weight approach to collect development activities andmetrics such
that we can step forward to study what is happening in the software
development and helps the developers to continuously improve test-driven
development process.

\Section{Methodology}
\label{sec:method} 
My claim is that fully test-driven development is ideal but developers
cannot achieve it rigorously. With the TDD viewer and related analyses we
aim to let the developers inspect the development process, be aware of how
well they are doing and know how to improve their process. To achieve this
goal I already implemented TDD viewer which still needs to be refined and a
series of analyses such as abnormal activity identification and locating,
quantification analysis based on rules, correlation between software
quality (blind test and comparison study) and development streams are to be
created.

The empirical study will be applied to classroom setting in software
engineering class. For comparison we enourage student to work in
TDD and also allow some of them to work on their projects in ad-hoc
manner as controlled group. As to my understanding it is better to let
every group work on same project to reduce the variations brought by
projects' difference.

\bibliography{/export/home/csdl/bib/tdd,/export/home/csdl/bib/csdl-trs}
\bibliographystyle{plain}

\end{document}













