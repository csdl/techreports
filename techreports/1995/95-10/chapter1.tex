%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -*- Mode: Latex -*- %%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter1.tex -- 
%% Author          : Philip Johnson
%% Created On      : Tue Mar 14 08:56:59 1995
%% Last Modified By: Philip Johnson
%% Last Modified On: Thu Sep  7 11:14:26 1995
%% Status          : Unknown
%% RCS: $Id$
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%   Copyright (C) 1995 University of Hawaii
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 

\chapter{Introduction}

\section{Collaborative systems: the spreadsheets of the '90s}

If the 1980's were the era of the ``personal computer'', the 1990's are the
era of the ``collaborative network.''  In just a few short years, the
Internet and the World Wide Web have begun to fundamentally change the
public's perception of computers: from a mechanism used to automate tasks
for individuals, computers are now becoming perceived as a mechanism for 
communication and coordination of people spread across offices,
towns, countries, and the earth.

Loosely stated, this transformation in the nature of computers is the focus
of the field of computer supported cooperative work (CSCW). Drawing
together practitioners from the fields of psychology, sociology,
anthropology, management information systems, computer science, and other
disciplines, CSCW concerns the impact that computers have upon the work of
groups, as well as the work of groups upon the design and implementation of
computer systems.  

Some primitive collaborative software is already in widespread use today.
Electronic mail and news groups are ubiquitous and extremely successful
examples of collaborative software.  Yet they are, in a real sense, only
the ``assembly languages'' of collaboration: primitive, powerful, yet
lacking high-level structure, process, and mechanisms.  To illustrate this,
imagine that you are charged with collaboratively developing a complex
document, communicating various changes and revisions to different members,
and involving outside experts at various points along the way in a
structured fashion. In this situation, e-mail or newsgroups provide little
support for coordination and control of the process outside basic data
transport. A useful collaborative system would ``know'' about the people
involved in the project, their responsibilities, and their activities, and
use this knowledge to help each member work with each other more
effectively.  In the coming years, the design and application of ``higher
level languages'' for collaborative systems will transform the way people
use computers as surely as spreadsheets and point-and-click interfaces did
in the past decade.

This book
introduces you to Egret, one such high level language for
collaboration. Egret is a distributed, hypertext, client-server-agent
framework that has been used since 1990 to develop collaborative applications
for learning, authoring, software review, news reading, and other areas.
\foot{More information about these systems is available from the WWW Home Page of our
research group, the Collaborative Software Development Laboratory (CSDL) at
the University of Hawaii <http://www.ics.hawaii.edu/~csdl/>.}.  Egret's
current design and functionality is a direct reflection of the (sometimes
painful) lessons we've learned about collaborative systems during the
past five years. This book escorts you on a programmatic
guided tour of Egret, stopping to point out particularly interesting sights
and sounds, as it teaches you to build collaborative systems of slowly
increasing complexity, sophistication, and power.

This stroll through Egret will create many opportunities to learn about
general issues that arise in building collaborative systems regardless of
the software development environment chosen.  For some of these issues,
Egret provides an elegant solution, for others, Egret merely
``satisfices'', for still others, Egret provides no insight.  No software
architecture is perfectly suited to every application context, and Egret is
no exception.  Both the successes and failures of the Egret architecture
will contribute to your understanding of the engineering of collaborative
systems.


\section{Strengths and limitations of this book}

One strength of this book is the active involvement of the reader in the
process and products of collaborative system building.  This book teaches
you about collaborative system building by enabling you to build
collaborative systems. While each example system is itself small and
relatively simple in scope, substantial power and sophistication can result
from their combination.  For example, various components of Egret support
shared, persistant data structures, real-time communication, and URL
retrieval and parsing.  By combining these building blocks, you could build
a collaborative system that not only allows a group to ``surf the net''
together in real time, but also stores their adventures for others to
examine, recreate, and extend at a later time.  Those who finish this
tutorial guide will acquire familiarity with a powerful software
toolkit for leveraging both networks of people and groups of computers.

A second strength of this book is its unabashedly heavy emphasis on the
software engineering of collaborative systems.  A major result of
development efforts in the Collaborative Software Development Laboratory
(CSDL) has been the creation of a style for collaborative system design and
implementation. Indeed, software engineering itself is intrinsically
collaborative: its very definition is the discipline of supporting teams in
the development of robust and reliable software systems.  This book
introduces you to the CSDL style of development, one that emphasizes
modularity, object orientation, software quality assurance, and
collaborative review and critique.  Collaborative systems are naturally
built in a collaborative fashion.

A limitation of this book is that it does not attempt to provide a
comprehensive introduction to all forms of collaborative systems.  The
arena of collaborative systems is spectacularly large, encompassing
collaborative hypertext systems, shared whiteboards, mobile computing,
shared screens, and so forth.  Instead of a broad survey orientation, this
book focusses on providing the user with concrete experience building Egret
collaborative applications.  Egret embodies the following design
assumptions about the nature of collaborative systems for which it is well
suited:

\begin{itemize}
\item {\em Egret supports collaborative construction and manipulation of
  artifacts that are primarily textual.}  Although Egret allows storage
  and retrieval of graphical objects, audio, and other binary data, it
  does not itself provide any built-in support for collaborative
  construction and modification of non-textual kinds of artifacts.  For
  example, it is not easy to build a shared whiteboard application in
  Egret.

\item {\em Egret provides collaborative services to support
  efficient storage, retrieval, and manipulation of state information.}
  Perhaps the most fundamental design assumption in Egret is that ``state
  is important for collaboration.''  In other words, for
  sophisticated collaborative applications, the system must exploit
  awareness of the current state of each user, the current state of the
  collaborative activity, the current state of the artifacts being
  constructed collaboratively, and any state information related to the
  specific application domain.  

  For example, in the domain of software review, the Egret-based CSRS
  system represents and manipulates the review roles associated with each
  user, the nature of the artifacts being reviewed and their history, the
  current phase of review and the outcome of previous phases, and the
  tendency for review process requirements to evolve over time.  In
  contrast, systems like the WWW support essentially ``stateless''
  collaboration: groups of people can use the WWW to work together by
  sharing data, but the system itself does not represent any information
  about the process or nature of this group work.

\end{itemize}

While the first design assumption limits the application areas for Egret,
we believe the second assumption is a deeply general characteristic of
any collaborative system.  Thus, learning how Egret supports storage,
retrieval, and manipulation of state information is valuable if you are
later charged with developing a collaborative application for some
non-textual domain. 


\section{How does this book work?}

Egret is a layered architecture: the bottom layer is called the Server
Subsystem and provides core functionality for defining shared storage,
hypertext nodes and links, concurrency control, and event-based
inter-client communication.  Subsequent layers provide a typed hypertext
data model, high-level interface mechanisms, measurement facilities, and
interfaces to network services like WWW, mail, and news.  Each of these
layers are implemented as additional Egret subsystems.

This book is constructed in a similarly layered fashion.  For example, the
next chapter consists of about a dozen sections which sequentially
introduce you to the major facilities of the Server subsystem.  Each
section consists of a complete description (including implementation and
example usage) of a small system which illustrates one important concept or
tool in the building of collaborative applications.  After reading the
material and playing with the system interactively, the exercises lead you
through several interesting extensions and/or variations on the concept.
Subsequent chapters repeat this approach for the next two subsystems in
Egret.  

The appendix provides background information on the style of object orientation
used in Egret and its applications, tool support for this book, and other
supplementary information.

\section{Required background and infrastructure}

This book requires basic familiarity and availability of Unix, basic
familiarity and availability of Emacs, and basic familiarity with Lisp. (No
Common Lisp system is required: the Lisp environment built-in to Emacs is
used in Egret.)

\begin{itemize}

\item {\em Unix.}  Egret's server system, called HBS, is currently
  available for both SunOS and Solaris flavors of Unix. (We expect to port
  HBS to Windows-NT at some point in the future.)

\item {\em Emacs.}  Egret's client/agent system, called ECS, is currently
  available for XEmacs.  XEmacs (and thus ECS) is available on virtually all
  flavors of Unix.  (A variant of XEmacs, called Win-Emacs, is available
  for MS-Windows.  We anticipate porting ECS to Win-Emacs at some point in the
  future.)

\item {\em Lisp.}  All of the software development exercises in this
  book are written in Emacs Lisp using a Common Lisp compatibility
  package. Thus, some knowledge of any Lisp dialect is very useful
  background knowledge for this book.  If you do not know any Lisp, a
  good interactive introduction to Emacs Lisp is {\em Programming in
  Emacs Lisp: An Introduction} by Robert Chassell, available through
  the Free Software Foundation.  XEmacs also provides
  an excellent on-line reference guide to Emacs Lisp in its info menu.

\end{itemize}

\subsection*{But I don't like Unix, Emacs, OR Lisp!}

That's fine; some of our best friends use Visual Basic and
Windows :-).  In all serious, this book addresses two audiences:

\begin{itemize}

\item Those who wish to develop advanced collaborative systems using
  Unix, Emacs, and Lisp, who desire a high-level platform for their
  implementation efforts using this infrastructure.

\item Those who wish to gain insight into architectural issues and design
  trade-offs in multi-user, interactive, client-server-agent systems, so
  that they can better design collaborative systems with any given
  infrastructure.

\end{itemize}

Obviously, this book is tailor-made to the first audience.  However, we
believe it is also tailor-made to the second audience precisely {\em
because} of its infrastructure decisions! Here are several reasons.

First, a minimal Egret collaborative system requires four concurrent
processes: one HBS server, one ECS agent, and two ECS users (remember, it
takes two users to be collaborative).  Typical Egret systems require
additional
agents, which can double or triple the number of concurrent
processes required.  Neither Mac, DOS, nor Windows are viable for these
kinds of applications. (Do you really want to round up, network together,
and dedicate 4 to 12 PCs every time you want to work on an exercise?)  On
the other hand, a single Unix workstation suffices for all the examples in
this book.

Second, although multimedia is certainly the shape of things to come, the
overwhelming majority of today's computer-mediated collaboration is textual
in nature.  For efficient, high-level, and {\em programmatic} manipulation
of textual information, Emacs has no rivals. For example, we once conducted
performance analyses for Egret that compared an Emacs client with an
equivalent C++ client, and found that the Emacs client ran twice as fast as
the one written in C++. This is because Emacs implements its most
frequently used Lisp functions in highly optimized C code, far better
suited to textual manipulation than the string manipulation facilities
found in generic C++ libraries.  For another example, many advanced
applications require the collaborative system to ``look over the shoulder''
of the user, so as to learn the user's preferences or to infer the progress
of the task.  Emacs offers a robust and common environment for such
collaborative monitoring, whether the activity is editing of documents,
programming, e-mail, net-surfing, or news reading.

Third, the choice of Lisp is dictated by the choice of Emacs, since it uses
Lisp as its internal programming environment.  Beyond that, Lisp offers
some special advantages for collaborative systems.  For example, Egret
supports communication of both data and functions between clients.
Exploring the potential of such a mechanism in Egret is useful, for
example, to those who later find themselves programming in Java, a new
language for WWW browsers.

Finally, although an Egret collaborative system requires Unix, Emacs, and
Lisp, it is not limited to these platforms.  For example, Egret can be used
as the ``coordination infrastructure'' for a collaborative system in which
actual users interact through a combination of mail, news, and web clients.
Rather than use Emacs, a user might fill out a WWW form that invokes a
script that sends a command to an Egret agent.

In summary, we believe that the time you invest in using Unix, Emacs, and
Lisp to learn about collaborative systems will provide a handsome return on
two levels.  First, these infrastructure choices vastly simplify the
introduction and exploration of issues in advanced collaborative systems.
Many concepts would be prohibitively difficult to introduce at all on most
other platforms. Second, some facility with Unix, Emacs, and Lisp is
valuable knowledge for any software professional.  At the very least,
you'll never view Visual Basic and Windows quite the same way again :-).
 
\section{A note about the exercises}

During the development of this book, we tracked how long it took to
complete the exercises, how large the solutions were, and how difficult the
beta-testers felt each exercise to be.  The average time spent, average
lines of code in a solution, and the average difficulty is specified for
each exercise as a result of these experiences.  Please feel free to
contribute to this on-going data collection process by e-mailing
johnson@hawaii.edu with your own outcomes.






