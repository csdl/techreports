\section{Apriori algorithm}\label{apriori}
I have mentioned several applications of the Apriori algorithm while reviewing temporal patterns mining from symbolic time-points and time-interval series. Family of Apriori algorithms was proposed in 1995 by Agrawal \& Srikant \cite{citeulike:775528}. These algorithms are based on the naive \textit{apriori association rule} stating that \textit{any sub-pattern of a frequent pattern must be frequent}. 

The authors has shown application of algorithms to the mining of recurrent behavior patterns from a database of purchase transactions. They used a support function which is defined as the fraction of the customers supporting such a pattern. The problem solved in this work with Apriori algorithm can be stated formally: ``given a database of customer transactions, find the set of maximal sequences among all others that have at least user-specified support''.

The naive Apriori algorithm starts by building a set of maximal sequences through finding all ``candidate'' patterns of size $1$ with a support value which is greater or equal to the minimal. On the next step, the algorithm generates a successive set of candidate patterns by extending each of the candidate patterns by $1$, and testing it against the database for sufficient support. The algorithm iterates over this second step, until it terminates when no further extension is possible, yielding a set of maximal sequences. While being simple, and proven to produce a correct solution, the naive approach is extremely inefficient due to the high time cost of the database scanning phase, which is the product of a time needed for a single pass over the database and the number of generated candidates.

\begin{table}
\begin{center}
    \begin{tabular}{ | c | c | c |}
    \hline
    Large 3-sequences & Candidate 4-sequences                     & Candidate 4-sequences \\ 
                      & after join                                & after pruning \\ 
    \hline
    $\left\{ 1, 2, 3 \right\} $ & $ \left\{ 1, 2, 3, 4 \right\} $ & $ \left\{ 1, 2, 3, 4 \right\} $ \\ 
    \hline
    $\left\{ 1, 2, 4 \right\} $ & $ \left\{ 1, 2, 4, 3 \right\} $ & \\ 
    \hline
    $\left\{ 1, 3, 4 \right\} $ & $ \left\{ 1, 3, 4, 5 \right\} $ & \\ 
    \hline
    $\left\{ 1, 3, 5 \right\} $ & $ \left\{ 1, 3, 5, 4 \right\} $ & \\ 
    \hline
    $\left\{ 2, 3, 4 \right\} $  &                                & \\ 
    \hline
    \end{tabular}
    \caption{Illustration of Apriori algorithm generative function by Agrawal \& Srikant \cite{citeulike:775528}. 4-sequences candidates are generated from 3-sequences by join and pruned in turn.}
    \label{fig:apriori}
    \end{center}
\end{table}

The significant improvement of the naive approach was a main contribution of Agrawal \& Srikant. First of all, they designed a clever generative function which excludes non-existing sequences of length $n+1$ just by looking on the existing set on sequences of length $n$ without scanning. The author's implementation of this generative function leverages the efficiency of an in-memory hash-tree and a breadth-first search. Further improvement of the naive algorithm made by authors, is that a database of transactions is getting transformed (shrunk) on the each iterative step. During this transformation each of the individual transactions within single sequence is replaced by the ``set of all litemsets contained in that transaction. If a transaction does not contain any litemset, it is not retained in the transformed sequence.'' The ``litemset'' here refers to the itemset with a minimum support.

AprioriAll, AprioriSome and DynamicSome by Agrawal \& Srikant were the very first algorithms for sequential pattern mining built upon the Apriori principle. While being far more efficient than a naive implementation, they still require many passes over the database while testing candidate sequences. Many other algorithms based on this implementation were proposed. In 1996 Srikant \& Agrawal extended their original work with GSP (Generalized Sequential Pattern) algorithm. GSP allows time constraints and relaxes the definition of transaction; additional improvement was added by using a knowledge of taxonomies, use of which prunes search space by excluding non-interesting sequences. Wang et al. in 2001 proposed a GSP-based MFS (Mining Frequent Sequences) \cite{citeulike:5164952} algorithm based on the concept of \textit{pre-large sequences} which further reduces the amount of rescanning.