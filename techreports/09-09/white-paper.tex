\documentclass[11pt,oneside]{article}
\usepackage{fullpage}
\begin{document}
\title{Dissertation proposal abstract}
\author{Pavel Senin \\
 \texttt{senin@hawaii.edu}
}
\date{July 2009}
\maketitle

\section{Motivation}
Since the first computers were build and first programs written many research was done on understanding of both: programming and programs. In contemporary understanding the human activity called ``\textit{programming}'' consists of many iterative, high-level phases and interleaving activities such as planning, writing, testing, debugging, and maintaining the source code of computer programs. Each of these phases in turn encloses many of low-level continuous processes and episodes. In addition to that, social interactions among developers and between developers and users are adding even more complexity into each phase of the programming. The computer program (\textit{computer system}, or \textit{software}) itself, from other hands, has it's own lifecycle which is directed by users and a programming effort but also, as observed in many cases, programs, especially large software systems, tend to be ``orchestrating'' all needed programming activities and social interactions. All of this creates a great process complexity due to unclear dependencies and spurious connections between different activities making an understanding of a software development process and software evolution difficult.

As a systematic study, the process of ``understanding'' of software process involves measurements, comparisons and validation experiments. Over the years many work has been done in order to discover and standardize metrics for programming activity and a software. Currently we have a rich variety of software utilities aiding the collection and analysis of a software process metrics. All of these findings and available tools created a rich ground for investigation of the software process and many successful work has been done discovering various specific patterns and characterizing metrics and features. Some of this research resulted in a such mature software process models as CMM, ISO, PSP etc. which were recognized as industry standards.

Nevertheless, software development process stays error-prone and many, more than a half, of all software development projects ending up failing for many reasons. Some of them getting abandoned running out of budget, some delivered with so low quality or so late that they become useless and some, when delivered, never get used by prospective users because they do not fulfill original requirements. The cost of this lost effort is enormous and it clearly reveals our incomplete knowledge of the software process fueling up continuous research in the field. 

\section{Contribution and impact}
At the ICS Department of the University of Hawaii we are developing an advance in-process software engineering measurement and analysis system called Hackystat which is aiding our own research in the field of software process. Personally, having three years of experience with Hackystat as a user and participating in the design and development of lwo last versions of Hackystat for more than two years, I see this software system as an ``one-stop shopping place'' for metrics collection utilities, storage database, analysis engine and visualization modules. The latest Hackystat implementation is a sophisticated distributed, service-oriented system which provides users not only with visualization of all metrics and their derivatives, but aids the understanding of metrics trend dynamics through the system of rules and alarm indicators. What the system is lacking in my opinion is it's own intelligent ability to discover novel rules and patterns in the software process and connecting them with some known phenomena. Currently I am conducting research, developing software tools and planning validation experiments in effort to cover this gap.

I am developing a Hackystat module called Trajectory which will aid the discovery of a novel knowledge about the software process through the utilization of unsupervised learning algorithms altered to the domain specificity. This module will alleviate the existing complexity of the in-process and post-process analyses, that are performed mostly manually, through the ``eyballing'', and require an advance (expert level) understanding of both: process metrics and the underlying generative processes. By utilizing current state of the art knowledge discovery and data mining algorithms and a domain knowledge, Trajectory software will provide user with discovered strong episodal and sequential patterns as well as with ``surprise'' patterns, which frequency is highly different from the expected one. Implementation of the clustering algorithms will also aid the classification analyses of the Hackystat telemetry streams.

\section{Approach and Methods}



Usually the event of observation of a software phenomena such as defect, or unusual pattern or trend eyeballed 


trends was observed and metrics and events were discovered. lately rules whether the  discovery of certain featured process and later investigation of it through the metricative effort.


\section{Methods}

\end{document}
