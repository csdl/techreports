\chapter{Introduction}
\section{Motivation}
A \textit{software process} is a set of activities performed in order to design, develop and maintain software systems. Examples of such activities are: design methods; requirements collection and creation of UML diagrams; requirements testing; and performance analysis. The intent behind a software process is to structure and coordinate human activities in order to achieve the goal - deliver a software system.

Much work has been done in software process research resulting in a number of industrial standards for process models (CMM, ISO, PSP etc. \cite{citeulike:5043104}) which are widely accepted by many institutions. Nevertheless, software development remains error-prone and more than half of all software development projects ending up failing or being very poorly executed. Some of them are abandoned due to running over budget, some are delivered with such low quality or so late that they are useless, and some, when delivered, are never used because they do not fulfill requirements. The cost of this lost effort is enormous and this fact reveals our incomplete understanding of software process.

There is a long history of software process improvement through proposing specific patterns of software development. For example, the Waterfall Model process proposes a sequential pattern in which developers first create a Requirements document, then create a Design, then create an Implementation, and finally develop Tests. The Test Driven Development process proposes an iterative pattern in which the developer must first write a test case, then write the code to implement that test case, then refactor the system for maximum clarity and minimal code duplication. One problem with the traditional top-down approach to process development is that it requires the developer or manager to notice a recurrent pattern of behavior in the first place \cite{citeulike:5043104}. 

In my research, I will apply knowledge discovery and data mining techniques to the domain of software engineering in order to evaluate their ability to automatically notice interesting recurrent patterns of behavior. While I am not proposing to be able to infer a complete and correct software process model, my system will provide its users with a formal description of discovered recurrent behaviors in software process. As a simple example, consider a development team in which committing code to a repository triggers a build of the system. Sometimes the build passes, and sometimes the build fails. To improve the productivity of the team, it would be useful to be aware of any recurrent behaviors of the developers. My system might generate one recurrent pattern consisting of a) implementing code b) running unit tests, c) committing code and d) a passed build: $i \rightarrow u \rightarrow c \rightarrow s $, and another recurrent pattern consisting of a) implementing code, b) committing code, and c) a failed build: $i \rightarrow c \rightarrow f $. The automated generation of these recurrent patterns can provide actionable knowledge to developers; in this case, the insight that running test cases prior to committing code reduces the frequency of build failures.

Although the latest trends in software process research emphasize mining of software process artifacts and behaviors \cite{citeulike:5043664} \cite{citeulike:1885717} \cite{citeulike:5112229} \cite{citeulike:1885717}, to the best of my knowledge, the approach I am taking has never been attempted. This may be partly due to the lack of means of automated, real-time data collection of fine-grained developer behaviors. By leveraging the ability of the Hackystat system \cite{citeulike:4041809} to collect such a fine grained data, I propose to extend previous research with new knowledge that will support improvements in our understanding of software process.

\section{Proposed contribution}
In summary, the proposed contributions of my research will include: 
\begin{itemize}
	\item the implementation of a system aiding in discovery of novel software process knowledge through the analysis of fine-grained software process and product data;
	\item experimental evaluation of the system, which will provide insight into its strengths and weaknesses;
	\item the potential discovery of useful new software process patterns.
\end{itemize}

\section{Roadmap}
This proposal has the following organization:
\begin{itemize}
	\item Chapter \ref{related.work}, section \ref{process.discovery} presents a review of the literature related to process discovery with application to software process. The methods discussed in this chapter are the high-level frameworks which are used for the process inference from the abstracted process artifacts. Section \ref{methods} presents a review of the literature related to temporal pattern discovery methods along with the construction of the symbolic time-point, time-interval, and event streams.
	\item Chapter \ref{trajectory} describes the requirements and presents the current state of Software Trajectory framework for automated software process discovery.
	\item Chapter \ref{experiments} describes pilot study results and outlines the planned experimental evaluation of my research.
	\item Chapter \ref{contribution} discusses anticipated contribution in greater detail and presents the estimated timeline.
\end{itemize}
