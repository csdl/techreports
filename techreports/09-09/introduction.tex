\chapter{Introduction}
\section{Motivation}
A \textit{software process} is a set of activities performed in order to design, develop and maintain software systems. Examples of such activities include design methods; requirements collection and creation of UML diagrams; requirements testing; and performance analysis. The intent behind a software process is to structure and coordinate human activities in order to achieve the goal - deliver a software system successfully.

Much work has been done in software process research resulting in a number of industrial standards for process models (CMM, ISO, PSP etc. \cite{citeulike:5043104}) which are widely accepted by many institutions. Nevertheless, software development remains error-prone and more than half of all software development projects ending up failing or being very poorly executed. Some of them are abandoned due to running over budget, some are delivered with such low quality or so late that they are useless, and some, when delivered, are never used because they do not fulfill requirements. The cost of this lost effort is enormous and may in part be due to our incomplete understanding of software process.

There is a long history of software process improvement through proposing specific patterns of software development. For example, the Waterfall Model process proposes a sequential pattern in which developers first create a Requirements document, then create a Design, then create an Implementation, and finally develop Tests. The Test Driven Development process proposes an iterative pattern in which the developer must first write a test case, then write the code to implement that test case, then refactor the system for maximum clarity and minimal code duplication. One problem with the traditional top-down approach to process development is that it requires the developer or manager to notice a recurrent pattern of behavior in the first place \cite{citeulike:5043104}. 

In my research, I will apply knowledge discovery and data mining techniques to the domain of software engineering in order to evaluate their ability to automatically notice interesting recurrent patterns of behavior. While I am not proposing to be able to infer a complete and correct software process model, my system will provide its users with a formal description of recurrent behaviors in their software development. As a simple example, consider a development team in which committing code to a repository triggers a build of the system. Sometimes the build passes, and sometimes the build fails. To improve the productivity of the team, it would be useful to be aware of any recurrent behaviors of the developers. My system might generate one recurrent pattern consisting of a) implementing code b) running unit tests, c) committing code and d) a passed build: $i \rightarrow u \rightarrow c \rightarrow s $, and another recurrent pattern consisting of a) implementing code, b) committing code, and c) a failed build: $i \rightarrow c \rightarrow f $. The automated generation of these recurrent patterns can provide actionable knowledge to developers; in this case, the insight that running test cases prior to committing code reduces the frequency of build failures.

Although the latest trends in software process research emphasize mining of software process artifacts and behaviors \cite{citeulike:5043664} \cite{citeulike:1885717} \cite{citeulike:5112229} \cite{citeulike:1885717}, to the best of my knowledge, the approach I am taking has never been attempted. This may be partly due to the lack of means of automated, real-time data collection of fine-grained developer behaviors. By leveraging the ability of the Hackystat system \cite{citeulike:4041809} to collect such a fine grained data, I propose to extend previous research with new knowledge that will support improvements in our understanding of software process.

\section{Proposed contribution}
In summary, the proposed contributions of my research will include: 
\begin{itemize}
	\item the implementation of a system aiding in discovery of novel software process knowledge through the analysis of fine-grained software process and product data;
	\item experimental evaluation of the system, which will provide insight into its strengths and weaknesses;
	\item the possible discovery of useful new software process patterns.
\end{itemize}

\section{Roadmap}
This proposal has the following organization:
\begin{itemize}
	\item Chapter \ref{related.work} presents a review of the literature related to software process discovery. Methods discussed in the Section \ref{process.discovery} are high-level frameworks which are used for software process inference from abstracted process artifacts. Section \ref{evolution.discovery} presents up to date progress in the mining of software repositories. Section \ref{methods} presents a review of research related to construction of the symbolic time-point and time-interval series and pattern discovery from a temporal symbolic data.
	\item Chapter \ref{trajectory} describes the requirements for the system and presents the current state of my Software Trajectory framework for automated software process discovery.
	\item Chapter \ref{experiments} describes pilot study results and outlines the planned experimental evaluation of my research.
	\item Chapter \ref{contribution} discusses the anticipated contributions in greater detail and presents the estimated timeline.
\end{itemize}
