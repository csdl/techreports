\chapter{Software Process}
There are different approaches for software development which were designed in order to 
support the creation of software systems. One of the aspects of all is the use of 
software process model. This model provides developers with guidance about their tasks 
and the activities that should be undertaken during development. It is advocated that the 
use of established and well structured model is crucial for the complex projects to 
orchestrate collaborative effort of multiple teams working on the software product. 

These models (or methodology) can be characterized by the series of distinct phases. 
Each phase is executed in order to provide a part of the software system or revise 
an existing part. Examples of such phases are the requirements collection, user manual 
or the functional module of the software system. While the methodology is applied for 
such a process it is not only prescribes an ordering of carried activities, but 
provides a framework for estimation of resources, definition of milestones, managing 
time and effort and monitoring the progress. 

\section{Waterfall model}
Many variation of the original Royce's (1970) waterfall model 
\cite{citeulike:9982731}  exist.
This is the probably the oldest of formal software process models and it is very popular 
for large and complex systems. It is an example of a plan-driven process - one must 
plan and schedule activities before execution. The waterfall 
model forms the basis of many standards in the industry. It is a refinement of a 
stagewise model developed in 50th (boehm?).

There is successive and distinct progression of stages in waterfall model; each state 
is well defined and forms the basis for the successive one. In addition to specific 
deliverable, each state producing a document which describes what exactly occurred 
during the stage, providing certain visibility to the processes, and facilitating 
audit. Each state has milestones and deliverables explicitly defined.

Five stages of waterfall model reflect the fundamental development activities:
\begin{enumerate}
 \item \textit{Requirements analysis and definition.} The feasibility study 
is conducted 
and the requirements collected. The system functionality clarified and
documented in details - the requirements specification document - delivered  
and will serve as the system specification. It is assumed that customer's 
expectations are articulated and will not change much throughout the development 
process.
 \item \textit{The system design.} Within this phase requirements for hardware and 
software components defined by the establishing an overall system architecture.
All system modules and their interactions are designed in accordance with 
collected requirements.
 \item \textit{Implementation and unit testing.} The actual code produced, individual 
modules are tested individually. This phase embeds all quality control checks.
 \item \textit{Integration and system testing.} System assembled and once complete, it
is tested and evaluated in actual conditions (alpha tested).
 \item \textit{Delivery and Maintenance.} System is tested by actual customer(s) 
(beta testing). Identified errors are corrected and if found satisfiable, 
software system is installed and put into use. Maintenance involves error correction, 
improvements of system units and enhancements of services if desired.
\end{enumerate}

During transition from stage to stage within the waterfall model, previous state 
should be signed-off - approved to be in finished state. In other 
word, states should not overlap, however in the real life problems often discovered
later on - for example it is often happens that problems with design 
discovered only after implementation is started and so on. In such situation
process returns to the problematic phase and changes are made and reflected in 
the documentation. These iterations are very costly in time and effort and 
usually after a certain number of iterations problematic stages considered 
``frozen'' and development continues. Identified and not resolved issues persist
through the further work and if possible - covered by workarounds, if not - 
they just ignored and system may not perform correctly or lack some functionality 
afterwards.

The big advantage of waterfall model of software development process is that 
it is consistent with other engineering models in terms of general approach, 
its flow and produced documentation. It seems to be manager-friendly too since
it is easy to track the progress against the development plan. The major 
problem however is that waterfall model is inflexible, all stages are 
partitioned and even small change in requirements are very hard to incorporate 
after first stages are done.

\subsection{Cleanroom software engineering}
One of the waterfall model derivatives is a Cleanroom software engineering, which is
a fusion of waterfall model with formal methods approach. 
Following the formal methodology, stages of waterfall model reshaped into 
\begin{enumerate}
 \item \textit{Formal specification} phase, where the software system is presented as 
a state-transition model with input and output. The states of the system and
its transitions (reactions on input) reflect specification and requirements.
 \item \textit{Structured, incremental development} phase 
\end{enumerate}

1) formal specification phase; 2) incremental, formal development and verification 
, formal methods are a particular kind of mathematically-based techniques for
the specification, development and verification of software and hardware systems

\section{}

The Institute of Electrical and Electronics Engineers defines software engineering as 
“the application of a systematic, disciplined, quantifiable approach to development, 
operation, and maintenance of software; that is, the application of engineering software”
