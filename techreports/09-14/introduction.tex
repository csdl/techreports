\chapter{Introduction}
Delivering high quality software products within the budget and in time is the main goal and the most 
challenging task of Software Engineering. Years of scientific research in
this area resulted in a number of software processes providing detailed guidelines on how to reach 
the goal efficiently. Many of these processes were successfully standardized and adopted 
in industry shaping the best practices of contemporary software development. 
It is interesting to see, that all these formalizations of the process lead to some sort of paradox 
in which programming, once qualified as a creative human activity, accessible by amateurs 
and hobbyists become bounded by requirements for education, rules for development, standards for 
processes, certifications and strict financial requirements from stakeholders. And what is even more 
interesting, is that in the present time we observe an opposite movement against this particular order 
of things - against the ``software production'' - the movement of 

Volumes of research literature propose various processes and manifest them as the 
means for improvements of a software development in terms of quality, speed and cost. 
Many of these processes were implemented and tested within academic and industrial 
settings proving proposed characteristics. These include large formalized processes: 
Waterfall and Spiral as well as more flexible Agile and SCRUM. 
There are also sets of rules and recommendations which can be applied to certain 
stages of these software process such as Test Driven Development or Pair Programming; 
and finally there are general guidelines helping to improve the correctness of a 
product - rules for naming variables, formatting code blocks and commenting the code. 

However, only ``35\% of software projects in 2006 can be categorized as successful - meaning 
they were completed on time, on budget and met user requirements'' according to Chaos Report
from the Standish Group (Rubinstein) \cite{SDTimes}. Taking all of this into account it is 
somewhat difficult to make a statement that we are fully understand and able to control 
software process. Thus, there is a great room for research and improvement.

This exploratory study is yet another attempt at understanding of the software development processes. 
In my research work I am exploring techniques aiming the understanding of small processes which are 
rather the reflection of personal behaviors or habits of software development rather than a 
formalized constructs. Also, I would like to emphasize, that in this work I will not 
address the need and means of the process synthesis, its quality assessment, productiveness
or any topics related to the software product itself; I would rather focus on the specific issue - 
uncovering an existence and studying the programming habits. 

This thesis presents a methodology for finding recurrent behaviors through the 
analysis of the variety of software process artifacts left after performing a 
software process. I have called this methodology ``Software Trajectory'' and it consists 
of four distinct steps. Each of these steps has a specific goal and compromising variety of 
means to reach it. 
At first software process artifacts are identified and collected. 
At second, they are cleaned, organized and classified. 
On the third step particular research questions are formulated and data are organized and indexed. 
And finally, a set of KDD techniques is applied in order to undercover recurrent behaviors which 
could potentially shed a light on the performed process details. 

My personal motivation for performing this work is coming from the recognition of the 
importance of the software in our lives and the severity of issues with its development. 
Through my everyday experiences with software development and use I have stumble upon 
a number of issues which made me realize that mentioned ``software crisis'' phenomena is very real.
As a user in industrial and academic settings I often find myself facing software failures 
which create numerous difficulties for reaching production or research goals. As a developer, 
in an attempt to be productive and in order to deliver a better software I have studied and 
explored a number of formal processes, however, sometime I found myself seeing a very little of 
rationale behind their application, and moreover, in this exploration, when facing the process
application failing to help I was unable to comprehend what exactly went wrong and what need 
to be changed. All of these experiences made me studying software process research and exploring
novel approaches to software process recovery on my own in order to understand software process better.

\section{Research area overview}
As mentioned above, in this thesis I am focusing on a very narrow subject - exploring approaches
for uncovering of recurrent behaviors or ``programming habits'' out of software process artifacts.
Before narrowing further 


Software is usually coded by teams. Members of these teams are agreed and bound to use 
a particular technologies and development tools, they also agree on following well defined 
development process which is constrained by a timeline and budget. These are necessary 
constraints to keep work organized, however there is a great freedom in what they actually 
do in every single moment of time in order to progress towards lines of code which eventually 
will result in software. For example one developer may follow test first process while
another writes tests at last.  This freedom of choice in ordering of development activities 
while being much appreciated by talented and creative individuals creates an impression 
of chaotic and unordered activities for random observers, newbies and people in 
charge - so there we have all the attempts of imposing an order 
(or control) on all of the development activities. Metrics and models of processes




