\chapter{Introduction}

\section{Motivation}
Delivering high quality software products within the budget and in time is the main goal and the most 
challenging task of Software Engineering. Years of scientific research in this area resulted in a 
number of software processes providing detailed guidelines on how to reach the goal efficiently. 
These processes manifested themselfs as the means for improvements in terms of quality, 
speed and execution cost over existing practices. Many were implemented and tested within academic 
and industrial settings proving proposed superiority. Some of the processes were adopted and standardized 
in industrial settings, shaping the best practices of contemporary software development \cite{citeulike:9962021}. 

The processes I am mentioning here include well-known large industrial software models
such as Waterfall and Spiral; standards and reccomendations, like CMMI, ISO 9000, and SPICE; 
the smaller and flexible agile approaches like XP, SCRUM or FDD; 
rules and recommendations, such as Test Driven Development or Pair Programming; 
many general guidelines to improve the process flow; and processes for improving existing processes of 
software development on the team and personal levels \cite{citeulike:9962027} \cite{citeulike:9962022}.
All these instructions resulted from numerous studies and described at length in academic and 
industrial literature. Virtually for any size of the project and the team, there are applicable 
standards, processes, coding conevtions at any level of the development process.

This amount of knowledge creates an impression that the area of software development 
process is thoroughly explored and there is a clear deterministic choice for a model and processes 
for any software project, however, it is very far from being true - software projects still fail 
and there are many challenges exist when developing a software product.
This phenomena also known as a ``software crisis'' was first recognized by Randell et al. in 1976 
\cite{naur1976software}. The attention was caught by the fact that many software projects ran 
over budget and schedule, some caused property damage, and a few projects caused 
loss of life \cite{citeulike:712058}. Decades later, the ``Chaos Report'' from the Standish 
Group (Rubinstein) \cite{SDTimes} stating, that only ``35\% of software projects in 2006 can 
be categorized as successful - meaning they were completed on time, on budget and met 
user requirements''. These thirty five percent of success clearly manifest that it is somewhat 
early to make a statement that we are fully capable to understand and to control software processes.

In recent decades, the poor performance of mainstream direction in the field of software processes
settled some doubts over the idea of direct applicability of classical engineering and
straightforward ``up-down'' direction in governing of software process. Researchers and practitioners
Over many years, the mainstream idea of succesful software process 
a software process formalizations shaped the programming practices, 
which once thought to be a creative human activity accessible by amateurs 
and hobbyists \cite{citeulike:9958822}, into a serious engineering discipline. 
Currently, it is not only difficult to to become a software engineer due to the education 
requirements and desired by industry experience threshold, but once in the field, one is 
strictly bounded by development rules, processes, forced to confirm with certifications, 
and constantly under pressure by budget requirements. 
 from stakeholders the opposite idea was born - the idea of 
software development as a craft. Interesting that such a duality of views can be found 
in the work of a single person \cite{citeulike:5203446}.



 documentation many 
use stories and studies all the known facts and application of logical 
reasoning, it is extremely diffcult to foretell what is the ``best'' process to choose for a 
certain software project. This uncertainty only increases with the growth of the project complexity.
What managers are left with, are the equally succesfull alternatives with vague promises. 

Clearly, there is a great room for research and improvement of our understanding of software processes.
This exploratory study is yet another attempt at the understanding. In my research work I am 
exploring techniques aiming the understanding of small processes which are 
rather the reflection of personal behaviors or habits of software development rather than a 
formalized constructs. Also, I would like to emphasize, that in this work I will not 
address the need and means of the process synthesis, its quality assessment, productiveness
or any topics related to the software product itself; I would rather focus on the specific issue - 
uncovering an existence and studying the programming habits. 

This thesis presents a methodology for finding recurrent behaviors through the 
analysis of the variety of software process artifacts left after performing a 
software process. I have called this methodology ``Software Trajectory'' and it consists 
of four distinct steps. Each of these steps has a specific goal and compromising variety of 
means to reach it. 
At first software process artifacts are identified and collected. 
At second, they are cleaned, organized and classified. 
On the third step particular research questions are formulated and data are organized and indexed. 
And finally, a set of KDD techniques is applied in order to undercover recurrent behaviors which 
could potentially shed a light on the performed process details. 

My personal motivation for performing this work is coming from the recognition of the 
importance of the software in our lives and the severity of issues with its development. 
Through my everyday experiences with software development and use I have stumble upon 
a number of issues which made me realize that mentioned ``software crisis'' phenomena is very real.
As a user in industrial and academic settings I often find myself facing software failures 
which create numerous difficulties for reaching production or research goals. As a developer, 
in an attempt to be productive and in order to deliver a better software I have studied and 
explored a number of formal processes, however, sometime I found myself seeing a very little of 
rationale behind their application, and moreover, in this exploration, when facing the process
application failing to help I was unable to comprehend what exactly went wrong and what need 
to be changed. All of these experiences made me studying software process research and exploring
novel approaches to software process recovery on my own in order to understand software process better.

\section{Research area overview}
Usually, software is coded by teams. Members of these teams have a variety of skills and experience, and
driven by their believes and motivations. While they usually agree on the use of particular technologies, 
development tools, and a development process with imposed timeline and a budget, the software development
activity is - as many other human activities - highly creative and mostly non-recurring. 
Thus, the choice of technology and tools provides only a marginal effect on this human-based and 
human-driven process. The common approach for studying this effect is to use the control environment 
for experiment and factor out human component and 

These are large scale industrial model such as Waterfall and Spiral, along with 
smaller and flexible agile approaches like XP, SCRUM or FDD. These also include sets of 
rules and recommendations which can be applied to certain stages of the software processes 
such as Test Driven Development or Pair Programming; general guidelines, helping 
to improve the process flow; standards and reccomendations, like CMMI, ISO 9000, and SPICE; 
guidlines for testing and measurements, code syntax rules and formatting styles, code comments 
recomendations \cite{citeulike:900855} etc. Finally, these include processes for 
improving existing processes of software development on the team \cite{citeulike:9962027} 
and personal levels \cite{citeulike:9962022}.

The plethora of these instructions, applicable for any software project at any level, creates 
an impression that the research area of software process is thoroughly explored and there 
is a deterministic choice for a model and processes for any software project, however,
it is very far from being true - software projects still fail and there are many challenges exist 
when developing a software product.
This phenomena also known as a ``software crisis'' was first recognized by Randell et al. in 1976 
\cite{naur1976software}. Thirty years later, the ``Chaos Report'' from the Standish 
Group (Rubinstein) \cite{SDTimes} stating, that only ``35\% of software projects in 2006 can 
be categorized as successful - meaning they were completed on time, on budget and met 
user requirements''. These thirty five percent of success clearly manifest that it is somewhat 
early to make a statement that we are fully understand and able to control software processes.
Moreover, it makes questionable the main direction of software process research.

Moreover, over years, while this idea of a software process formalizations shaped the 
programming practices, which once thought to be a creative human activity accessible by amateurs 
and hobbyists \cite{citeulike:9958822} into a serious engineering discipline, bounded 
by requirements for education, standardized processes, rules, certifications, and strict 
financial requirements from stakeholders the opposite idea was born - the idea of 
software development as a craft. Interesting that such a duality of views can be found 
in the work of a single person \cite{citeulike:5203446}.


, the effect which can be found by factoring out human component. \todo{here must add stuff}
While the particular are of ``software process'' effect is well studied by using controlled environment 
and conducting a series of studies. We must admit, however, that this approach provides a very poor metric - 
the ``local efficiency'' which refers to the efficiency and effectiveness of the tool or technique when it 
is applied in isolation from larger application context. 
For example, the typical efficiency study is limited to a specific type of development 
artifact, by a typical class of developers (with homogenous training and experience levels) 
regardless of the other techniques and entities involved in a real life development process. 
As a contrary  - the ``global efficiency'' of a tool or technique, relates to its role and 
impact on the whole project performance while considering all other tools and techniques 
involved in the entire development process and their interactions. Typically, global efficiency 
and effectiveness is very difficult to evaluate due to the cost of the study and its complexity.


As mentioned above, in this thesis I am focusing on a very narrow subject - exploring approaches
for uncovering of recurrent behaviors or ``programming habits'' out of software process artifacts.








