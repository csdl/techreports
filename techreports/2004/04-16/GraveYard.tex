\section{COCOMO II}

During recent years, various COCOMO extensions emerge. They are
\begin{itemize}
  \item CPSEMO - Phase Schedule and Effort Estimation (on what basis do
they distribute effort???)
  \item CORADMO - Rapid Application Development Estimation
  \item COCOTS - COTS Integration Estimation
  \item COQUALMO - Quality Estimation (tradeoff, by Sunita?)
  \item COPROMO - Productivity Estimation
  \item Expert COCOMO - Risk Assessment (to read...)
  \item Dynamic COCOMO - System Dynamics and Simulation (Ray)
\end{itemize}

%% COCOMO Process Assumption
COCOMO II has been developed to be usable by projects employing
either waterfall or spiral process. [Cocomo II book, p301].

However, in order to be compatible with what the model estimates,
the waterfall process needs to be strongly risk-driven in order to
avoid incurring large amount of rework not included in
spiral-model-based estimates. On the other hand, the spiral
process needs to have a set of well-defined common milestones,
which can serve as the end points between which COCOMO II
estimates and actuals are assessed.

The implication is that COCOMO II is not suitable for XP style
programming, where no specific project end point is defined.


%%\subsubsection{Development Phases Covered}

COCOMO II estimates covers core software development phases (from
determination of a product's requirements baseline to the
completion of an acceptance activity certifying that the product
satisfies its requirements).

The phases outside the core are not covered (i.e. Plans \&
Requirements and Transition for Waterfall; Inception and
Transition for MBASE/RUP), since there are large variations
between projects and not enough calibration data for the outer
phases have been accumulated. [Cocomo II book, p308].

[Fig in P307 goes here]


%%\subsubsection{Size Input}

COCOMO II only uses size data that influences effort, which is new
code and code that is copied and modified. [Cocomo II book, P14].
For reused code, a method is provided to make it equivalent to new
code, so that they can be aggregated.

COCOMO II uses a factor called REVL to adjust the effective size
of the product caused by requirements evolution. REVL represents
the percentage of code discarded.

  \begin{equation}\label{size equation}
    SIZE = (1 + REVL \div 100) * (Delivered Software Size)
  \end{equation}

For example, if the final delivered software size is 100K, but 20% of
code is discarded during development, then 120K should be used as
size input for effort estimation.From the above discussion,
absolute code size (code churn) should be used as size input.






\subsubsection{COCOTS}

As the use of commercial-off-the-shelf components becomes ever
more prevalent in the creation of large software systems, the need
for the ability to reasonably predict the true lifetime cost of
using such software components grows.


Using COTS components brings the immediate short-term gains in
direct development effort and schedule. At the same time it also
brings the risks that is not normally associated with creating
components from scratch, such as unavailable source code and no
direct control over future evolution of COTS components .

COCOTS \ref{COCOTS:a} tries to predict the life cycle costs of
using COTS components by capturing the more significant COTS risks
in its modeling parameters.

Currently, COCOTS only addresses the \textit{initial} development
costs associated with using COTS components. It does not cover
long-term life cycle and maintenance costs for projects using COTS
components.

In terms of a waterfall process, the specific phases covered are:
\begin{itemize}
  \item Requirements Definition
  \item Preliminary Code Design
  \item Detailed Code Design and Unit Test
  \item Integration and Test
\end{itemize}

Specifically, it includes the requirements definition phase, which
is not covered under normal COCOMO estimates.





\subsubsection{Dynamic COCOMO}

Dynamic COCOMO is an extension based on cost parameters that vary
continuously over time. It provides a simulation model using
system dynamics that implement COCOMO with varying degrees of
assumptions, including information feedback loops.