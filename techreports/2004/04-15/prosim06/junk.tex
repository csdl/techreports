and planning processes to the level of the individual developer.  In the
PSP (and the more recent Team Software Process (TSP)), developers are
expected to record activities such as planning, compilation, and debugging
activities, each of which might take from minutes to hours.  More recently,
the test-driven development methodology \cite{Beck:03} takes an even more
microscopic view of development, representing it as cycles of testing,
refactoring, implementation, and debugging, each of which might last from
only a few seconds to a few minutes.

Low-level process models are very appealing: they tend to be quite
prescriptive, and can be quite amenable to automated support. For example,
the Eclipse IDE has excellent support for both refactoring and unit test
creation and execution, which are important components of test-driven
development. Low-level process descriptions generally do not have the problems
associated with the abstraction and contextuality of high-level process
descriptions.

Compliance, however, is much more difficult to assess with low-level
process models.  Compliance is important to assess for a variety of obvious
reasons. One not-so-obvious reason to assess compliance is to reveal
inadequacies in the low-level process model and discover alternative models
that might be even more effective.  For example, if a good developer
chooses to not comply with what is presumed to be an effective process
model, then it is quite possible that the developer knows a better way of
accomplishing the task at hand than the approach dictated by the model.

Compliance is difficult to assess in low-level process models because of
the density of process-relevant actions that take place in a short time
span.  For example, the original design of the PSP required each developer
to manually log their activities, frequently leading to dozens of
interruptions per hour to record what they were doing, what resulted from
their actions, and how much time elapsed while doing it.  Not only was this
level of logging found to be unsustainable \cite{Ferguson97}, it did not
constitute an effective approach to compliance, since the data is
self-reported and the data recording process highly error-prone
\cite{csdl-98-13}.  Similar problems surround compliance with test-driven
development.

In general, there are two basic ways to approach low-level process
compliance: top-down and bottom-up.  The top-down approach involves the
creation of a toolset and development environment that enforces the process
by preventing out-of-sequence or missing/extra activities.  In some
domains, the top-down approach to process compliance is clearly
appropriate. For example, the checkout procedure at Amazon.com for customer
purchases constitutes a kind of low-level process which guarantees that all
of the steps necessary for an order are accomplished in the appropriate
order.  Top-down specification of low-level software development processes
with a precision sufficient to prevent non-process behaviors has mostly
focused on scripting tools that totally automate certain development
activities. Build tools such as Make and Ant are perhaps the most widely
used form of top-down low-level process compliance in software development.

The bottom-up approach involves the fully automatic monitoring of the
developer's behavior along with some sort of mechanism that can recognize
when the developer is complying with the process of interest and when they
are not.  The advantage of the bottom-up approach is that if it can
accurately assess compliance, it can reveal ways to improve a given
low-level process description or even replace it with a more effective one. 
The (considerable) challenge of the bottom-up approach involves the creation 
of an automated monitoring mechanism that can gather developer behavior 
in a manner appropriate for the process of interest, as well as the creation
of a recognition mechanism that can accurately distinguish process compliance for
interesting software development processes. 
